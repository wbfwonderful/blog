[{"title":"Hello World ğŸ‘‹","url":"/blog/hello-world/","content":"ğŸ˜æ¬¢è¿æ¥åˆ°æˆ‘çš„åšå®¢ä½ ä¹Ÿè®¸å¯ä»¥çœ‹åˆ°ï¼š\n\nâœï¸å­¦ä¹ è®°å½•\nğŸ’»æŠ€æœ¯åˆ†äº«\nğŸ“‘æ—¥å¸¸æµæ°´è´¦\nâ€¦\n\n"},{"title":"ã€Kaggle Coursesã€‘3-æœºå™¨å­¦ä¹ ä»‹ç»","url":"/blog/Kaggle-course/intro-to-ML/","content":"Learn the core ideas in machine learning, and build your first models. Click here for more information.\n\n\næ¨¡å‹æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Ÿ\nThe first step.\n\nå¼•å…¥è€ƒè™‘ä»¥ä¸‹åœºæ™¯ï¼š\n\nä½ è¡¨å¼Ÿåšæˆ¿åœ°äº§æŠ•æœºèµšäº†å‡ ç™¾ä¸‡ç¾å…ƒã€‚å› ä¸ºä½ å¯¹æ•°æ®ç§‘å­¦æ„Ÿå…´è¶£ï¼Œä»–æå‡ºè¦å’Œä½ æˆä¸ºå•†ä¸šä¼™ä¼´ã€‚ä»–ä¼šæä¾›é’±ï¼Œä½ ä¼šæä¾›æ¨¡å‹æ¥é¢„æµ‹å„ç§æˆ¿å­çš„ä»·å€¼ã€‚\nä½ é—®ä½ çš„å ‚å…„ä»–è¿‡å»æ˜¯å¦‚ä½•é¢„æµ‹æˆ¿åœ°äº§ä»·å€¼çš„ï¼Œä»–è¯´è¿™åªæ˜¯ç›´è§‰ã€‚ä½†æ›´å¤šçš„è´¨ç–‘è¡¨æ˜ï¼Œä»–ä»è¿‡å»çœ‹è¿‡çš„æˆ¿å­ä¸­è¯†åˆ«å‡ºäº†ä»·æ ¼æ¨¡å¼ï¼Œå¹¶ç”¨è¿™äº›æ¨¡å¼æ¥é¢„æµ‹ä»–æ­£åœ¨è€ƒè™‘çš„æ–°æˆ¿ã€‚\nâ€¦\n\nè€ƒè™‘è¿™ä¸ªç®€å•çš„å†³ç­–æ ‘ï¼šå®ƒåªæŠŠæˆ¿å­åˆ†æˆä¸¤ç±»ã€‚æ‰€è€ƒè™‘çš„ä»»ä½•æˆ¿å±‹çš„é¢„æµ‹ä»·æ ¼éƒ½æ˜¯åŒä¸€ç±»åˆ«æˆ¿å±‹çš„å†å²å¹³å‡ä»·æ ¼ã€‚\né€šè¿‡æ•°æ®æ¥å†³å®šå¦‚ä½•å°†æˆ¿å±‹åˆ†ä¸ºä¸¤ç±»ï¼ŒåŒæ—¶å†³å®šå…¶é¢„æµ‹ä»·æ ¼ã€‚ä»æ•°æ®ä¸­æ•è·æ¨¡å¼çš„è¿™ä¸€æ­¥ç§°ä¸ºæ‹Ÿåˆ(fitting)æˆ–è®­ç»ƒ(training)æ¨¡å‹ã€‚ç”¨äºæ‹Ÿåˆæ¨¡å‹çš„æ•°æ®ç§°ä¸ºè®­ç»ƒæ•°æ®(training data)ã€‚\næ”¹è¿›å†³ç­–æ ‘ä»¥ä¸‹å“ªä¸ªå†³ç­–æ ‘æ›´æœ‰æ•ˆï¼Ÿå·¦è¾¹çš„å†³ç­–æ ‘ï¼ˆå†³ç­–æ ‘1ï¼‰å¯èƒ½æ›´æœ‰æ„ä¹‰ï¼Œå› ä¸ºå®ƒæŠ“ä½äº†ä¸€ä¸ªç°å®ï¼Œå³å§å®¤å¤šçš„æˆ¿å­å¾€å¾€æ¯”å§å®¤å°‘çš„æˆ¿å­å–å¾—æ›´é«˜ã€‚è¿™ç§æ¨¡å¼æœ€å¤§çš„ç¼ºç‚¹æ˜¯ï¼Œå®ƒæ²¡æœ‰è€ƒè™‘åˆ°å½±å“æˆ¿ä»·çš„å¤§å¤šæ•°å› ç´ ï¼Œæ¯”å¦‚æµ´å®¤æ•°é‡ã€åœ°å—å¤§å°ã€ä½ç½®ç­‰ã€‚\nå¯ä»¥ä½¿ç”¨å…·æœ‰æ›´å¤šâ€œåˆ†è£‚â€çš„æ ‘æ¥æ•è·æ›´å¤šå› ç´ ã€‚è¿™äº›æ ‘è¢«ç§°ä¸ºâ€œæ›´æ·±çš„â€æ ‘ã€‚è€ƒè™‘åˆ°æ¯æ ‹æˆ¿å­åœ°å—æ€»é¢ç§¯çš„å†³ç­–æ ‘å¯èƒ½æ˜¯è¿™æ ·çš„ï¼šæˆ¿å­çš„é¢„æµ‹ä»·æ ¼åœ¨è¿™æ£µæ ‘çš„åº•éƒ¨ã€‚æˆ‘ä»¬åšå‡ºé¢„æµ‹çš„åº•éƒ¨ç‚¹è¢«ç§°ä¸ºå¶å­ (leaf)ã€‚\nåˆæ­¥æ¢ç´¢æ•°æ®\nLoad and understand your data.\n\nä½¿ç”¨ Pandas æ¥åŠ è½½æ•°æ®Pandas æ˜¯æ•°æ®ç§‘å­¦å®¶ç”¨æ¥æ¢ç´¢å’Œæ“ä½œæ•°æ®çš„ä¸»è¦å·¥å…·ã€‚å¤§å¤šæ•°äººåœ¨ä»£ç ä¸­å°† pandas ç¼©å†™ä¸º pdï¼š\nimport pandas as pd\nPandas åº“ä¸­æœ€é‡è¦çš„éƒ¨åˆ†æ˜¯ DataFrameã€‚DataFrame ä¿å­˜äº†æ‚¨å¯èƒ½è®¤ä¸ºæ˜¯è¡¨çš„æ•°æ®ç±»å‹ã€‚è¿™ç±»ä¼¼äº Excel ä¸­çš„å·¥ä½œè¡¨æˆ– SQL æ•°æ®åº“ä¸­çš„è¡¨ã€‚\nä½¿ç”¨å¦‚ä¸‹å‘½ä»¤æ¥è¯»å– csv æ–‡ä»¶ï¼Œå¹¶è¿›è¡Œå±•ç¤ºï¼š\ndf = pd.read_csv(&#x27;my_csv.csv&#x27;)df.describe()\næ›´å¤šå…³äº pandas çš„ä»‹ç»ã€‚\nå¯¹æ•°æ®çš„è§£é‡ŠæŸä¸ª csv æ–‡ä»¶é€šè¿‡ .describe() å±•ç¤ºçš„ç»“æœä¸ºï¼š\n\nç»“æœä¸ºåŸå§‹æ•°æ®é›†ä¸­çš„æ¯åˆ—æ˜¾ç¤º8ä¸ªæ•°å­—ã€‚ç¬¬ä¸€ä¸ªæ•°å­—æ˜¯ countï¼Œæ˜¾ç¤ºæœ‰å¤šå°‘è¡Œå…·æœ‰éç¼ºå¤±å€¼ã€‚\nç¼ºå¤±å€¼çš„äº§ç”Ÿæœ‰å¾ˆå¤šåŸå› ã€‚ä¾‹å¦‚ï¼Œåœ¨è°ƒæŸ¥ä¸€é—´å§å®¤çš„æˆ¿å­æ—¶ï¼Œä¸ä¼šæ”¶é›†ç¬¬äºŒé—´å§å®¤çš„å¤§å°ã€‚æˆ‘ä»¬å°†å›åˆ°ä¸¢å¤±æ•°æ®çš„è¯é¢˜ã€‚\n\n\nç¬¬äºŒä¸ªå€¼æ˜¯å‡å€¼ï¼Œä¹Ÿå°±æ˜¯å¹³å‡å€¼ã€‚åœ¨æ­¤ä¹‹ä¸‹ï¼Œstd æ˜¯æ ‡å‡†åå·®ï¼Œå®ƒè¡¡é‡æ•°å€¼çš„æ•°å€¼åˆ†å¸ƒã€‚\nåç»­äº”ä¸ªå€¼ï¼šå°†è¯¥åˆ—çš„æ•°æ®å‡åºæ’åºå½¢æˆä¸€ä¸ªåˆ—è¡¨ï¼Œåœ¨åˆ—è¡¨ä¸­èµ°å››åˆ†ä¹‹ä¸€ï¼Œä¼šå‘ç°ä¸€ä¸ªå¤§äº 25% ä¸”å°äº 75% çš„å€¼ã€‚è¿™æ˜¯ 25% çš„å®šä¹‰ã€‚\n\nç¬¬ä¸€ä¸ªæœºå™¨å­¦ä¹ æ¨¡å‹\nBuilding your first model. Hurray!\n\né€‰æ‹©å»ºæ¨¡çš„æ•°æ®ä¸€æ¡æ•°æ®æœ‰å¾ˆå¤šå˜é‡ï¼Œå¦‚ä½•é€‰æ‹©åˆé€‚çš„å˜é‡ï¼Ÿæˆ‘ä»¬å…ˆç”¨ç›´è§‰é€‰å‡ ä¸ªå˜é‡ã€‚åé¢çš„è¯¾ç¨‹å°†å±•ç¤ºè‡ªåŠ¨ç¡®å®šå˜é‡ä¼˜å…ˆçº§çš„ç»Ÿè®¡æŠ€æœ¯ã€‚\né¦–å…ˆéœ€è¦æŸ¥çœ‹æ•°æ®é›†ä¸­æ‰€æœ‰åˆ—çš„åˆ—è¡¨ã€‚é€šè¿‡ DataFrame çš„ columns å±æ€§å®Œæˆï¼š\nimport pandas as pdmelbourne_file_path = &#x27;../input/melbourne-housing-snapshot/melb_data.csv&#x27;melbourne_data = pd.read_csv(melbourne_file_path) print(melbourne_data.columns)\nIndex([&#x27;Suburb&#x27;, &#x27;Address&#x27;, &#x27;Rooms&#x27;, &#x27;Type&#x27;, &#x27;Price&#x27;, &#x27;Method&#x27;, &#x27;SellerG&#x27;,       &#x27;Date&#x27;, &#x27;Distance&#x27;, &#x27;Postcode&#x27;, &#x27;Bedroom2&#x27;, &#x27;Bathroom&#x27;, &#x27;Car&#x27;,       &#x27;Landsize&#x27;, &#x27;BuildingArea&#x27;, &#x27;YearBuilt&#x27;, &#x27;CouncilArea&#x27;, &#x27;Lattitude&#x27;,       &#x27;Longtitude&#x27;, &#x27;Regionname&#x27;, &#x27;Propertycount&#x27;],      dtype=&#x27;object&#x27;)\næŸäº›æ•°æ®å¯èƒ½æœ‰ç¼ºå¤±å€¼ï¼Œåç»­è¯¾ç¨‹ä¼šè§£å†³ç¼ºå¤±å€¼ã€‚è¿™é‡Œç®€å•åœ°åˆ é™¤æœ‰ç¼ºå¤±çš„æ•°æ®ï¼Œé€šè¿‡ .dropna()ï¼š\nmelbourne_data = melbourne_data.dropna(axis=0)\næ³¨æ„ .dropna() ä¸ä¼šåœ¨å½“å‰ DataFrame ä¸Šè¿›è¡Œä¿®æ”¹ï¼Œè€Œæ˜¯ä¼šè¿”å›ä¸€ä¸ªæ–°çš„å¯¹è±¡ï¼Œæ‰€ä»¥éœ€è¦èµ‹å€¼ç»™æ–°å¯¹è±¡ã€‚\nè·å– DataFrame å­é›†çš„æ–¹æ³•ï¼š\n\nä½¿ç”¨ç‚¹ .\nä½¿ç”¨ä¸€ä¸ªåˆ—ååˆ—è¡¨\n\né€‰æ‹©é¢„æµ‹ç›®æ ‡é€šè¿‡ç‚¹ . æ¥è®¿é—®æŸä¸ªå˜é‡çš„æ•°æ®ã€‚è¿™äº›æ•°æ®å­˜å‚¨åœ¨ä¸€ä¸ª Series ä¸­ï¼Œå®ƒå¤§è‡´ç±»ä¼¼äºåªæœ‰å•åˆ—æ•°æ®çš„ DataFrame ã€‚éœ€è¦é¢„æµ‹çš„å˜é‡ä¸º Price ï¼Œå®šä¹‰ä¸ºyï¼š\ny = melbourne_data.Price\n\né€‰æ‹©ç‰¹å¾â€œç‰¹å¾â€å®šä¹‰ä¸ºè¾“å…¥æ¨¡å‹çš„æ•°æ®åˆ—ï¼Œå¹¶åç»­ç”¨äºé¢„æµ‹ã€‚ä½¿ç”¨åˆ—ååˆ—è¡¨æ¥è·å–ï¼Œå¹¶å®šä¹‰ä¸º xï¼š\nmelbourne_features = [&#x27;Rooms&#x27;, &#x27;Bathroom&#x27;, &#x27;Landsize&#x27;, &#x27;Lattitude&#x27; &#x27;Longtitude&#x27;]x = melbourne_data[melbourne_features]\nä½¿ç”¨ .head() æ–¹æ³•æŸ¥çœ‹å¤´éƒ¨å‡ ä¸ªæ ·æœ¬ï¼š\nx.head()\n\næ„å»ºæ¨¡å‹ä½¿ç”¨ scikit-learn åŒ…æ¥åˆ›å»ºæ¨¡å‹ã€‚ä»£ç ä¸­å†™ä½œ sklearnã€‚\né€šè¿‡ä»¥ä¸‹æ­¥éª¤æ¥æ„å»ºæ¨¡å‹ï¼š\n\nå®šä¹‰ï¼šæ¨¡å‹ç±»å‹ã€æ¨¡å‹å‚æ•°\næ‹Ÿåˆï¼ˆè®­ç»ƒï¼‰ï¼šä»æ•°æ®ä¸­å­¦ä¹ æ¨¡å¼\né¢„æµ‹ï¼šJust what it sounds likeï¼ˆåŸæ–‡ğŸ¤”ï¼‰\nè¯„ä¼°ï¼šç¡®å®šæ¨¡å‹çš„å‡†ç¡®åº¦\n\nä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼š\nfrom sklearn.tree import DecisionTreeRegressor# Define model. Specify a number for random_state to ensure same results each runmelbourne_model = DecisionTreeRegressor(random_state=1)# Fit modelmelbourne_model.fit(X, y)\n\nè®¾ç½® random_state ç¡®ä¿åœ¨æ¯ä¸€ä¸ªè½®æ¬¡ä¸­è·å–ç›¸åŒçš„ç»“æœã€‚ä½†æ˜¯æ¨¡å‹çš„æ€§èƒ½å’Œè¿™ä¸ªæ•°å­—æ— å…³ã€‚\nç°åœ¨ä½¿ç”¨è®­ç»ƒå¥½çš„æ¨¡å‹æ¥é¢„æµ‹è¾“å…¥çš„å‰ 5 ä¸ªæ•°æ®ï¼š\nmelbourne_model.predict(X.head())\næ¨¡å‹éªŒè¯\nMeasure the performance of your model, so you can test and compare alternatives.\n\nä»€ä¹ˆæ˜¯æ¨¡å‹éªŒè¯è®¸å¤šäººåœ¨è¡¡é‡é¢„æµ‹å‡†ç¡®æ€§æ—¶çŠ¯äº†ä¸€ä¸ªå·¨å¤§çš„é”™è¯¯ã€‚ä»–ä»¬ç”¨è®­ç»ƒæ•°æ®è¿›è¡Œé¢„æµ‹ï¼Œå¹¶å°†è¿™äº›é¢„æµ‹ä¸è®­ç»ƒæ•°æ®ä¸­çš„ç›®æ ‡å€¼è¿›è¡Œæ¯”è¾ƒã€‚ç¨åæ‚¨å°†çœ‹åˆ°è¿™ç§æ–¹æ³•çš„é—®é¢˜ä»¥åŠå¦‚ä½•è§£å†³å®ƒï¼Œä½†è®©æˆ‘ä»¬å…ˆè€ƒè™‘ä¸€ä¸‹å¦‚ä½•åšè¿™ä¸ªã€‚\nè€ƒè™‘æœ€ç®€å•çš„å¹³å‡ç»å¯¹è¯¯å·®ï¼ˆMean Absolute Error, MAEï¼‰ï¼š\nerror = actual - predicted\n\nä½¿ç”¨ scikit-learn è®¡ç®— MAEï¼š\nfrom sklearn.metrics import mean_absolute_errorpredicted_home_prices = melbourne_model.predict(X)mean_absolute_error(y, predicted_home_prices)\n\nâ€œIn-Sampleâ€åˆ†æ•°çš„é—®é¢˜å‰é¢æåˆ°çš„è¯„ä»·æ–¹å¼æ˜¯ä¸€ç§â€œæ ·æœ¬å†…â€åˆ†æ•°ï¼ˆin-sampleï¼‰ã€‚æ˜¯åŒç»Ÿä¸€æ•°æ®æ¥è®­ç»ƒå’Œé¢„æµ‹ã€‚æƒ³è±¡ä»¥ä¸‹åœºæ™¯ï¼š\n\nåœ¨å¤§å‹æˆ¿åœ°äº§å¸‚åœºä¸­ï¼Œé—¨çš„é¢œè‰²ä¸æˆ¿ä»·æ— å…³ã€‚ç„¶è€Œï¼Œåœ¨æ‚¨ç”¨äºæ„å»ºæ¨¡å‹çš„æ•°æ®æ ·æœ¬ä¸­ï¼Œæ‰€æœ‰å¸¦æœ‰ç»¿è‰²é—¨çš„æˆ¿å±‹éƒ½éå¸¸æ˜‚è´µã€‚è¿™ä¸ªæ¨¡å‹çš„å·¥ä½œæ˜¯æ‰¾åˆ°é¢„æµ‹æˆ¿ä»·çš„æ¨¡å¼ï¼Œæ‰€ä»¥å®ƒä¼šçœ‹åˆ°è¿™ä¸ªæ¨¡å¼ï¼Œå®ƒæ€»æ˜¯ä¼šé¢„æµ‹ç»¿è‰²é—¨çš„æˆ¿å±‹çš„é«˜ä»·æ ¼ã€‚ç”±äºè¯¥æ¨¡å¼æ˜¯ä»è®­ç»ƒæ•°æ®ä¸­å¯¼å‡ºçš„ï¼Œå› æ­¤è¯¥æ¨¡å‹åœ¨è®­ç»ƒæ•°æ®ä¸­ä¼šæ˜¾å¾—å‡†ç¡®ã€‚ä½†æ˜¯ï¼Œå¦‚æœå½“æ¨¡å‹çœ‹åˆ°æ–°çš„æ•°æ®æ—¶ï¼Œè¿™ç§æ¨¡å¼ä¸æˆç«‹ï¼Œé‚£ä¹ˆåœ¨å®é™…ä½¿ç”¨æ—¶ï¼Œæ¨¡å‹å°†éå¸¸ä¸å‡†ç¡®ã€‚\n\nç”±äºæ¨¡å‹çš„å®ç”¨ä»·å€¼æ¥è‡ªäºå¯¹æ–°æ•°æ®çš„é¢„æµ‹ï¼Œå› æ­¤æˆ‘ä»¬åœ¨æœªç”¨äºæ„å»ºæ¨¡å‹çš„æ•°æ®ä¸Šè¡¡é‡æ€§èƒ½ã€‚è¦åšåˆ°è¿™ä¸€ç‚¹ï¼Œæœ€ç›´æ¥çš„æ–¹æ³•æ˜¯ä»æ¨¡å‹æ„å»ºè¿‡ç¨‹ä¸­æ’é™¤ä¸€äº›æ•°æ®ï¼Œç„¶åä½¿ç”¨è¿™äº›æ•°æ®æ¥æµ‹è¯•æ¨¡å‹å¯¹ä»¥å‰æ²¡æœ‰è§è¿‡çš„æ•°æ®çš„å‡†ç¡®æ€§ã€‚è¿™äº›æ•°æ®ç§°ä¸ºéªŒè¯æ•°æ®ï¼ˆvalidation dataï¼‰ã€‚\nCoding it!scikit-learn æä¾›äº† train_test_solit æ–¹æ³•æ¥åˆ’åˆ†è®­ç»ƒé›†å’Œæµ‹è¯•é›†ã€‚\nfrom sklearn.model_selection import train_test_split# split data into training and validation data, for both features and target# The split is based on a random number generator. Supplying a numeric value to# the random_state argument guarantees we get the same split every time we# run this script.train_X, val_X, train_y, val_y = train_test_split(X, y, random_state = 0, test_size=0.2)# Define modelmelbourne_model = DecisionTreeRegressor()# Fit modelmelbourne_model.fit(train_X, train_y)# get predicted prices on validation dataval_predictions = melbourne_model.predict(val_X)print(mean_absolute_error(val_y, val_predictions))\n\né€šè¿‡è®¾ç½® test_size æ¥æ›´æ”¹æµ‹è¯•é›†çš„æ¯”ä¾‹ã€‚\nWow!ç»è¿‡æµ‹è¯•ï¼Œæ ·æœ¬å†…æ•°æ®çš„å¹³å‡ç»å¯¹è¯¯å·®çº¦ä¸º500ç¾å…ƒï¼Œè€Œæ ·æœ¬å¤–è¶…è¿‡25ä¸‡ç¾å…ƒï¼\næ¬ æ‹Ÿåˆå’Œè¿‡æ‹Ÿåˆ\nFine-tune your model for better performance.\n\nå®éªŒä¸åŒæ¨¡å‹ä¸¤ä¸ªæç«¯\n\nå½“æˆ‘ä»¬æŠŠæˆ¿å­åˆ†æˆè®¸å¤šç‰‡å¶å­æ—¶ï¼Œæ¯ç‰‡å¶å­ä¸Šçš„æˆ¿å­ä¹Ÿæ›´å°‘ã€‚æˆ¿å­å¾ˆå°‘çš„æ ‘å¶ä¼šåšå‡ºéå¸¸æ¥è¿‘è¿™äº›æˆ¿å­çš„å®é™…ä»·å€¼çš„é¢„æµ‹ï¼Œä½†å®ƒä»¬å¯¹æ–°æ•°æ®çš„é¢„æµ‹å¯èƒ½éå¸¸ä¸å¯é ï¼ˆå› ä¸ºæ¯æ¬¡é¢„æµ‹éƒ½åªåŸºäºå‡ æ‰€æˆ¿å­ï¼‰ã€‚\nè¿™æ˜¯ä¸€ç§è¢«ç§°ä¸ºè¿‡æ‹Ÿåˆçš„ç°è±¡ï¼Œå³æ¨¡å‹å‡ ä¹å®Œç¾åœ°åŒ¹é…è®­ç»ƒæ•°æ®ï¼Œä½†åœ¨éªŒè¯å’Œå…¶ä»–æ–°æ•°æ®æ–¹é¢è¡¨ç°ä¸ä½³ã€‚å¦ä¸€æ–¹é¢ï¼Œå¦‚æœæˆ‘ä»¬æŠŠæ ‘ç”»å¾—å¾ˆæµ…ï¼Œå®ƒå°±ä¸ä¼šæŠŠæˆ¿å­åˆ†æˆå¾ˆæ˜æ˜¾çš„ç»„ã€‚\n\n\nå¦‚æœä¸€æ£µæ ‘åªæŠŠæˆ¿å­åˆ†æˆ2ä¸ªæˆ–4ä¸ªï¼Œæ¯ä¸€ç»„ä»ç„¶æœ‰å„ç§å„æ ·çš„æˆ¿å­ã€‚å¯¹å¤§å¤šæ•°æœºæ„æ¥è¯´ï¼Œç»“æœé¢„æµ‹å¯èƒ½è¿˜å¾ˆé¥è¿œï¼Œç”šè‡³åœ¨è®­ç»ƒæ•°æ®ä¸­ä¹Ÿæ˜¯å¦‚æ­¤ï¼ˆå‡ºäºåŒæ ·çš„åŸå› ï¼Œå®ƒåœ¨éªŒè¯ä¸­ä¹Ÿä¼šå¾ˆç³Ÿç³•ï¼‰ã€‚\nå½“ä¸€ä¸ªæ¨¡å‹æ— æ³•æ•æ‰æ•°æ®ä¸­çš„é‡è¦åŒºåˆ«å’Œæ¨¡å¼ï¼Œå› æ­¤å³ä½¿åœ¨è®­ç»ƒæ•°æ®ä¸­ä¹Ÿè¡¨ç°ä¸ä½³ï¼Œè¿™è¢«ç§°ä¸ºæ¬ æ‹Ÿåˆã€‚\n\n\n\nä¾‹å­é€šè¿‡è®¾ç½®ä¸åŒæ•°é‡çš„å†³ç­–æ ‘ç»“ç‚¹æ•°é‡ max_leaf_nodesï¼Œè®¡ç®—å‡ºä¸åŒçš„ç²¾ç¡®ç‡ã€‚\nfrom sklearn.metrics import mean_absolute_errorfrom sklearn.tree import DecisionTreeRegressordef get_mae(max_leaf_nodes, train_X, val_X, train_y, val_y):    model = DecisionTreeRegressor(max_leaf_nodes=max_leaf_nodes, random_state=0)    model.fit(train_X, train_y)    preds_val = model.predict(val_X)    mae = mean_absolute_error(val_y, preds_val)    return(mae)\n\nç»“è®ºä¸¤ç§æƒ…å†µï¼š\n\nè¿‡æ‹Ÿåˆï¼šæ•æ‰æœªæ¥ä¸ä¼šå†å‡ºç°çš„è™šå‡æ¨¡å¼ï¼Œå¯¼è‡´é¢„æµ‹ä¸é‚£ä¹ˆå‡†ç¡®\næ¬ æ‹Ÿåˆï¼šæ— æ³•æ•æ‰ç›¸å…³çš„æ¨¡å¼ï¼ŒåŒæ ·å¯¼è‡´é¢„æµ‹ä¸å‡†ç¡®\n\néšæœºæ£®æ—\nUsing a more sophisticated machine learning algorithm.\n\nå¼•å…¥å†³ç­–æ ‘ç•™ç»™ä½ ä¸€ä¸ªè‰°éš¾çš„å†³å®šã€‚æœ‰å¾ˆå¤šå¶å­çš„æ·±æ ‘ä¼šè¿‡æ‹Ÿåˆï¼Œå› ä¸ºæ¯ä¸ªé¢„æµ‹éƒ½æ˜¯æ¥è‡ªå¶å­é™„è¿‘çš„å°‘æ•°æˆ¿å±‹çš„å†å²æ•°æ®ã€‚ä½†æ˜¯ä¸€æ£µå¶å­å¾ˆå°‘çš„æµ…æ ‘ä¼šè¡¨ç°å¾—å¾ˆå·®ï¼Œå› ä¸ºå®ƒæ— æ³•åœ¨åŸå§‹æ•°æ®ä¸­æ•æ‰åˆ°å°½å¯èƒ½å¤šçš„åŒºåˆ«ã€‚\nå³ä½¿æ˜¯ä»Šå¤©æœ€å¤æ‚çš„å»ºæ¨¡æŠ€æœ¯ä¹Ÿé¢ä¸´ç€æ¬ æ‹Ÿåˆå’Œè¿‡æ‹Ÿåˆä¹‹é—´çš„ç´§å¼ å…³ç³»ã€‚ä½†æ˜¯ï¼Œè®¸å¤šæ¨¡å‹éƒ½æœ‰èªæ˜çš„æƒ³æ³•ï¼Œå¯ä»¥å¸¦æ¥æ›´å¥½çš„æ€§èƒ½ã€‚æˆ‘ä»¬å°†ä»¥éšæœºæ£®æ—ä¸ºä¾‹ã€‚\néšæœºæ£®æ—ä½¿ç”¨è®¸å¤šæ ‘ï¼Œå®ƒé€šè¿‡å¹³å‡æ¯ä¸ªç»„æˆæ ‘çš„é¢„æµ‹æ¥è¿›è¡Œé¢„æµ‹ã€‚å®ƒé€šå¸¸æ¯”å•ä¸€å†³ç­–æ ‘å…·æœ‰æ›´å¥½çš„é¢„æµ‹å‡†ç¡®æ€§ï¼Œå¹¶ä¸”åœ¨é»˜è®¤å‚æ•°ä¸‹å·¥ä½œå¾—å¾ˆå¥½ã€‚\nfrom sklearn.ensemble import RandomForestRegressorfrom sklearn.metrics import mean_absolute_errorforest_model = RandomForestRegressor(random_state=1)forest_model.fit(train_X, train_y)melb_preds = forest_model.predict(val_X)print(mean_absolute_error(val_y, melb_preds))\nç»“è®ºå¯èƒ½è¿˜æœ‰è¿›ä¸€æ­¥æ”¹è¿›çš„ç©ºé—´ï¼Œä½†è¿™å·²ç»æ¯”25ä¸‡çš„æœ€ä½³å†³ç­–æ ‘è¯¯å·®æœ‰äº†å¾ˆå¤§çš„æ”¹è¿›ã€‚æœ‰ä¸€äº›å‚æ•°å…è®¸ä½ æ”¹å˜éšæœºæ£®æ—çš„æ€§èƒ½ï¼Œå°±åƒæˆ‘ä»¬æ”¹å˜å•ä¸ªå†³ç­–æ ‘çš„æœ€å¤§æ·±åº¦ä¸€æ ·ã€‚ä½†éšæœºæ£®æ—æ¨¡å‹çš„ä¸€ä¸ªæœ€ä½³ç‰¹å¾æ˜¯ï¼Œå³ä½¿æ²¡æœ‰è¿™ç§è°ƒæ•´ï¼Œå®ƒä»¬é€šå¸¸ä¹Ÿèƒ½åˆç†åœ°å·¥ä½œã€‚\næœºå™¨å­¦ä¹ æ¯”èµ›\nEnter the world of machine learning competitions to keep improving and see your progress.\n\nItâ€™s your turn!\n","categories":["Kaggle courses"],"tags":["Kaggle","Pandas","Python"]},{"title":"ã€Kaggle Coursesã€‘1-ç¼–ç¨‹ä»‹ç»","url":"/blog/Kaggle-course/intro-to-programming/","content":"Get started with Python, if you have no coding experience. Click here for more information.\n\n\nè®¡ç®—å’Œå˜é‡\nMake calculations, and define and modify variables.\n\næ‰“å°æ‰“å°ä¸€æ¡æ¶ˆæ¯ã€‚\nprint(&#x27;hello&#x27;)\nè®¡ç®—æ‰“å°è®¡ç®—ç»“æœã€‚\nprint(1 + 2)\næ³¨é‡Šä½¿ç”¨ # å†™æ³¨é‡Šã€‚\nå‡½æ•°\nOrganize your code and avoid redundancy.\n\nä¸€ä¸ªç®€å•çš„ä¾‹å­def add_three(input_var):    output_var = input_var + 3    return output_var\nå‡½æ•°åŒ…å«ä¸¤ä¸ªéƒ¨åˆ†: header å’Œ body.\n\nHeader: å®šä¹‰å‡½æ•°åå’Œå‚æ•°ã€‚\nBody: å®šä¹‰å‡½æ•°å¦‚ä½•å·¥ä½œã€‚\n\nå˜é‡ä½œç”¨åŸŸå‡½æ•°å†…éƒ¨å®šä¹‰çš„å˜é‡æ— æ³•åœ¨å‡½æ•°å¤–è®¿é—®ã€‚\næ•°æ®ç±»å‹\nExplore integers, floats, booleans, and strings.\n\nint, float, boolean, string\næ¡ä»¶å’Œæ¡ä»¶å£°æ˜\nModify how functions run, depending on the input.if, if-else, if-elif-else\n\nåˆ—è¡¨ä»‹ç»\nOrganize your data so you can work with it efficiently.\n\nç´¢å¼•\nè·å–æœ€åä¸€ä¸ªå…ƒç´ : [-1]\nè·å–å€’æ•°ç¬¬äºŒä¸ªå…ƒç´ : [-2]\n\nåˆ‡ç‰‡åˆ‡ç‰‡ï¼šè·å–åˆ—è¡¨çš„ä¸€ä¸ªç‰‡æ®µã€‚\n\nè·å–å‰ x ä¸ªå…ƒç´ ï¼š[:x]\nè·å–å y ä¸ªå…ƒç´ ï¼š[-y:]\n\næ­¤å¤„â€œå…ƒç´ â€çš„è‹±æ–‡ä¸ºâ€œentryâ€ã€‚\nl = [1, 2, 3, 4, 5]print(l[:2])print(l[-2:])\n[1, 2][4, 5]\nåˆ é™¤ä½¿ç”¨ .remove()\næ·»åŠ ä½¿ç”¨ .add()\n","categories":["Kaggle courses"],"tags":["Kaggle","Python"]},{"title":"ã€Kaggle Coursesã€‘4-pandas","url":"/blog/Kaggle-course/pandas-kaggle/","content":"Solve short hands-on challenges to perfect your data manipulation skills. Click here for more information.\n\nåˆ›å»ºã€è¯»å’Œå†™\nYou canâ€™t work with data if you canâ€™t read it. Get started here.\n\nå¼€å§‹å¯¼å…¥ pandasï¼š\nimport pandas as pd\nåˆ›å»ºæ•°æ®Pandas ä¸­çš„ä¸¤ä¸ªæ ¸å¿ƒå¯¹è±¡ï¼šDataFrame å’Œ Seriesã€‚\nDataFrameDataFrame æ˜¯ä¸€ä¸ªè¡¨ã€‚å®ƒåŒ…å«ä¸€ä¸ªå•ç‹¬æ¡ç›®ï¼ˆentryï¼‰çš„æ•°ç»„ï¼Œæ¯ä¸ªæ¡ç›®éƒ½æœ‰ä¸€ä¸ªç‰¹å®šçš„å€¼ã€‚æ¯ä¸ªæ¡ç›®å¯¹åº”ä¸€è¡Œï¼ˆæˆ–è®°å½•ï¼‰å’Œä¸€åˆ—ã€‚ä¾‹å¦‚ï¼š\npd.DataFrame(&#123;&#x27;Yes&#x27;: [50, 21], &#x27;No&#x27;: [131, 2]&#125;)\nåœ¨æœ¬ä¾‹ä¸­ï¼Œâ€œ0ï¼ŒNoâ€ æ¡ç›®çš„å€¼ä¸º 131 ã€‚â€œ0ï¼ŒYesâ€ æ¡ç›®çš„å€¼ä¸º 50ï¼Œä»¥æ­¤ç±»æ¨ã€‚æ•°æ®æ¡†æ¡ç›®ä¸é™äºæ•´æ•°ã€‚ä¾‹å¦‚ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªå€¼ä¸ºå­—ç¬¦ä¸²çš„DataFrameï¼š\npd.DataFrame(&#123;&#x27;Bob&#x27;: [&#x27;I liked it.&#x27;, &#x27;It was awful.&#x27;], &#x27;Sue&#x27;: [&#x27;Pretty good.&#x27;, &#x27;Bland.&#x27;]&#125;)\n\næˆ‘ä»¬ä½¿ç”¨ pd.DataFrame() æ„é€ å‡½æ•°æ¥ç”Ÿæˆè¿™äº› DataFrame å¯¹è±¡ã€‚å£°æ˜ä¸€ä¸ªæ–°å¯¹è±¡çš„è¯­æ³•æ˜¯ä¸€ä¸ªå­—å…¸ï¼Œå®ƒçš„é”®æ˜¯åˆ—åï¼ˆæœ¬ä¾‹ä¸­æ˜¯Bobå’ŒSueï¼‰ï¼Œå®ƒçš„å€¼æ˜¯ä¸€ä¸ªæ¡ç›®åˆ—è¡¨ã€‚è¿™æ˜¯æ„é€ æ–° DataFrame çš„æ ‡å‡†æ–¹æ³•ã€‚\nå­—å…¸åˆ—è¡¨æ„é€ å‡½æ•°å°†å€¼èµ‹ç»™åˆ—æ ‡ç­¾ï¼Œä½†å¯¹è¡Œæ ‡ç­¾æ¥è¯´ï¼Œé»˜è®¤æ˜¯ä» 0 å¼€å§‹çš„å‡åºè®¡æ•°ã€‚\nDataFrame ä¸­ä½¿ç”¨çš„è¡Œæ ‡ç­¾åˆ—è¡¨ç§°ä¸ºç´¢å¼•ã€‚å¯ä»¥é€šè¿‡åœ¨æ„é€ å‡½æ•°ä¸­ä½¿ç”¨ index å½¢å‚ç»™å®ƒèµ‹å€¼ï¼š\npd.DataFrame(&#123;&#x27;Bob&#x27;: [&#x27;I liked it.&#x27;, &#x27;It was awful.&#x27;],               &#x27;Sue&#x27;: [&#x27;Pretty good.&#x27;, &#x27;Bland.&#x27;]&#125;,             index=[&#x27;Product A&#x27;, &#x27;Product B&#x27;])\n\nSeriesç›¸æ¯”ä¹‹ä¸‹ï¼Œåºåˆ—æ˜¯æ•°æ®å€¼çš„åºåˆ—ã€‚å¦‚æœ DataFrame æ˜¯ä¸€ä¸ªè¡¨ï¼Œé‚£ä¹ˆ Series å°±æ˜¯ä¸€ä¸ªåˆ—è¡¨ã€‚åªéœ€è¦ä¸€ä¸ªåˆ—è¡¨å°±å¯ä»¥åˆ›å»ºä¸€ä¸ª Series å¯¹è±¡ï¼š\npd.Series([1, 2, 3, 4, 5])\n\nä»æœ¬è´¨ä¸Šè®²ï¼ŒSeries æ˜¯ DataFrame çš„ä¸€åˆ—ã€‚å› æ­¤ï¼Œå¯ä»¥åƒä»¥å‰ä¸€æ ·ä½¿ç”¨ index å‚æ•°å°†è¡Œæ ‡ç­¾åˆ†é…ç»™ Seriesã€‚ä½†æ˜¯ï¼Œ Series æ²¡æœ‰åˆ—åï¼Œå®ƒåªæœ‰ä¸€ä¸ªæ€»ç§°ï¼š\npd.Series([30, 35, 40], index=[&#x27;2015 Sales&#x27;, &#x27;2016 Sales&#x27;, &#x27;2017 Sales&#x27;], name=&#x27;Product A&#x27;)\n\nè¯»å–æ•°æ®æ•°æ®å¯ä»¥ä»¥è®¸å¤šä¸åŒçš„å½¢å¼å’Œæ ¼å¼ä¸­çš„ä»»ä½•ä¸€ç§è¿›è¡Œå­˜å‚¨ã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œå…¶ä¸­æœ€åŸºæœ¬çš„æ˜¯ CSV æ–‡ä»¶ã€‚å½“ä½ æ‰“å¼€ä¸€ä¸ª CSV æ–‡ä»¶æ—¶ï¼Œä½ ä¼šçœ‹åˆ°è¿™æ ·çš„ä¸œè¥¿ï¼š\nProduct A,Product B,Product C,30,21,9,35,34,1,41,11,11\nCSV æ–‡ä»¶æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªç”¨é€—å·åˆ†éš”çš„å€¼è¡¨ã€‚å› æ­¤å¾—åï¼šComma-Separated Valuesï¼ŒCSVã€‚\nè¯»å–å¹¶æŸ¥çœ‹ CSV æ–‡ä»¶ï¼š\nimport pandas as pddf = pd.read_csv(&#x27;file.csv&#x27;)df.shapedf.head()\n\nç´¢å¼•ã€é€‰æ‹©å’Œèµ‹å€¼\nPro data scientists do this dozens of times a day. You can, too!\n\nåŸç”Ÿè®¿é—®å™¨åŸç”Ÿ Python å¯¹è±¡æä¾›äº†ç´¢å¼•æ•°æ®çš„æ–¹æ³•ã€‚PandasåŒ…å«äº†æ‰€æœ‰è¿™äº›å†…å®¹ï¼š\ndf = pd.read_csv(&#x27;file.csv&#x27;)# è®¿é—® country åˆ—ï¼ˆè®¿é—®ä¸€ä¸ª Series ï¼‰df.countrydf[&#x27;country&#x27;]# è®¿é—®è¯¥åˆ—çš„æŸä¸ªå¯¹è±¡df[&#x27;country&#x27;][0]\nPandas ä¸­çš„ç´¢å¼•Pandas æœ‰è‡ªå·±çš„ç´¢å¼•æ–¹å¼ loc ã€‚Pandas ç´¢å¼•çš„å·¥ä½œæ–¹å¼æœ‰ä¸¤ç§ã€‚\nåŸºäºç´¢å¼•çš„é€‰æ‹©iloc åŸºäºæ•°å€¼ä½ç½®é€‰æ‹©æ•°æ®ã€‚ä¾‹å¦‚è®¿é—®ç¬¬ä¸€è¡Œçš„æ•°æ®ï¼š\ndf.iloc[0]\n\nloc å’Œ iloc éƒ½æ˜¯è¡Œä¼˜å…ˆï¼Œè¿™æ„å‘³ç€æ£€ç´¢è¡Œç¨å¾®å®¹æ˜“ä¸€äº›ï¼Œè€Œè·å–æ£€ç´¢åˆ—ç¨å¾®å›°éš¾ä¸€äº›ã€‚ä¾‹å¦‚è®¿é—®ç¬¬ä¸€åˆ—çš„æ•°æ®ï¼š\ndf.iloc[:, 0]\n\næ›´å¤šä¾‹å­ï¼š\n# è®¿é—®ç¬¬äºŒè¡Œå’Œç¬¬ä¸‰è¡Œçš„ç¬¬ä¸€åˆ—df.iloc[1 : 3, 0]# ä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªåˆ—è¡¨df.iloc[[1, 2], 0]\n\nåŸºäºæ ‡ç­¾çš„é€‰æ‹©iloc åœ¨æ¦‚å¿µä¸Šæ¯” loc ç®€å•ï¼Œå› ä¸ºå®ƒå¿½ç•¥æ•°æ®é›†çš„ç´¢å¼•ã€‚å½“ä½¿ç”¨ iloc æ—¶ï¼Œæˆ‘ä»¬å°†æ•°æ®é›†è§†ä¸ºä¸€ä¸ªå¤§çŸ©é˜µï¼ˆåˆ—è¡¨çš„åˆ—è¡¨ï¼‰ï¼Œæˆ‘ä»¬å¿…é¡»æ ¹æ®ä½ç½®å¯¹å…¶è¿›è¡Œç´¢å¼•ã€‚\nç›¸æ¯”ä¹‹ä¸‹ï¼Œloc ä½¿ç”¨ç´¢å¼•ä¸­çš„ä¿¡æ¯æ¥å®Œæˆå·¥ä½œã€‚ç”±äºæ•°æ®é›†é€šå¸¸åŒ…å«æœ‰æ„ä¹‰çš„ç´¢å¼•ï¼Œå› æ­¤ä½¿ç”¨locé€šå¸¸æ›´å®¹æ˜“ã€‚ä¾‹å¦‚ï¼Œè®¿é—®æ‰€æœ‰è¡Œçš„ä»¥ä¸‹å±æ€§ï¼š\ndf.loc[:, [&#x27;taster_name&#x27;, &#x27;taster_twitter_handle&#x27;, &#x27;points&#x27;]]\n\nloc è¿˜æ˜¯ iloc ï¼Ÿ\niloc ä½¿ç”¨æ ‡å‡†çš„ç´¢å¼•ç­–ç•¥ï¼Œ0:10 çš„ç»“æœæ˜¯ 0,...,9ï¼Œè€Œ loc çš„ç»“æœæ˜¯ 0,...,10ã€‚\nloc å¯ä»¥è¿™æ ·ç”¨ï¼šdf.loc[&#39;a&#39;:&#39;d&#39;] ï¼Œè¡¨ç¤ºç´¢å¼•æ ‡ç­¾ a åˆ° d ä¹‹é—´çš„æ‰€æœ‰åˆ—ã€‚ï¼ˆåŒ…æ‹¬ dï¼‰\niloc ç´¢å¼•æ•°å€¼ä½ç½®ï¼Œloc ç´¢å¼•æ ‡ç­¾ï¼Œä¸” loc åŒ…æ‹¬â€œç»“å°¾â€ã€‚\n\næ“ä½œç´¢å¼•Pandas é»˜è®¤ä½¿ç”¨æ•°å­—ä½œä¸ºç´¢å¼•ï¼Œå¯ä»¥é€šè¿‡ set_index() å°†æŒ‡å®šåˆ—è®¾ç½®ä¸ºç´¢å¼•ï¼š\ndf = df.set_index(&quot;title&quot;)\n\næ³¨æ„ï¼Œé‡æ–°è®¾ç½®ç´¢å¼•ä¹‹åè¦è¿›è¡Œèµ‹å€¼ã€‚å³ä¸ä¼šåœ¨åŸæ¥çš„åŸºç¡€ä¸Šè¿›è¡Œä¿®æ”¹ï¼Œè€Œæ˜¯ä¼šè¿”å›ä¸€ä¸ªæ–°çš„ DataFrame å¯¹è±¡ã€‚\næ¡ä»¶é€‰æ‹©ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬å¯¹æ„å¤§åˆ©ç”Ÿäº§çš„å¥½äºå¹³å‡æ°´å¹³çš„è‘¡è„é…’ç‰¹åˆ«æ„Ÿå…´è¶£ã€‚\næˆ‘ä»¬é¦–å…ˆéœ€è¦æ£€æŸ¥æ¯ä¸€ç“¶é…’æ˜¯å¦æ¥è‡ªæ„å¤§åˆ©ï¼š\ndf.country == &#x27;Italy&#x27;\n\nè¿™ä¸ªæ“ä½œä¼šè¿”å›ä¸€ä¸ªå…¨æ˜¯å¸ƒå°”å˜é‡çš„ Series å¯¹è±¡ã€‚è¡¨ç¤ºè¯¥è¡Œçš„ country å±æ€§æ˜¯å¦ä¸º Italy ã€‚\næ¥ä¸‹æ¥å¯ä»¥é€šè¿‡ loc æ¥é€‰æ‹©å¯¹åº”çš„è¡Œï¼š\ndf.loc[df.country == &#x27;Italy&#x27;]\nå¯ä»¥ä½¿ç”¨ &amp; æˆ–è€… | æ¥æºå¸¦å¤šä¸ªæ¡ä»¶ï¼š\ndf.loc[(df.country == &#x27;Italy&#x27;) &amp; (reviews.points &gt;= 90)]\n\næ­¤å¤–ï¼Œpandas è¿˜æä¾›äº†ä¸€äº›å†…ç½®çš„é€‰æ‹©å™¨ï¼šisin() å’Œ isnull()\nisin() é€‰æ‹©é‚£äº›å€¼åœ¨ç»™å®šåˆ—è¡¨é‡Œçš„æ•°æ®ã€‚ä¾‹å¦‚é€‰å–åŒ…å«æ„å¤§åˆ©å’Œæ³•å›½çš„è¡Œï¼š\ndf.loc[df.country.isin([&#x27;Italy&#x27;, &#x27;France&#x27;])]# ç­‰ä»·äºdf.loc[(df.country == &#x27;Italy&#x27;) | (df.country == &#x27;France&#x27;)]\n\nisnull() é€‰æ‹©é‚£äº›åŒ…å«ç©ºå€¼çš„è¡Œï¼š\ndf.loc[df.price.isnull()]\nèµ‹å€¼ç»™ä¸€æ•´åˆ—èµ‹å€¼ï¼š\n# å°†æ•´åˆ—éƒ½èµ‹å€¼ä¸º everyonereviews[&#x27;critic&#x27;] = &#x27;everyone&#x27;# ä¹Ÿå¯ä»¥ä½¿ç”¨å¯è¿­ä»£çš„å¯¹è±¡ï¼ˆlistã€rangeç­‰ï¼‰reviews[&#x27;index_backwards&#x27;] = range(len(reviews), 0, -1)\n\næ€»ç»“å‡½æ•°å’Œæ˜ å°„\nExtract insights from your data.\n\næ€»ç»“å‡½æ•°ä½¿ç”¨ describe() æ–¹æ³•è·å–å¯¹æ•°æ®çš„é«˜çº§æè¿°ï¼š\nå¯¹ä¸åŒçš„æ•°æ®ç±»å‹ï¼Œä¼šæœ‰ä¸åŒçš„æ€»ç»“ï¼Œä¾‹å¦‚å¯¹å­—ç¬¦ä¸²ï¼š\nmean() æ–¹æ³•ï¼šæŸ¥çœ‹æŸä¸€åˆ—çš„å¹³å‡å€¼ã€‚\nunique() æ–¹æ³•ï¼šæŸ¥çœ‹æŸä¸€åˆ—çš„å”¯ä¸€å€¼åˆ—è¡¨ã€‚ï¼ˆå¯¹åº”äº describe è¾“å‡ºçš„ unique å…³é”®å­—ï¼‰\ncount() æ–¹æ³•ï¼šæŸ¥çœ‹æŸä¸€åˆ—çš„å”¯ä¸€å€¼åˆ—è¡¨ä»¥åŠå…¶å‡ºç°æ¬¡æ•°ã€‚\næ˜ å°„ï¼ˆMapsï¼‰æ‰¹é‡ä¿®æ”¹æŸäº›åˆ—ã€‚\nä¾‹å¦‚ï¼Œæƒ³è¦å°†æŸä¸€åˆ—å‡å»å…¶å‡å€¼ï¼š\nreview_points_mean = reviews.points.mean()reviews.points.map(lambda p: p - review_points_mean)\nä¼ é€’ç»™ map() çš„å‡½æ•°åº”è¯¥æœŸæœ›å¾—åˆ°æ¥è‡ª Series çš„å•ä¸ªå€¼ï¼ˆåœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­æ˜¯ä¸€ä¸ªç‚¹å€¼ï¼Œå³ pï¼‰ï¼Œå¹¶è¿”å›è¯¥å€¼çš„è½¬æ¢ç‰ˆæœ¬ï¼ˆå³ p - review_points_meanï¼‰ã€‚mapï¼ˆï¼‰è¿”å›ä¸€ä¸ªæ–°çš„ Series ï¼Œå…¶ä¸­æ‰€æœ‰çš„å€¼éƒ½å·²è¢«å‡½æ•°è½¬æ¢è¿‡ã€‚\nè¿™é‡Œ lambda è¡¨ç¤ºåŒ¿åå‡½æ•°ï¼Œå…¶ç­‰ä»·äºä»¥ä¸‹å‡½æ•°ï¼š\ndef my_function(p):    return p - review_points_mean\n\nåŒæ ·åœ°ï¼Œ apply() æ–¹æ³•åŒæ ·å¯ä»¥å®ç°ä¸Šè¿°è¿‡ç¨‹ï¼š\ndef remean_points(row):    row.points = row.points - review_points_mean    return rowreviews.apply(remean_points, axis=&#x27;columns&#x27;)\n\næ­¤å¤–ï¼Œä¹Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨æ“ä½œç¬¦ + ã€ - ç­‰ç›´æ¥å¯¹ Series å¯¹è±¡è¿›è¡Œæ“ä½œï¼Œè¿™æ¯”ä¸Šè¿°ä¸¤ä¸ªå‡½æ•°æ›´é«˜æ•ˆï¼Œä½†æ˜¯ä¸æ”¯æŒæ›´å¤æ‚çš„æƒ…å†µã€‚\nåˆ†ç»„å’Œæ’åº\nScale up your level of insight. The more complex the dataset, the more this matters\n\nåˆ†ç»„åˆ†æä»¥ä¸‹ä»£ç ç­‰åŒäº value_counts() æ–¹æ³•ï¼š\nreviews.groupby(&#x27;points&#x27;).points.count()\n\nå³æŒ‰ç…§ points åˆ—è¿›è¡Œåˆ†ç»„ï¼Œåˆ†ç»„ä¹‹åå†å¯¹ point åˆ—è¿›è¡Œè®¡æ•°ã€‚\nreviews.groupby(&#x27;points&#x27;).price.min()\nä¸Šè¿°ä»£ç æŒ‰ç…§ points åˆ—è¿›è¡Œåˆ†ç»„ï¼Œåˆ†ç»„ä¹‹åï¼Œåœ¨æ¯ä¸ªç»„é‡Œé¢è®¡ç®—æœ€å°å€¼ã€‚\nç”Ÿæˆçš„æ¯ä¸ªç»„å¯ä»¥è§†ä¸º DataFrame çš„ä¸€ä¸ªç‰‡æ®µï¼Œå…¶ä¸­ä»…åŒ…å«å…·æœ‰åŒ¹é…å€¼çš„æ•°æ®ã€‚å¯ä»¥ç›´æ¥ä½¿ç”¨ apply() æ–¹æ³•è®¿é—®è¿™ä¸ª DataFrameï¼Œç„¶åå¯ä»¥é€šè¿‡ä»»ä½•æ–¹å¼æ“ä½œæ•°æ®ã€‚ä¾‹å¦‚ï¼Œä¸‹é¢æ˜¯ä»æ•°æ®é›†ä¸­çš„æ¯ä¸ªé…’å‚ä¸­é€‰æ‹©ç¬¬ä¸€ä¸ªè¢«è¯„è®ºçš„è‘¡è„é…’åç§°çš„ä¸€ç§æ–¹æ³•ï¼š\nreviews.groupby(&#x27;winery&#x27;).apply(lambda df: df.title.iloc[0])\n\nå¯¹äºæ›´ç»†ç²’åº¦çš„ï¼Œè¿˜å¯ä»¥æŒ‰å¤šä¸ªåˆ—åˆ†ç»„ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œä»¥ä¸‹æ˜¯æˆ‘ä»¬å¦‚ä½•æŒ‰å›½å®¶å’Œçœä»½æŒ‘é€‰æœ€å¥½çš„è‘¡è„é…’ï¼š\nreviews.groupby([&#x27;country&#x27;, &#x27;province&#x27;]).apply(lambda df: df.loc[df.points.idxmax()])\n\næ’åºç®€å•æ’åºï¼ˆé»˜è®¤å‡åºï¼‰ï¼š\ncountries_reviewed.sort_values(by=&#x27;len&#x27;)\n\næŒ‰ç…§å¤šä¸ªåˆ—è¿›è¡Œæ’åºï¼š\ncountries_reviewed.sort_values(by=[&#x27;country&#x27;, &#x27;len&#x27;])\n\næ•°æ®ç±»å‹å’Œç¼ºå¤±å€¼\nDeal with the most common progress-blocking problems\n\næ•°æ®ç±»å‹DataFrame æˆ–Series ä¸­æ¯åˆ—çš„æ•°æ®ç±»å‹ç§°ä¸º dtype ã€‚å¯ä»¥ä½¿ç”¨ dtype å±æ€§è·å–ç‰¹å®šåˆ—çš„ç±»å‹ã€‚\nreviews.price.dtype\n\ndtypes å±æ€§è¿”å› DataFrame ä¸­æ¯ä¸€åˆ—çš„æ•°æ®ç±»å‹ã€‚\nreviews.dtypes\n\næ³¨æ„ï¼Œå­—ç¬¦ä¸²çš„ç±»å‹ä¸º object ã€‚\nå¯ä»¥ä½¿ç”¨ astype() æ–¹æ³•è¿›è¡Œæ•°æ®è½¬æ¢ï¼š\nreviews.points.astype(&#x27;float64&#x27;)\n\nç¼ºå¤±å€¼ä½¿ç”¨ fillna() æ–¹æ³•æ¥æ›¿æ¢ç¼ºå¤±å€¼ã€‚é€šå¸¸å¯ä»¥è®¾ç½®ä¸ºâ€œunkonwnâ€å­—ç¬¦ä¸²ï¼Œä¾¿äºåç»­æ›´æ”¹ã€‚è¿™ç§å€¼é€šå¸¸è¢«ç§°ä½œâ€œå“¨å…µâ€ï¼Œè¿˜åŒ…æ‹¬â€œUndisclosedâ€ã€â€œInvalidâ€ç­‰ã€‚\næ­¤å¤–å¯ä»¥ä½¿ç”¨ replace() æ–¹æ³•æ¥æ›¿æ¢è®¾ç½®çš„å“¨å…µå€¼ã€‚\né‡å‘½åå’Œç»„åˆ\nData comes in from many sources. Help it all make sense together\n\né‡å‘½åæœ‰æ—¶éœ€è¦æ›´æ”¹åˆ—æ˜æˆ–ç´¢å¼•åã€‚\n# å°† points åˆ—æ›´åä¸º scorereviews.rename(columns=&#123;&#x27;points&#x27;: &#x27;score&#x27;&#125;)# å°†ç¬¬ä¸€è¡Œå’Œç¬¬äºŒè¡Œæ›´åä¸º firstEntry å’Œ secondEntryreviews.rename(index=&#123;0: &#x27;firstEntry&#x27;, 1: &#x27;secondEntry&#x27;&#125;)\n\nç»„åˆç»„åˆæ¥è‡ªå¤šä¸ª DataFrame æˆ– Series çš„æ•°æ®ã€‚\nä¾‹å¦‚ï¼Œä¸¤ä¸ª CSV æ–‡ä»¶æœ‰ç›¸åŒçš„åˆ—ï¼Œæœ€ç®€å•çš„æ–¹æ³•æ˜¯ conca() ã€‚\ncanadian_youtube = pd.read_csv(&quot;../input/youtube-new/CAvideos.csv&quot;)british_youtube = pd.read_csv(&quot;../input/youtube-new/GBvideos.csv&quot;)pd.concat([canadian_youtube, british_youtube])\n\nä¾‹å¦‚ï¼Œç»„åˆä¸¤ä¸ªå…·æœ‰ç›¸åŒç´¢å¼•çš„ CSV æ–‡ä»¶ï¼š\nleft = canadian_youtube.set_index([&#x27;title&#x27;, &#x27;trending_date&#x27;])right = british_youtube.set_index([&#x27;title&#x27;, &#x27;trending_date&#x27;])left.join(right, lsuffix=&#x27;_CAN&#x27;, rsuffix=&#x27;_UK&#x27;)\nlsuffix å’Œ rsuffix å‚æ•°ç”¨äºåŒºåˆ†ä¸¤ä¸ªç›¸åŒçš„åˆ—ã€‚\nç®€å•è¯»å†™ CSV æ–‡ä»¶è¯»import pandas as pddf = pd.read_csv(&#x27;./file.csv&#x27;)\nå†™for i, row in df.iterrows():    path = row[&#x27;path&#x27;]    label = row[&#x27;label&#x27;]\næ–°å»ºdata = &#123;    &#x27;path&#x27;: [&#x27;path1&#x27;, &#x27;path2&#x27;],    &#x27;label&#x27;: [&#x27;label1&#x27;, &#x27;label2&#x27;]&#125;    new_df = pd.DateFrame(data)new_df.to_csv(&#x27;./new_file.csv&#x27;, index=False)\nloc æ–¹æ³•å®šä½æŸä¸€è¡Œpath = df.loc[index][&#x27;path&#x27;]\n\nå®šä½æŸåˆ—çš„æŒ‡å®šå€¼df = df.loc[df[&#x27;label&#x27;] == &#x27;Normal&#x27;]df = df.reset_index()","categories":["Kaggle courses"],"tags":["Kaggle","Pandas","Python"]},{"title":"ã€LLMã€‘nanoGPTå­¦ä¹ ","url":"/blog/LLM/nanogpt/","content":"å†™åœ¨å‰é¢æœ¬æ–‡ä¸»è¦è®°å½• nanoGPT çš„å­¦ä¹ è¿‡ç¨‹ï¼Œå‚è€ƒé“¾æ¥\n\nGPT in 60 Lines of NumPyï¼šhttps://jaykmody.com/blog/gpt-from-scratch/60 è¡Œä»£ç å®ç° gptï¼ˆä¸Šä¸€ç¯‡çš„ç¿»è¯‘ï¼‰ï¼š https://zhuanlan.zhihu.com/p/679330102nanoGPT å®æˆ˜ï¼š https://zhuanlan.zhihu.com/p/716442447nanoGPT ä»£ç è§£è¯»ï¼šhttps://zhuanlan.zhihu.com/p/677407971\n\nGPT åŸç†\nGPT(Generative Pre-trained Transformer)åŸºäºTransformerè§£ç å™¨è‡ªå›å½’åœ°é¢„æµ‹ä¸‹ä¸€ä¸ªTokenï¼Œä»è€Œè¿›è¡Œäº†è¯­è¨€æ¨¡å‹çš„å»ºæ¨¡ã€‚GPTçš„ä¼ªä»£ç å¯ä»¥ç®€å•çš„è¡¨ç¤ºä¸ºï¼š\n\ndef gpt(inputs: list[int]) -&gt; list[list[float]]:\t&quot;&quot;&quot; GPTä»£ç ï¼Œå®ç°é¢„æµ‹ä¸‹ä¸€ä¸ªtoken\tinputsï¼šList[int], shapeä¸º[n_seq]ï¼Œè¾“å…¥æ–‡æœ¬åºåˆ—çš„token idçš„åˆ—è¡¨\toutputï¼šList[List[int]], shapeä¸º[n_seq, n_vocab]ï¼Œé¢„æµ‹è¾“å‡ºçš„logitsåˆ—è¡¨\t&quot;&quot;&quot;    output = # éœ€è¦å®ç°çš„GPTå†…éƒ¨è®¡ç®—é€»è¾‘     return output\n\nå³è¾“å…¥ä¸€æ®µtoken\n\nå…³äº token\ntoken å¯ä»¥ç†è§£ä¸ºä¸€ä¸ªå¥å­ä¸­æœ€å°çš„ç»„æˆéƒ¨åˆ†ã€‚é€šå¸¸ä¸ºä¸€ä¸ªè¯ï¼Œä¸€äº›æƒ…å†µä¸‹ï¼Œå¯ä»¥è¿›è¡Œç®€åŒ–ï¼Œä¾‹å¦‚åç»­ä½¿ç”¨èå£«æ¯”äºšçš„ä½œå“é›†è¿›è¡Œè®­ç»ƒæ—¶ï¼Œå°†å­—ç¬¦ä½œä¸º tokenã€‚\n\ntoken é€šè¿‡åˆ†è¯å™¨æ¥è·å–ï¼Œå¯¹åº”ä¸€ä¸ªè¯æ±‡è¡¨ã€‚æœ€å¼€å§‹è¾“å…¥åˆ°æ¨¡å‹ä¸­çš„åºåˆ—å…¶å®ä¸ºä¸€ä¸²æ•°å­—ï¼Œè¡¨ç¤ºå½“å‰ token åœ¨è¯æ±‡è¡¨ä¸­çš„ä½ç½®ã€‚ä¾‹å¦‚ï¼š\n# è¯æ±‡è¡¨ä¸­çš„tokenç´¢å¼•è¡¨ç¤ºè¯¥tokençš„æ•´æ•°ID# ä¾‹å¦‚ï¼Œ&quot;robot&quot;çš„æ•´æ•°IDä¸º1ï¼Œå› ä¸ºvocab[1] = &quot;robot&quot;vocab = [&quot;must&quot;, &quot;robot&quot;, &quot;obey&quot;, &quot;the&quot;, &quot;orders&quot;, &quot;.&quot;]# è¿›è¡Œåˆ†è¯çš„åˆ†è¯å™¨tokenizerï¼ˆå‡è®¾é€šè¿‡ç©ºæ ¼æ¥è¿›è¡Œåˆ†è¯ï¼‰tokenizer = WhitespaceTokenizer(vocab)# encode()æ–¹æ³•å°†strå­—ç¬¦ä¸²è½¬æ¢ä¸ºlist[int]ids = tokenizer.encode(&quot;robot must obey orders&quot;) # ids = [1, 0, 2, 4]# é€šè¿‡è¯æ±‡è¡¨æ˜ å°„ï¼Œå¯ä»¥çœ‹åˆ°å®é™…çš„tokenæ˜¯ä»€ä¹ˆtokens = [tokenizer.vocab[i] for i in ids] # tokens = [&quot;robot&quot;, &quot;must&quot;, &quot;obey&quot;, &quot;orders&quot;]# decode()æ–¹æ³•å°†list[int] è½¬æ¢å›strtext = tokenizer.decode(ids) # text = &quot;robot must obey orders&quot;\n\nåŒæ ·ï¼Œè¾“å‡ºä¸ºä¸€ä¸ªäºŒç»´æ•°ç»„ï¼Œè¡¨ç¤ºå½“å‰ä½ç½®ä¸åŒ token çš„å‡ºç°æ¦‚ç‡ã€‚output æ˜¯ä¸€ä¸ªäºŒç»´æ•°ç»„ï¼Œå…¶ä¸­ output[i][j] è¡¨ç¤ºæ–‡æœ¬åºåˆ—çš„ç¬¬ i ä¸ªä½ç½®çš„ tokenï¼ˆinputs[i]ï¼‰æ˜¯è¯æ±‡è¡¨çš„ç¬¬ j ä¸ª tokenï¼ˆvocab[j]ï¼‰çš„æ¦‚ç‡ï¼ˆå®é™…ä¸ºæœªå½’ä¸€åŒ–çš„logitså¾—åˆ†ï¼‰ã€‚ä¾‹å¦‚ï¼š\ninputs = [1, 0, 2, 4]  # &quot;robot&quot; &quot;must&quot; &quot;obey&quot; &quot;orders&quot;vocab = [&quot;must&quot;, &quot;robot&quot;, &quot;obey&quot;, &quot;the&quot;, &quot;orders&quot;, &quot;.&quot;]output = gpt(inputs)# output[0] = [0.75, 0.1, 0.15, 0.0, 0.0, 0.0]# ç»™å®š &quot;robot&quot;ï¼Œæ¨¡å‹é¢„æµ‹ &quot;must&quot; çš„æ¦‚ç‡æœ€é«˜# output[1] = [0.0, 0.0, 0.8, 0.1, 0.0, 0.1]# ç»™å®šåºåˆ— [&quot;robot&quot;, &quot;must&quot;]ï¼Œæ¨¡å‹é¢„æµ‹ &quot;obey&quot; çš„æ¦‚ç‡æœ€é«˜# output[-1] = [0.0, 0.0, 0.1, 0.0, 0.85, 0.05]# ç»™å®šæ•´ä¸ªåºåˆ—[&quot;robot&quot;, &quot;must&quot;, &quot;obey&quot;]ï¼Œæ¨¡å‹é¢„æµ‹ &quot;orders&quot; çš„æ¦‚ç‡æœ€é«˜next_token_id = np.argmax(output[-1])  # next_token_id = 4next_token = vocab[next_token_id]      # next_token = &quot;orders&quot;\nåœ¨æ¨ç†æ—¶ï¼ˆç”Ÿæˆæ–‡æœ¬ï¼‰ï¼Œé¦–å…ˆå°† prompt è¾“å…¥ GPTï¼Œç„¶åè¿­ä»£åœ°å°†ä¸Šä¸€è½®çš„è¾“å‡ºæ”¾åˆ°å½“å‰çš„æœ«å°¾ï¼Œé‡å¤ç”Ÿæˆã€‚ä¾‹å¦‚ï¼š\ndef generate(inputs, n_tokens_to_generate):\t&quot;&quot;&quot; GPTç”Ÿæˆä»£ç \tinputs: list[int], è¾“å…¥æ–‡æœ¬çš„token idsåˆ—è¡¨\tn_tokens_to_generateï¼šint, éœ€è¦ç”Ÿæˆçš„tokenæ•°é‡\t&quot;&quot;&quot;    # è‡ªå›å½’å¼è§£ç å¾ªç¯    for _ in range(n_tokens_to_generate):         output = gpt(inputs)            # æ¨¡å‹å‰å‘æ¨ç†ï¼Œè¾“å‡ºé¢„æµ‹è¯è¡¨å¤§å°çš„logitsåˆ—è¡¨        next_id = np.argmax(output[-1]) # è´ªå¿ƒé‡‡æ ·        inputs.append(int(next_id))     # å°†é¢„æµ‹æ·»åŠ å›è¾“å…¥    return inputs[len(inputs) - n_tokens_to_generate :]  # åªè¿”å›ç”Ÿæˆçš„ids# éšä¾¿ä¸¾ä¾‹input_ids = [1, 0, 2]                          # [&quot;robot&quot;, &quot;must&quot;, &quot;obey&quot;]output_ids = generate(input_ids, 1)            #  output_ids = [1, 0, 2, 4]output_tokens = [vocab[i] for i in output_ids] # [&quot;robot&quot;, &quot;must&quot;, &quot;obey&quot;, &quot;orders&quot;]\n\nä»£ç é¦–å…ˆï¼Œæœ€å¤–å±‚è°ƒç”¨çš„æ˜¯ GPT ç±»ã€‚è°ƒç”¨æ–¹æ³•ä¸ºï¼š\nlogits, loss = model(X, Y)\nå…¶ä¸­ Xï¼ŒY è¡¨ç¤ºè¾“å…¥ä»¥åŠå…¶å¯¹åº”çš„æ ‡ç­¾ï¼Œæ³¨æ„è¿™é‡Œå·²ç»ä¸º int ç±»å‹çš„æ•°ç»„äº†ï¼ˆè¡¨ç¤º token åœ¨è¯æ±‡è¡¨ä¸­çš„ä½ç½®ï¼‰ã€‚\nGPT ç±»æ•´ä½“ç»“æ„def forward(self, idx, targets=None):    device = idx.device    b, t = idx.size()    assert t &lt;= self.config.block_size, f&quot;Cannot forward sequence of length &#123;t&#125;, block size is only &#123;self.config.block_size&#125;&quot;    pos = torch.arange(0, t, dtype=torch.long, device=device)    tok_emb = self.transformer.wte(idx)     pos_emb = self.transformer.wpe(pos)     x = self.transformer.drop(tok_emb + pos_emb)    for block in self.transformer.h:        x = block(x)    x = self.transformer.ln_f(x)    if targets is not None:        logits = self.lm_head(x)        loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)    else:        logits = self.lm_head(x[:, [-1], :]) # note: using list [-1] to preserve the time dim        loss = None    return logits, loss\n\nè¾“å…¥ idx ç±»å‹ä¸º list[int]ï¼Œè¡¨ç¤ºè¾“å…¥ token åœ¨è¯æ±‡è¡¨ä¸­çš„ç´¢å¼•ï¼Œå¹¶ä¸”æœ‰ batch ç»´åº¦ã€‚æ­¤å¤„æœ‰ä¸€ä¸ªæ–­è¨€ï¼Œå³è¦æ±‚åºåˆ—çš„é•¿åº¦è¦å°äºå—é•¿åº¦ï¼Œå³ block_size è¡¨ç¤ºæ¨¡å‹èƒ½å¤„ç†çš„æœ€å¤§é•¿åº¦ã€‚\næ–°å»ºä¸€ä¸ªä½ç½®æ•°ç»„ psoï¼Œç”¨äºè®¡ç®—ä½ç½®ç¼–ç ã€‚\næ¥ä¸‹æ¥ä¸ºæ ¸å¿ƒä»£ç  self.transformerï¼Œå®ç°å¦‚ä¸‹self.transformer = nn.ModuleDict(dict(    wte = nn.Embedding(config.vocab_size, config.n_embd),    wpe = nn.Embedding(config.block_size, config.n_embd),    drop = nn.Dropout(config.dropout),    h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),    ln_f = LayerNorm(config.n_embd, bias=config.bias),))\nå…¶åŒ…å« 5 ä¸ªéƒ¨åˆ†ï¼štoken ç¼–ç ï¼ˆword token embedding, wteï¼‰ã€ä½ç½®ç¼–ç ï¼ˆword position embedding, wpeï¼‰ã€dropoutã€æ³¨æ„åŠ›å—ï¼ˆblockï¼‰å’Œå±‚å½’ä¸€åŒ–ã€‚\næ•´ä½“å¤„ç†æµç¨‹ä¸ºï¼š\ntoken ç¼–ç  + ä½ç½®ç¼–ç ï¼Œå¹¶ç›¸åŠ \nä¾æ¬¡é€šè¿‡æ³¨æ„åŠ›å±‚\nç»è¿‡æœ€ç»ˆçš„æ˜ å°„å±‚ï¼ˆå°†æ³¨æ„åŠ›çš„è¾“å‡ºæ˜ å°„åˆ°è¯æ±‡è¡¨ç»´åº¦ï¼‰\næœ€åè¿›è¡Œåˆ¤æ–­æ˜¯å¦è®¡ç®— loss\n\n\n\ntoken ç¼–ç å’Œä½ç½®ç¼–ç \ntoken ç¼–ç ï¼šwte æ˜¯ä¸€ä¸ª [n_vocab, n_embd] å¤§å°çš„å¯å­¦ä¹ å‚æ•°çŸ©é˜µï¼Œå®ƒå……å½“ä¸€ä¸ª token åµŒå…¥æŸ¥æ‰¾è¡¨ï¼Œå…¶ä¸­çŸ©é˜µçš„ç¬¬ i å¯¹åº”äºè¯æ±‡è¡¨ä¸­ç¬¬ i ä¸ª token çš„ embeddingã€‚\nwte[idx] ä½¿ç”¨ Token Ids åˆ—è¡¨ç´¢å¼•æ¥æ£€ç´¢ä¸è¾“å…¥ä¸­æ¯ä¸ªtokenå¯¹åº”çš„å‘é‡ã€‚\n\n\nä½ç½®ç¼–ç ï¼šè¡¨ç¤ºåºåˆ—çš„å…ˆåä¿¡æ¯ï¼ŒåŒæ ·æ˜¯ä¸€ä¸ª [n_block, n_embd] å¤§å°çš„å¯å­¦ä¹ å‚æ•°çŸ©é˜µã€‚\n\nBlock ç±»\nBlock ç±»çš„å®ç°å¦‚ä¸‹ï¼šclass Block(nn.Module):    def __init__(self, config):        super().__init__()        self.ln_1 = LayerNorm(config.n_embd, bias=config.bias)        self.attn = CausalSelfAttention(config)        self.ln_2 = LayerNorm(config.n_embd, bias=config.bias)        self.mlp = MLP(config)    def forward(self, x):        x = x + self.attn(self.ln_1(x))        x = x + self.mlp(self.ln_2(x))        return x\nå…¶ä¸»è¦åŒ…å«ä¸¤ä¸ªå±‚å½’ä¸€åŒ–ã€MLPå’Œæ³¨æ„åŠ›å±‚ã€‚\n\nCausalSelfAttention ç±»å®ç°æ³¨æ„åŠ›æœºåˆ¶çš„æ ¸å¿ƒç±»ã€‚\ndef forward(self, x):    B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)    # calculate query, key, values for all heads in batch and move head forward to be the batch dim    q, k, v  = self.c_attn(x).split(self.n_embd, dim=2)    k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)    q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)    v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)    # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -&gt; (B, nh, T, T)    if self.flash:        # efficient attention using Flash Attention CUDA kernels        y = torch.nn.functional.scaled_dot_product_attention(q, k, v, attn_mask=None, dropout_p=self.dropout if self.training else 0, is_causal=True)    else:        # manual implementation of attention        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float(&#x27;-inf&#x27;))        att = F.softmax(att, dim=-1)        att = self.attn_dropout(att)        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -&gt; (B, nh, T, hs)    y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side    # output projection    y = self.resid_dropout(self.c_proj(y))    return y\n\nself.c_attn(x) è¡¨ç¤ºä¸ºæ³¨æ„åŠ›æœºåˆ¶çš„æ˜ å°„å±‚ï¼Œå¹¶å°† Qã€Kã€V ä¸‰ä¸ªæ˜ å°„å±‚åˆå¹¶ä¸ºä¸€ä¸ªï¼Œå‡å°‘è®¡ç®—é‡ã€‚è®¡ç®—å‡ºæ˜ å°„çŸ©é˜µåå†è¿›è¡Œåˆ’åˆ†ã€‚\nself.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd, bias=config.bias)\n\næ¥ä¸‹æ¥æ ¹æ® head çš„æ•°é‡å¯¹æ˜ å°„çŸ©é˜µè¿›è¡Œåˆ’åˆ†ã€‚ç„¶åå°±æ˜¯è®¡ç®—æ³¨æ„åŠ›ã€‚\n\næ³¨æ„ï¼Œä¸ºäº†å®ç°å› æœæœºåˆ¶ï¼Œå³æ¨¡å‹åªèƒ½çœ‹åˆ°å½“å‰ token ä¹‹å‰çš„ tokenï¼Œéœ€è¦å°†è®¡ç®—å‡ºçš„ attn çŸ©é˜µ mask ä¸€éƒ¨åˆ†ã€‚\n# è¾“å…¥æ˜¯ [&quot;not&quot;, &quot;all&quot;, &quot;heroes&quot;, &quot;wear&quot;, &quot;capes&quot;] # åŸå§‹è‡ªæ³¨æ„åŠ›        not    all   heroes  wear  capes   not 0.116  0.159  0.055  0.226  0.443   all 0.180  0.397  0.142  0.106  0.175heroes 0.156  0.453  0.028  0.129  0.234  wear 0.499  0.055  0.133  0.017  0.295 capes 0.089  0.290  0.240  0.228  0.153 # å› æœè‡ªæ³¨æ„åŠ› ï¼ˆè¡Œä¸ºj, åˆ—ä¸ºiï¼‰ # ä¸ºé˜²æ­¢è¾“å…¥çš„æ‰€æœ‰æŸ¥è¯¢éƒ½èƒ½é¢„æµ‹æœªæ¥ï¼Œéœ€è¦å°†æ‰€æœ‰j&gt;iä½ç½®è®¾ç½®ä¸º0 ï¼š        not    all   heroes  wear  capes   not 0.116  0.     0.     0.     0.   all 0.180  0.397  0.     0.     0.heroes 0.156  0.453  0.028  0.     0.  wear 0.499  0.055  0.133  0.017  0. capes 0.089  0.290  0.240  0.228  0.153 # åœ¨åº”ç”¨ softmax ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦ä¿®æ”¹æˆ‘ä»¬çš„æ³¨æ„åŠ›çŸ©é˜µï¼Œå¾—åˆ°æ©ç è‡ªæ³¨æ„åŠ› # å³ï¼Œåœ¨softmaxä¹‹å‰å°†è¦å±è”½é¡¹çš„æ³¨æ„åŠ›å¾—åˆ†è®¾ç½®ä¸º âˆ’âˆï¼ˆå½’ä¸€åŒ–ç³»æ•°ä¸º0ï¼‰ # maskæ©ç çŸ©é˜µ 0 -1e10 -1e10 -1e10 -1e10 0   0   -1e10 -1e10 -1e10 0   0     0   -1e10 -1e10 0   0     0     0   -1e10 0   0     0     0     0 ä½¿ç”¨ -1e10 è€Œä¸æ˜¯ -np.inf ï¼Œå› ä¸º -np.inf å¯èƒ½ä¼šå¯¼è‡´ nans\n\nè‡³æ­¤ï¼Œæ•´ä¸ª GPT çš„ç»“æ„æ‹†è§£å®Œæ¯•ã€‚\n","categories":["LLM"],"tags":["LLM"]},{"title":"ã€Smol Courseã€‘1-æŒ‡ä»¤è°ƒä¼˜","url":"/blog/LLM/smol1/","content":"Chat templateMessage and modelä»¥ä¸‹ä»£ç å®šä¹‰äº†ä¸€æ¡æ¶ˆæ¯ï¼ŒåŒ…æ‹¬ç”¨æˆ·å’Œå¤§æ¨¡å‹ä¸¤ä¸ªè§’è‰²ã€‚\nmessages = [    &#123;        &quot;role&quot;: &quot;user&quot;,         &quot;content&quot;: &quot;Hello, how are you?&quot;&#125;,    &#123;        &quot;role&quot;: &quot;assistant&quot;,        &quot;content&quot;: &quot;I&#x27;m doing well, thank you! How can I assist you today?&quot;,    &#125;,]\næ¨¡å‹åŒ…æ‹¬ä¸¤ä¸ªéƒ¨åˆ†ï¼šmodelï¼ˆdecoderï¼‰å’Œ tokenizerã€‚\nfrom transformers import AutoModelForCausalLM, AutoTokenizerfrom trl import setup_chat_formatimport torchdevice = (    &quot;cuda&quot;    if torch.cuda.is_available()    else &quot;mps&quot; if torch.backends.mps.is_available() else &quot;cpu&quot;)model_name = &quot;D:\\study\\smol-course\\data\\SmolLM2-135M&quot;model = AutoModelForCausalLM.from_pretrained(    pretrained_model_name_or_path=model_name).to(device)tokenizer = AutoTokenizer.from_pretrained(pretrained_model_name_or_path=model_name)model, tokenizer = setup_chat_format(model=model, tokenizer=tokenizer)\n\næ³¨æ„è¿™é‡Œçš„ setup_chat_format æ–¹æ³•ï¼Œé€šè¿‡æ·»åŠ ç‰¹æ®Šçš„ token æ¥è®¾ç½®æ¨¡å‹çš„èŠå¤©æ¨¡æ¿ã€‚\nApply chat templateä½¿ç”¨ tokenizer çš„ apply_chat_template æ–¹æ³•å°†å®šä¹‰çš„ messageï¼ˆlistï¼‰è½¬æ¢ä¸ºå¸¦ç‰¹æ®Š token çš„å­—ç¬¦ä¸²ï¼š\ninput_text = tokenizer.apply_chat_template(messages, tokenize=False)print(&quot;Conversation with template:\\n&quot;, input_text)\n\nç»“æœä¸ºï¼š\n\n&lt;|im_start|&gt;userHello, how are you?&lt;|im_end|&gt;&lt;|im_start|&gt;assistantIâ€™m doing well, thank you! How can I assist you today?&lt;|im_end|&gt;  \n\nå¦‚æœå°† tokenize å‚æ•°è®¾ç½®ä¸º trueï¼Œåˆ™ä¼šå°† token æ˜ å°„ä¸º token è¡¨ä¸­çš„ idã€‚å¯ä»¥ä½¿ç”¨ tokenizer çš„ decode æ–¹æ³•å°† id è½¬æ¢ä¸º tokenã€‚\ninput_text = tokenizer.apply_chat_template(    messages, tokenize=True, add_generation_prompt=True)print(&quot;Conversation decoded:&quot;, tokenizer.decode(token_ids=input_text))\n\næ­¤å¤–ï¼Œapply_chat_template è¿˜æœ‰ä¸€ä¸ªå‚æ•° ä¸º add_generation_promptï¼Œä½œç”¨æ˜¯æ·»åŠ ä¸‹ä¸€æ¡æ¶ˆæ¯çš„å¼€å¤´ï¼Œå³ä¸‹é¢ç»“æœçš„æœ€åä¸€è¡Œ &lt;|im_start|&gt;assistant ã€‚ \n\nConversation decoded: &lt;|im_start|&gt;userHello, how are you?&lt;|im_end|&gt;&lt;|im_start|&gt;assistantIâ€™m doing well, thank you! How can I assist you today?&lt;|im_end|&gt;&lt;|im_start|&gt;assistant  \n\nProcess datatset for SFTä¸ºç°æœ‰çš„æ•°æ®é›†æ·»åŠ èŠå¤©æ¨¡æ¿ã€‚\næ¡ˆä¾‹ 1é¦–å…ˆåŠ è½½æ•°æ®é›†å¹¶æ‰“å°\nfrom datasets import load_datasetds = load_dataset(&quot;HuggingFaceTB/smoltalk&quot;, &quot;everyday-conversations&quot;, cache_dir=&quot;D:\\study\\smol-course\\data&quot;)print(ds)\n\nç»“æœä¸ºå¦‚ä¸‹ï¼ŒåŒ…å«ä¸¤ä¸ªéƒ¨åˆ†ï¼Œåˆ†åˆ«ä¸ºæµ‹è¯•é›†å’Œè®­ç»ƒé›†ã€‚\n\nDatasetDict({\n     train: Dataset({\n         features: ['full_topic', 'messages'],\n         num_rows: 2260\n     })\n     test: Dataset({\n         features: ['full_topic', 'messages'],\n         num_rows: 119\n     })\n})\n\n\nè¿™é‡Œçš„ message å°±æ˜¯ä¸€ä¸ªåŒ…å«äº†ç”¨æˆ·å’Œå¤§æ¨¡å‹ä¹‹é—´å¯¹è¯çš„ listï¼Œå†…å®¹å¦‚ä¸‹ï¼Œå¯ä»¥ç›´æ¥åº”ç”¨èŠå¤©æ¨¡æ¿ã€‚\n\n[{â€˜contentâ€™: â€˜Hi thereâ€™, â€˜roleâ€™: â€˜userâ€™}, {â€˜contentâ€™: â€˜Hello! How can I help you today?â€™, â€˜roleâ€™: â€˜assistantâ€™}, {â€˜contentâ€™: â€œIâ€™m looking for a beach resort for my next vacation. Can you recommend some popular ones?â€, â€˜roleâ€™: â€˜userâ€™}, {â€˜contentâ€™: â€œSome popular beach resorts include Maui in Hawaii, the Maldives, and the Bahamas. Theyâ€™re known for their beautiful beaches and crystal-clear waters.â€, â€˜roleâ€™: â€˜assistantâ€™}, {â€˜contentâ€™: â€˜That sounds great. Are there any resorts in the Caribbean that are good for families?â€™, â€˜roleâ€™: â€˜userâ€™}, {â€˜contentâ€™: â€˜Yes, the Turks and Caicos Islands and Barbados are excellent choices for family-friendly resorts in the Caribbean. They offer a range of activities and amenities suitable for all ages.â€™, â€˜roleâ€™: â€˜assistantâ€™}, {â€˜contentâ€™: â€œOkay, Iâ€™ll look into those. Thanks for the recommendations!â€, â€˜roleâ€™: â€˜userâ€™}, {â€˜contentâ€™: â€œYouâ€™re welcome. I hope you find the perfect resort for your vacation.â€, â€˜roleâ€™: â€˜assistantâ€™}]\n\nåº”ç”¨èŠå¤©æ¨¡æ¿çš„ä»£ç ä¸ºï¼š\ndef process_dataset(sample):    # TODO: ğŸ¢ Convert the sample into a chat format    # use the tokenizer&#x27;s method to apply the chat template    sample = tokenizer.apply_chat_template(sample[&quot;messages&quot;], tokenize=False)        return &#123;&quot;chat&quot;: sample&#125;ds = ds.map(process_dataset)print(ds)\n\nä¸Šè¿°ä»£ç å®šä¹‰ä¸€ä¸ª process_dataset å‡½æ•°ï¼Œç”¨äºå¤„ç†æ•°æ®é›†ã€‚map æ–¹æ³•å¯¹æ•°æ®é›†ä¸­çš„æ¯ä¸ªæ ·æœ¬éƒ½æ‰§è¡Œç»™å®šçš„å‡½æ•°ã€‚æ­¤å¤–ï¼Œmap æ˜¯æ›´æ–°å¼æ˜ å°„ï¼Œå¸Œæœ›è¿”å›ä¸€ä¸ªå­—å…¸ï¼Œæ·»åŠ åˆ°åŸæœ‰çš„æ•°æ®é›†å­—å…¸ä¸­ã€‚ä¸Šè¿°ä»£ç çš„ç»“æœä¸ºï¼š\nDatasetDict({\n    train: Dataset({\n        features: ['full_topic', 'messages', 'chat'],\n        num_rows: 2260\n    })\n    test: Dataset({\n        features: ['full_topic', 'messages', 'chat'],\n        num_rows: 119\n    })\n})\n\nå¯ä»¥çœ‹åˆ°ï¼ŒåŸæœ‰çš„æ•°æ®é›†å­—å…¸ä¸­æ–°å¢äº†ä¸€ä¸ªå­—æ®µ chatï¼Œå†…å®¹ä¸ºæ·»åŠ äº†èŠå¤©æ¨¡æ¿çš„å­—ç¬¦ä¸²ã€‚\næ¡ˆä¾‹ 2æœ¬æ•°æ®é›†åŒ…å«äº†ä¸€ä¸ªé—®é¢˜å’Œç›¸åº”çš„å›ç­”ï¼Œæ‰€ä»¥åœ¨ process_dataset å‡½æ•°ä¸­è¦å…ˆå®šä¹‰ä¸€ä¸ª messageï¼Œç„¶åå†å°† message è½¬æ¢ä¸ºå¸¦å¤´èŠå¤©æ¨¡æ¿çš„å­—ç¬¦ä¸²ã€‚\nds = load_dataset(&quot;openai/gsm8k&quot;, &quot;main&quot;, cache_dir=&quot;D:\\study\\smol-course\\data&quot;)print(ds)def process_dataset(sample):    # TODO: ğŸ• Convert the sample into a chat format    # 1. create a message format with the role and content    message = [        &#123;&#x27;role&#x27;: &#x27;user&#x27;, &#x27;content&#x27;: sample[&#x27;question&#x27;]&#125;,        &#123;&#x27;role&#x27;: &#x27;assistant&#x27;, &#x27;content&#x27;: sample[&#x27;answer&#x27;]&#125;    ]    # 2. apply the chat template to the samples using the tokenizer&#x27;s method    sample = tokenizer.apply_chat_template(message, tokenize=False)    return &#123;&quot;chat&quot;: sample&#125;ds = ds.map(process_dataset)print(ds)\n\nç»“æœä¸ºï¼š\nDatasetDict({\n    train: Dataset({\n        features: ['question', 'answer'],\n        num_rows: 7473\n    })\n    test: Dataset({\n        features: ['question', 'answer'],\n        num_rows: 1319\n    })\n})\nDatasetDict({\n    train: Dataset({\n        features: ['question', 'answer', 'chat'],\n        num_rows: 7473\n    })\n    test: Dataset({\n        features: ['question', 'answer', 'chat'],\n        num_rows: 1319\n    })\n})\n\n\nSupervised Fine-tuning with SFTTrainerPreparationåŒ…å«ä»¥ä¸‹éƒ¨åˆ†ï¼š\n\ndevice\nmodel\ntokenizer\nè®¾ç½®èŠå¤©æ¨¡æ¿\n\n# Import necessary librariesfrom transformers import AutoModelForCausalLM, AutoTokenizerfrom datasets import load_datasetfrom trl import SFTConfig, SFTTrainer, setup_chat_formatimport torchdevice = (    &quot;cuda&quot;    if torch.cuda.is_available()    else &quot;mps&quot; if torch.backends.mps.is_available() else &quot;cpu&quot;)# Load the model and tokenizermodel_name = &quot;D:\\study\\smol-course\\data\\SmolLM2-135M&quot;model = AutoModelForCausalLM.from_pretrained(    pretrained_model_name_or_path=model_name).to(device)tokenizer = AutoTokenizer.from_pretrained(pretrained_model_name_or_path=model_name)# Set up the chat formatmodel, tokenizer = setup_chat_format(model=model, tokenizer=tokenizer)\n\nGenerate with base model\næ„å»º messageï¼Œç„¶åä½¿ç”¨ tokenizer çš„ apply_chat_template æ–¹æ³•å…ˆå°†å½¢å¼ä¸ºå­—å…¸çš„ message è½¬æ¢ä¸ºå¸¦ç‰¹æ®Šç¬¦å·çš„å­—ç¬¦ä¸²ã€‚\nprompt = &quot;Write me a haiku about programming&quot;# Format with templatemessages = [&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt&#125;]formatted_prompt = tokenizer.apply_chat_template(messages, tokenize=False)# &lt;|im_start|&gt;userWrite me a haiku about programming&lt;|im_end|&gt;\n\nç„¶åå†è¿›è¡Œ tokenize å¤„ç†ï¼Œtokenizer è¿”å›å­—å…¸ï¼ŒåŒ…æ‹¬ token çš„ç¼–ç ä»¥åŠä¸€ä¸ª maskï¼Œç”¨äºè¡¨ç¤ºå“ªäº›ä½ç½®æ˜¯ padding\n\n\ninputs = tokenizer(formatted_prompt, return_tensors=&quot;pt&quot;).to(device)# inputs# &#123;#   &#x27;input_ids&#x27;: tensor([[101, ..., 102]]), token çš„ç¼–å·#   &#x27;attention_mask&#x27;: tensor([[1, 1, ..., 1]]) æœ‰æ•ˆ token æ©ç ï¼ˆå½“è¾“å…¥é•¿åº¦ä¸è¶³æœ€å¤§é•¿åº¦æ—¶ï¼Œtokenizer ä¼šè‡ªåŠ¨è¡¥é½ï¼ˆpaddingï¼‰ï¼Œç„¶åç”¨ attention_mask é¿å…æ¨¡å‹åœ¨è®¡ç®— self-attention æ—¶æŠŠè¿™äº› padding ä½ç½®ä¹Ÿè€ƒè™‘è¿›æ¥ï¼‰# &#125;\n\nç”Ÿæˆå›ç­”ï¼šmodel.generate éœ€è¦å¤šä¸ªå‚æ•°ï¼Œ** å°±æ˜¯è‡ªåŠ¨å¸®ä½ æŠŠå­—å…¸æ‹†å¼€ä¸€ä¸ªä¸ªä¼ è¿›å»ã€‚\nskip_special_tokens&#x3D;True è¡¨ç¤º decode æ—¶å¿½ç•¥ chat template ä¸­çš„ç‰¹æ®Šå­—ç¬¦\nç”Ÿæˆçš„ outputs ä¸ºä¸€ä¸ª listï¼Œéœ€è¦å–ç¬¬ 0 ä¸ªå…ƒç´ ï¼ˆwhyï¼Ÿï¼‰ï¼ŒåŒæ ·ä¸º token çš„ ç¼–å·ï¼Œé€šè¿‡ decode æ–¹æ³•æ˜ å°„åˆ°æ–‡æœ¬ã€‚outputs = model.generate(**inputs, max_new_tokens=100)print(tokenizer.decode(outputs[0], skip_special_tokens=True))\n\n\n\nDatasetç»™å®šçš„æ•°æ®é›†ä¸­å·²ç»æœ‰ dict æ ¼å¼çš„ messageï¼Œåªéœ€è¦å¯¹æ¯æ¡ message åšå¤„ç†ï¼Œå°†å…¶ç”Ÿæˆä¸ºä¸€ä¸ªå¸¦ç‰¹æ®Šç¬¦å·çš„å­—ç¬¦ä¸²å³å¯ã€‚æ³¨æ„æœ€åçš„ç»“æœæ˜¯å¤šäº†ä¸€ä¸ª chat å­—æ®µã€‚\ndef process_dataset(sample):    sample = tokenizer.apply_chat_template(sample[&quot;messages&quot;], tokenize=False)        return &#123;&quot;chat&quot;: sample&#125;print(ds[&#x27;train&#x27;][0])&quot;&quot;&quot;&#123;&#x27;full_topic&#x27;: &#x27;Travel/Vacation destinations/Beach resorts&#x27;, &#x27;messages&#x27;: ...&#125;&quot;&quot;&quot;ds = ds.map(process_dataset)print(ds[&#x27;train&#x27;][0])# å¤šäº†ä¸€ä¸ªå­—æ®µ chat&quot;&quot;&quot;&#123;&#x27;full_topic&#x27;: &#x27;Travel/Vacation destinations/Beach resorts&#x27;, &#x27;messages&#x27;: ..., &#x27;chat&#x27;: &quot;...&quot;&#125;&quot;&quot;&quot;\n\nTrain modelè®¾ç½® SFTConfig å’Œ SFTTrainerã€‚æ³¨æ„ï¼Œå°½é‡å°†æ‰€æœ‰çš„å‚æ•°éƒ½å†™åœ¨ SFTConfig ä¸­ã€‚\n# Configure the SFTTrainersft_config = SFTConfig(    dataset_text_field=&quot;chat&quot;, # è®¾ç½®ä½œä¸ºæ•°æ®é›†çš„å­—æ®µ    max_seq_length=512, # æœ€å¤§çš„åºåˆ—é•¿åº¦    output_dir=&quot;./sft_output&quot;,    max_steps=1000,  # æœ€å¤§è®­ç»ƒæ­¥æ•°    per_device_train_batch_size=4,  # batch    learning_rate=5e-5,  # å­¦ä¹ ç‡    logging_steps=10,  # æ¯ 10 æ­¥è®¡ç®—ä¸€æ¬¡è®­ç»ƒçš„ log    save_steps=100,  # æ¯ 100 æ­¥ä¿å­˜ä¸€æ¬¡    eval_strategy=&quot;steps&quot;,  # è¯„ä¼°å‘¨æœŸçš„å•ä½    eval_steps=50,  # æ¯ 50 æ­¥è¯„ä¼°ä¸€æ¬¡    use_mps_device=(        True if device == &quot;mps&quot; else False    ),  # Use MPS for mixed precision training    hub_model_id=finetune_name,  # è®¾ç½®æœ¬æ¬¡è®­ç»ƒçš„åå­—)# Initialize the SFTTrainertrainer = SFTTrainer(    model=model,    args=sft_config,    train_dataset=ds[&quot;train&quot;],    tokenizer=tokenizer,    eval_dataset=ds[&quot;test&quot;],)\n\nè®­ç»ƒå¹¶ä¿å­˜æ¨¡å‹\n# Train the modeltrainer.train()# Save the modeltrainer.save_model(f&quot;./&#123;finetune_name&#125;&quot;)\n\nGenerate with trained modelä»£ç å’Œå‰é¢çš„ç›¸ä¼¼\nmodel_path = &quot;D:/study/smol-course/1_instruction_tuning/notebooks/SmolLM2-FT-MyDataset&quot;# Load the model and tokenizermodel = AutoModelForCausalLM.from_pretrained(    pretrained_model_name_or_path=model_path).to(device)tokenizer = AutoTokenizer.from_pretrained(pretrained_model_name_or_path=model_path)# Set up the chat format# model, tokenizer = setup_chat_format(model=model, tokenizer=tokenizer)prompt = &quot;Write a haiku about programming&quot;# Format with templatemessages = [&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt&#125;]formatted_prompt = tokenizer.apply_chat_template(messages, tokenize=False)# Generate responseinputs = tokenizer(formatted_prompt, return_tensors=&quot;pt&quot;).to(device)outputs = model.generate(**inputs, max_new_tokens=100)print(&quot;After training:&quot;)print(tokenizer.decode(outputs[0], skip_special_tokens=True))\n\næ³¨æ„ï¼Œè®­ç»ƒåçš„æ¨¡å‹å°±ä¸éœ€è¦ setup_chat_format äº†ã€‚å› ä¸ºåœ¨è®­ç»ƒä¹‹å‰å·²ç»è®¾ç½®è¿‡ï¼Œå¹¶ä¿å­˜åˆ°äº†ç›¸åº”çš„ json æ–‡ä»¶ä¸­ã€‚éªŒè¯å¦‚ä¸‹ï¼š\nori_tokenizer = AutoTokenizer.from_pretrained(pretrained_model_name_or_path=&quot;D:\\study\\smol-course\\data\\SmolLM2-135M&quot;)print(&quot;before training: &quot;, ori_tokenizer.chat_template)# Noneprint(&quot;after training: &quot;, tokenizer.chat_template)# &#123;% for message in messages %&#125;&#123;&#123;&#x27;&lt;|im_start|&gt;&#x27; + message[&#x27;role&#x27;] + &#x27;# &#x27; + message[&#x27;content&#x27;] + &#x27;&lt;|im_end|&gt;&#x27; + &#x27;# &#x27;&#125;&#125;&#123;% endfor %&#125;&#123;% if add_generation_prompt %&#125;&#123;&#123; &#x27;&lt;|im_start|&gt;assistant# &#x27; &#125;&#125;&#123;% endif %&#125;","categories":["LLM"],"tags":["trl","smol"]},{"title":"ã€Smol Courseã€‘2-åå¥½å¯¹é½","url":"/blog/LLM/smol2/","content":"Preference Alignmentç›‘ç£å¾®è°ƒæœ‰åŠ©äºæ¨¡å‹å­¦ä¹ ä»»åŠ¡ï¼Œä½†åå¥½å¯¹é½é¼“åŠ±è¾“å‡ºç¬¦åˆäººç±»çš„æœŸæœ›å’Œä»·å€¼è§‚ã€‚\n\nDirect Preference Optimization (DPO)ï¼šç›´æ¥åå¥½ä¼˜åŒ–ï¼ˆDPOï¼‰é€šè¿‡ä½¿ç”¨åå¥½æ•°æ®ç›´æ¥ä¼˜åŒ–æ¨¡å‹æ¥ç®€åŒ–åå¥½å¯¹é½ã€‚è¿™ç§æ–¹æ³•æ¶ˆé™¤äº†å¯¹å•ç‹¬çš„å¥–åŠ±æ¨¡å‹å’Œå¤æ‚çš„å¼ºåŒ–å­¦ä¹ çš„éœ€è¦ï¼Œä½¿å…¶æ¯”ä¼ ç»Ÿçš„åŸºäºäººç±»åé¦ˆçš„å¼ºåŒ–å­¦ä¹ ï¼ˆRLHFï¼‰æ›´åŠ ç¨³å®šå’Œé«˜æ•ˆã€‚\nOdds Ratio Preference Optimization (ORPO)ï¼šORPOåœ¨å•ä¸ªè¿›ç¨‹ä¸­å¼•å…¥äº†æŒ‡ä»¤è°ƒä¼˜å’Œåå¥½å¯¹é½çš„ç»„åˆæ–¹æ³•ã€‚å®ƒé€šè¿‡åœ¨ token çº§åˆ«ä¸Šå°†è´Ÿå¯¹æ•°ä¼¼ç„¶æŸå¤±ä¸æ¯”å€¼æ¯”é¡¹ç»“åˆèµ·æ¥ï¼Œä¿®æ”¹äº†æ ‡å‡†è¯­è¨€å»ºæ¨¡ç›®æ ‡ã€‚è¯¥æ–¹æ³•å…·æœ‰ç»Ÿä¸€çš„å•é˜¶æ®µè®­ç»ƒè¿‡ç¨‹ã€å‚è€ƒæ— æ¨¡å‹æ¶æ„å’Œæé«˜è®¡ç®—æ•ˆç‡çš„ç‰¹ç‚¹ã€‚\n\nDPODPO å°†åå¥½å¯¹é½é‡æ–°å®šä¹‰ä¸ºäººç±»åå¥½æ•°æ®çš„åˆ†ç±»é—®é¢˜ã€‚ä¼ ç»Ÿçš„ RLHF æ–¹æ³•éœ€è¦è®­ç»ƒä¸€ä¸ªå•ç‹¬çš„å¥–åŠ±æ¨¡å‹ï¼Œå¹¶ä½¿ç”¨å¤æ‚çš„å¼ºåŒ–å­¦ä¹ ç®—æ³•ï¼ˆå¦‚ PPOï¼‰æ¥æ ¡å‡†æ¨¡å‹è¾“å‡ºã€‚DPO é€šè¿‡å®šä¹‰ä¸€ä¸ªæŸå¤±å‡½æ•°æ¥ç®€åŒ–è¿™ä¸€è¿‡ç¨‹ï¼Œè¯¥æŸå¤±å‡½æ•°å¯ä»¥æ ¹æ®é¦–é€‰è¾“å‡ºå’Œéé¦–é€‰è¾“å‡ºç›´æ¥ä¼˜åŒ–æ¨¡å‹çš„ç­–ç•¥ã€‚\nHow DPO worksDPO è¿‡ç¨‹éœ€è¦ç›‘ç£å¾®è°ƒï¼ˆSFTï¼‰æ¥ä½¿æ¨¡å‹é€‚åº”ç›®æ ‡åŸŸã€‚è¿™ä¸ºé€šè¿‡åœ¨æ ‡å‡†æŒ‡ä»¤éµå¾ªæ•°æ®é›†ä¸Šè¿›è¡Œè®­ç»ƒæ¥è¿›è¡Œåå¥½å­¦ä¹ å¥ å®šäº†åŸºç¡€ã€‚è¯¥æ¨¡å‹åœ¨ä¿æŒå…¶ä¸€èˆ¬èƒ½åŠ›çš„åŒæ—¶å­¦ä¹ åŸºæœ¬ä»»åŠ¡çš„å®Œæˆã€‚\næ¥ä¸‹æ¥æ˜¯åå¥½å­¦ä¹ ï¼Œå…¶ä¸­æ¨¡å‹åœ¨æˆå¯¹çš„è¾“å‡ºä¸Šè¿›è¡Œè®­ç»ƒâ€”â€”ä¸€ä¸ªæ˜¯é¦–é€‰çš„ï¼Œä¸€ä¸ªæ˜¯éé¦–é€‰çš„ã€‚åå¥½å¯¹å¸®åŠ©æ¨¡å‹ç†è§£å“ªç§ååº”æ›´ç¬¦åˆäººç±»çš„ä»·å€¼è§‚å’ŒæœŸæœ›ã€‚\nDPO çš„æ ¸å¿ƒåˆ›æ–°åœ¨äºå…¶ç›´æ¥ä¼˜åŒ–æ–¹æ³•ã€‚DPO ä¸æ˜¯è®­ç»ƒå•ç‹¬çš„å¥–åŠ±æ¨¡å‹ï¼Œè€Œæ˜¯ä½¿ç”¨äºŒå…ƒäº¤å‰ç†µæŸå¤±æ¥ç›´æ¥æ›´æ–°åŸºäºåå¥½æ•°æ®çš„æ¨¡å‹æƒé‡ã€‚è¿™ç§ç®€åŒ–çš„è¿‡ç¨‹ä½¿è®­ç»ƒæ›´åŠ ç¨³å®šå’Œé«˜æ•ˆï¼ŒåŒæ—¶è¾¾åˆ°ä¸ä¼ ç»Ÿ RLHF ç›¸å½“æˆ–æ›´å¥½çš„ç»“æœã€‚\nDatasetDPO çš„æ•°æ®é›†é€šå¸¸æ˜¯é€šè¿‡å°†å“åº”å¯¹æ³¨é‡Šä¸ºé¦–é€‰æˆ–éé¦–é€‰æ¥åˆ›å»ºçš„ã€‚é€šå¸¸åŒ…å« promptã€chosen å’Œ selected ä¸‰éƒ¨åˆ†ã€‚\nPrompt åŒ…å«ç”¨äºç”Ÿæˆ selected å’Œ Rejected å“åº”çš„æç¤ºã€‚selected å’Œ Rejected åˆ†åˆ«åŒ…å«é¦–é€‰å’Œéé¦–é€‰çš„å“åº”ã€‚\nImplementation with TRLç®€å•å®ç°å¦‚ä¸‹ï¼š\nfrom trl import DPOConfig, DPOTrainer# Define argumentstraining_args = DPOConfig(    ...)# Initialize trainertrainer = DPOTrainer(    model,    train_dataset=dataset,    tokenizer=tokenizer,    ...)# Train modeltrainer.train()\n\nPracticeå¯¼å…¥åŒ…import torchimport osfrom transformers import AutoModelForCausalLM, AutoTokenizerfrom datasets import load_datasetfrom trl import DPOTrainer, DPOConfig\n\næ•°æ®é›†è®¾ç½® cache_dir å­—æ®µå³å¯å°†å…¶ä¸‹è½½åˆ°æŒ‡å®šç›®å½•ã€‚åç»­å¯ä»¥ç›´æ¥åŠ è½½ä½¿ç”¨ã€‚\ndataset = load_dataset(&quot;argilla/ultrafeedback-binarized-preferences&quot;, split=&quot;train&quot;, cache_dir=&quot;D:\\study\\smol-course\\data&quot;)\n\næŸ¥çœ‹æ•°æ®é›†ï¼Œæ ¸å¿ƒä¸º instructionã€chosen_response å’Œ rejected_responseã€‚\n\nDataset({\n    features: ['source', 'instruction', 'chosen_response', 'rejected_response', 'chosen_avg_rating', 'rejected_avg_rating', 'chosen_model'],\n    num_rows: 63619\n})\n\n\nä½†æ˜¯ï¼Œchosen_response å’Œ rejected_response åªæœ‰å›ç­”ï¼Œæ²¡æœ‰å½¢æˆå¯¹è¯åˆ—è¡¨ã€‚æ‰€ä»¥éœ€è¦å®šä¹‰å¤„ç†æ•°æ®é›†çš„å‡½æ•°ï¼š\ndef process_dataset(example):    chosen = [        &#123;            &#x27;role&#x27;: &#x27;user&#x27;,            &#x27;content&#x27;: example[&#x27;instruction&#x27;]        &#125;,        &#123;            &#x27;role&#x27;: &#x27;assistant&#x27;,            &#x27;content&#x27;: example[&#x27;chosen_response&#x27;]        &#125;    ]    rejected = [        &#123;            &#x27;role&#x27;: &#x27;user&#x27;,            &#x27;content&#x27;: example[&#x27;instruction&#x27;]        &#125;,        &#123;            &#x27;role&#x27;: &#x27;assistant&#x27;,            &#x27;content&#x27;: example[&#x27;rejected_response&#x27;]        &#125;    ]    return &#123;&#x27;chosen&#x27;: chosen, &#x27;rejected&#x27;: rejected, &#x27;prompt&#x27;: example[&quot;instruction&quot;]&#125;dataset = dataset.map(process_dataset)\n\nåŠ è½½æ¨¡å‹model_name = &quot;HuggingFaceTB/SmolLM2-135M-Instruct&quot;device = (    &quot;cuda&quot;    if torch.cuda.is_available()    else &quot;mps&quot; if torch.backends.mps.is_available() else &quot;cpu&quot;)# Model to fine-tunemodel = AutoModelForCausalLM.from_pretrained(    pretrained_model_name_or_path=model_name,    torch_dtype=torch.float32,).to(device)model.config.use_cache = Falsetokenizer = AutoTokenizer.from_pretrained(model_name)tokenizer.pad_token = tokenizer.eos_tokenmodel, tokenizer = setup_chat_format(model=model, tokenizer=tokenizer)# Set our name for the finetune to be saved &amp;/ uploaded tofinetune_name = &quot;SmolLM2-FT-DPO&quot;finetune_tags = [&quot;smol-course&quot;, &quot;module_1&quot;]\n\næ³¨æ„ï¼š\n\nmodel.config.use_cache &#x3D; Falseï¼šç¦ç”¨ KV-cacheï¼ˆKey&#x2F;Value Cacheï¼‰ã€‚é€šå¸¸åœ¨è®­ç»ƒ&#x2F;å¾®è°ƒæ—¶ç¦ç”¨ç¼“å­˜ï¼ˆä¸ç„¶æ¢¯åº¦è®¡ç®—ä¼šå‡ºé”™ï¼‰ï¼›è€Œåœ¨æ¨ç†æ—¶å¼€å¯ä»¥æå‡ç”Ÿæˆé€Ÿåº¦ã€‚\ntokenizer.pad_token &#x3D; tokenizer.eos_tokenï¼šå°† pad_token è®¾ç½®ä¸º eos_tokenï¼ˆç»“æŸç¬¦ï¼‰ã€‚åŸå› ï¼šæœ‰äº›æ¨¡å‹ï¼ˆå¦‚ GPTï¼‰æ²¡æœ‰ä¸“é—¨å®šä¹‰ pad tokenï¼Œè®­ç»ƒæ—¶åˆéœ€è¦å¯¹åºåˆ—è¿›è¡Œ paddingï¼Œè¿™ç§æƒ…å†µä¸‹é€šå¸¸å°† pad token å’Œ eos token è®¾ä¸ºåŒä¸€ä¸ªã€‚å¦åˆ™è®­ç»ƒæ—¶å¯èƒ½ä¼šå‡ºç°ç¼ºå¤± pad_token çš„é”™è¯¯ã€‚\nè¿™é‡Œéœ€è¦è®¾ç½®èŠå¤©æ¨¡æ¿ï¼šmodel, tokenizer &#x3D; setup_chat_format(model&#x3D;model, tokenizer&#x3D;tokenizer)\n\nè®­ç»ƒDPOConfig å‚æ•°\n# Training argumentstraining_args = DPOConfig(    # Training batch size per GPU    per_device_train_batch_size=4,    # Number of updates steps to accumulate before performing a backward/update pass    # Effective batch size = per_device_train_batch_size * gradient_accumulation_steps    gradient_accumulation_steps=4,    # Saves memory by not storing activations during forward pass    # Instead recomputes them during backward pass    gradient_checkpointing=True,    # Base learning rate for training    learning_rate=5e-5,    # Learning rate schedule - &#x27;cosine&#x27; gradually decreases LR following cosine curve    lr_scheduler_type=&quot;cosine&quot;,    # Total number of training steps    max_steps=200,    # Disables model checkpointing during training    save_strategy=&quot;no&quot;,    # How often to log training metrics    logging_steps=1,    # Directory to save model outputs    output_dir=&quot;smol_dpo_output&quot;,    # Number of steps for learning rate warmup    warmup_steps=100,    # Use bfloat16 precision for faster training    bf16=True,    # Disable wandb/tensorboard logging    report_to=&quot;none&quot;,    # Keep all columns in dataset even if not used    remove_unused_columns=False,    # Enable MPS (Metal Performance Shaders) for Mac devices    use_mps_device=device == &quot;mps&quot;,    # Model ID for HuggingFace Hub uploads    hub_model_id=finetune_name,    # DPO-specific temperature parameter that controls the strength of the preference model    # Lower values (like 0.1) make the model more conservative in following preferences    beta=0.1,    # Maximum length of the input prompt in tokens    max_prompt_length=1024,    # Maximum combined length of prompt + response in tokens    max_length=1536,)\n\n\nper_device_train_batch_size&#x3D;4ï¼šæ¯ä¸ªè®¾å¤‡ï¼ˆGPU&#x2F;MPSï¼‰ä¸Šçš„å¾®è°ƒæ‰¹å¤§å°æ˜¯ 4ã€‚è‹¥ä½ ä½¿ç”¨å¤šä¸ª GPU æˆ– MPSï¼Œåˆ™æ€» batch size ä¼šä¹˜ä»¥è®¾å¤‡æ•°ã€‚\ngradient_accumulation_steps&#x3D;4ï¼šç´¯ç§¯ 4 ä¸ª mini-batch çš„æ¢¯åº¦å†åšä¸€æ¬¡åå‘ä¼ æ’­ã€‚è¿™æ ·å¯ä»¥æ¨¡æ‹Ÿ 4Ã—4&#x3D;16 çš„æœ‰æ•ˆ batch sizeï¼ŒèŠ‚çœæ˜¾å­˜ã€‚\ngradient_checkpointing&#x3D;Trueï¼šå¯ç”¨æ¢¯åº¦æ£€æŸ¥ç‚¹æŠ€æœ¯ï¼šèŠ‚çœå†…å­˜ï¼Œé€šè¿‡åœ¨åå‘ä¼ æ’­æ—¶é‡ç®—ä¸­é—´æ¿€æ´»æ¥æ¢å–å°‘é‡è®¡ç®—å¼€é”€ã€‚\nlearning_rate&#x3D;5e-5ï¼šåˆå§‹å­¦ä¹ ç‡ã€‚å¯¹äº LoRA + å¾®è°ƒä¸€èˆ¬æ¨è 1e-5 ~ 5e-5ã€‚\nlr_scheduler_type&#x3D;â€cosineâ€ï¼šä½¿ç”¨ä½™å¼¦é€€ç«å­¦ä¹ ç‡ç­–ç•¥ï¼ˆcosine scheduleï¼‰ï¼šåˆæœŸç¼“æ…¢å¢å¤§ï¼ŒåæœŸç¼“æ…¢é™ä½ï¼ˆç±»ä¼¼ U å½¢æ›²çº¿ï¼‰ã€‚\nmax_steps&#x3D;200ï¼šæ€»å…±è¿›è¡Œ 200 ä¸ªè®­ç»ƒ stepã€‚é€‚åˆå°è§„æ¨¡è°ƒè¯•æˆ–å¿«é€Ÿå®éªŒã€‚\nsave_strategy&#x3D;â€noâ€ï¼šä¸ä¿å­˜ä¸­é—´æ¨¡å‹ checkpointï¼ˆèŠ‚çœç©ºé—´ï¼Œé€‚åˆè°ƒè¯•ï¼‰ã€‚\nlogging_steps&#x3D;1ï¼šæ¯ 1 æ­¥æ‰“å°ä¸€æ¬¡æ—¥å¿—ï¼ˆéå¸¸é¢‘ç¹ï¼Œä¾¿äºè§‚å¯Ÿï¼‰ã€‚\noutput_dir&#x3D;â€smol_dpo_outputâ€ï¼šæ¨¡å‹å¾®è°ƒè¾“å‡ºç›®å½•ã€‚\nwarmup_steps&#x3D;100ï¼šå‰ 100 ä¸ª step ä½¿ç”¨ warmup ç­–ç•¥é€æ¸æé«˜å­¦ä¹ ç‡ã€‚å¯é¿å…è®­ç»ƒåˆæœŸæ¨¡å‹éœ‡è¡ã€‚\nbf16&#x3D;Trueï¼šä½¿ç”¨ bfloat16 ç²¾åº¦è®­ç»ƒï¼Œé€‚ç”¨äºæ”¯æŒçš„è®¾å¤‡ï¼ˆå¦‚ A100&#x2F;H100ï¼‰ã€‚æ¯” fp16 æ›´ç¨³å®šï¼Œé€‚åˆ DPOã€‚\nreport_to&#x3D;â€noneâ€ï¼šä¸å¯ç”¨æ—¥å¿—è¿½è¸ªå·¥å…·ï¼ˆå¦‚ WandBã€TensorBoardï¼‰ã€‚\nremove_unused_columns&#x3D;Falseï¼šä¿ç•™æ‰€æœ‰è¾“å…¥å­—æ®µï¼Œå¿…è¦è®¾ç½®ï¼Œå› ä¸º DPO ä½¿ç”¨è‡ªå®šä¹‰å­—æ®µï¼ˆå¦‚ prompt, chosen, rejectedï¼‰ã€‚\nuse_mps_device&#x3D;device &#x3D;&#x3D; â€œmpsâ€ï¼šå¦‚æœåœ¨ Mac ä¸Šä½¿ç”¨ MPS åŠ é€Ÿåˆ™è®¾ä¸º Trueã€‚\nhub_model_id&#x3D;finetune_nameï¼šè®­ç»ƒå®Œæˆåæ¨¡å‹ä¸Šä¼ åˆ° Hugging Face Hub çš„ ID åï¼ˆå¦‚ â€œmy-org&#x2F;my-dpo-modelâ€ï¼‰ã€‚\nbeta&#x3D;0.1\tDPO ç‰¹æœ‰å‚æ•°ï¼šæ§åˆ¶ DPO loss ä¸­ policy ä¸ reference çš„å¯¹æ¯”å¼ºåº¦ã€‚è¶Šå°ï¼ˆå¦‚ 0.1ï¼‰ï¼Œåå¥½æ§åˆ¶è¶Šä¸¥æ ¼ï¼ˆä¿å®ˆï¼‰ï¼›è¶Šå¤§ï¼ˆå¦‚ 1.0ï¼‰ï¼Œæ›´è‡ªç”±ã€‚\nmax_prompt_length&#x3D;1024ï¼šè¾“å…¥çš„ prompt æœ€å¤§é•¿åº¦ï¼ˆtoken æ•°ï¼‰ã€‚è¶…è¿‡åˆ™æˆªæ–­ã€‚\nmax_length&#x3D;1536ï¼šprompt + å›å¤ï¼ˆchosen&#x2F;rejectedï¼‰æ‹¼æ¥åçš„æœ€å¤§æ€»é•¿åº¦ã€‚\n\nDPOTrainer å‚æ•°ï¼š\ntrainer = DPOTrainer(    # The model to be trained    model=model,    # Training configuration from above    args=training_args,    # Dataset containing preferred/rejected response pairs    train_dataset=dataset,    # Tokenizer for processing inputs    processing_class=tokenizer,    # DPO-specific temperature parameter that controls the strength of the preference model    # Lower values (like 0.1) make the model more conservative in following preferences    # beta=0.1,    # Maximum length of the input prompt in tokens    # max_prompt_length=1024,    # Maximum combined length of prompt + response in tokens    # max_length=1536,)\n\nref_modelï¼šå¦‚æœæ²¡æœ‰å‚è€ƒæ¨¡å‹ï¼Œåˆ™é»˜è®¤å’Œ model ç›¸åŒ\nargsï¼šå°† DPOConfig ä¼ å…¥\ntrain_datasetï¼šè®­ç»ƒé›†ã€‚å¿…é¡»åŒ…å« prompt, chosen, rejected ä¸‰åˆ—\nbetaï¼šæ§åˆ¶ loss ä¸­ Ï€(chosen)&#x2F;Ï€(rejected) çš„æ•æ„Ÿç¨‹åº¦ã€‚\nbeta &#x3D; 0.1ï¼šè¶‹äºä¿å®ˆï¼ˆæ›´ç›¸ä¿¡å‚è€ƒæ¨¡å‹ï¼‰\nbeta &#x3D; 1.0ï¼šæ›´è‡ªç”±ï¼ˆè®­ç»ƒæ¨¡å‹å¯åç¦»å‚è€ƒï¼‰\n\n\n\nORPOORPO ï¼ˆOdds Ratio Preference Optimizationï¼‰æ˜¯ä¸€ç§æ–°é¢–çš„å¾®è°ƒæŠ€æœ¯ï¼Œå®ƒå°†å¾®è°ƒå’Œåå¥½å¯¹é½ç»“åˆåˆ°ä¸€ä¸ªç»Ÿä¸€çš„è¿‡ç¨‹ä¸­ã€‚ä¸ RLHF æˆ– DPO ç­‰ä¼ ç»Ÿæ–¹æ³•ç›¸æ¯”ï¼Œè¿™ç§ç»„åˆæ–¹æ³•åœ¨æ•ˆç‡å’Œæ€§èƒ½æ–¹é¢å…·æœ‰ä¼˜åŠ¿ã€‚\nä¸ DPO ç­‰æ–¹æ³•çš„å¯¹é½é€šå¸¸æ¶‰åŠä¸¤ä¸ªå•ç‹¬çš„æ­¥éª¤ï¼šç›‘ç£å¾®è°ƒä»¥ä½¿æ¨¡å‹é€‚åº”é¢†åŸŸå’Œæ ¼å¼ï¼Œç„¶åè¿›è¡Œåå¥½å¯¹é½ä»¥ä¸äººç±»åå¥½ä¿æŒä¸€è‡´ã€‚è™½ç„¶ SFT æœ‰æ•ˆåœ°ä½¿æ¨¡å‹é€‚åº”ç›®æ ‡åŸŸï¼Œä½†å®ƒå¯èƒ½æ— æ„ä¸­å¢åŠ äº§ç”ŸæœŸæœ›å’Œä¸æœŸæœ›å“åº”çš„æ¦‚ç‡ã€‚ORPO é€šè¿‡å°†è¿™ä¸¤ä¸ªæ­¥éª¤é›†æˆåˆ°ä¸€ä¸ªæµç¨‹ä¸­æ¥è§£å†³è¿™ä¸€é™åˆ¶ã€‚å¯¹æ¯”å¦‚ä¸‹ï¼š\n\nå¦‚ä½•å·¥ä½œè®­ç»ƒè¿‡ç¨‹åˆ©ç”¨äº†ä¸€ä¸ªç±»ä¼¼äºåœ¨ DPO ä¸­ä½¿ç”¨çš„åå¥½æ•°æ®é›†ï¼Œå…¶ä¸­æ¯ä¸ªè®­ç»ƒç¤ºä¾‹åŒ…å«ä¸€ä¸ªè¾“å…¥æç¤ºä»¥åŠä¸¤ä¸ªå“åº”ï¼šä¸€ä¸ªæ˜¯é¦–é€‰çš„ï¼Œå¦ä¸€ä¸ªæ˜¯æ‹’ç»çš„ã€‚ä¸å…¶ä»–éœ€è¦å•ç‹¬é˜¶æ®µå’Œå‚è€ƒæ¨¡å‹çš„æ ¡å‡†æ–¹æ³•ä¸åŒï¼ŒORPO å°†åå¥½æ ¡å‡†ç›´æ¥é›†æˆåˆ°ç›‘ç£å¾®è°ƒè¿‡ç¨‹ä¸­ã€‚è¿™ç§å•ç‰‡æ–¹æ³•ä½¿å…¶æ— éœ€å‚è€ƒæ¨¡å‹ï¼Œè®¡ç®—æ•ˆç‡æ›´é«˜ï¼Œå¹¶ä¸”ä½¿ç”¨æ›´å°‘çš„ flop æ¥æé«˜å†…å­˜æ•ˆç‡ã€‚\nORPO é€šè¿‡ç»“åˆä¸¤ä¸ªä¸»è¦ç»„ä»¶åˆ›å»ºäº†ä¸€ä¸ªæ–°ç›®æ ‡ï¼š\n\nSFT æŸå¤±ï¼šè¯­è¨€å»ºæ¨¡ä¸­ä½¿ç”¨çš„æ ‡å‡†è´Ÿå¯¹æ•°ä¼¼ç„¶æŸå¤±ï¼Œå®ƒæœ€å¤§é™åº¦åœ°æé«˜äº†ç”Ÿæˆå‚è€ƒä»¤ç‰Œçš„æ¦‚ç‡ã€‚è¿™æœ‰åŠ©äºç»´æŠ¤æ¨¡å‹çš„é€šç”¨è¯­è¨€åŠŸèƒ½ã€‚\nodd rate æŸå¤±ï¼šä¸€ä¸ªæ–°çš„ç»„ä»¶ï¼Œæƒ©ç½šä¸å¸Œæœ›çš„ååº”ï¼Œè€Œå¥–åŠ±é¦–é€‰çš„ã€‚è¿™ä¸ªæŸå¤±å‡½æ•°ä½¿ç”¨æ¯”å€¼æ¯”åœ¨ä»¤ç‰Œçº§åˆ«ä¸Šæœ‰æ•ˆåœ°å¯¹æ¯”å—æ¬¢è¿å’Œä¸å—æ¬¢è¿çš„å“åº”ã€‚\n\n","categories":["LLM"],"tags":["trl","smol"]},{"title":"ã€Kaggle Coursesã€‘2-python","url":"/blog/Kaggle-course/python-kaggle/","content":"coming soonâ€¦\n","tags":["Kaggle","Python"]},{"title":"ã€Smol Courseã€‘4-è¯„ä¼°","url":"/blog/LLM/smol4/","content":"Evaluationå…¨é¢çš„è¯„ä¼°ç­–ç•¥æ£€æŸ¥æ¨¡å‹æ€§èƒ½çš„å¤šä¸ªæ–¹é¢ã€‚æˆ‘ä»¬è¯„ä¼°ç‰¹å®šäºä»»åŠ¡çš„åŠŸèƒ½ï¼Œå¦‚é—®é¢˜å›ç­”å’Œæ€»ç»“ï¼Œä»¥äº†è§£æ¨¡å‹å¦‚ä½•å¤„ç†ä¸åŒç±»å‹çš„é—®é¢˜ã€‚æˆ‘ä»¬é€šè¿‡è¿è´¯æ€§å’Œäº‹å®å‡†ç¡®æ€§ç­‰å› ç´ æ¥è¡¡é‡è¾“å‡ºè´¨é‡ã€‚å®‰å…¨è¯„ä¼°æœ‰åŠ©äºè¯†åˆ«æ½œåœ¨çš„æœ‰å®³è¾“å‡ºæˆ–åè§ã€‚æœ€åï¼Œé¢†åŸŸä¸“ä¸šçŸ¥è¯†æµ‹è¯•éªŒè¯æ¨¡å‹åœ¨ç›®æ ‡é¢†åŸŸä¸­çš„ä¸“ä¸šçŸ¥è¯†ã€‚\n\nAutomatic Benchmarksï¼šå­¦ä¹ ä½¿ç”¨æ ‡å‡†åŒ–çš„åŸºå‡†å’ŒæŒ‡æ ‡æ¥è¯„ä¼°ä½ çš„æ¨¡å‹ã€‚æˆ‘ä»¬å°†æ¢ç´¢å¸¸è§çš„åŸºå‡†ï¼Œå¦‚MMLUå’ŒTruthfulQAï¼Œäº†è§£å…³é”®çš„è¯„ä¼°æŒ‡æ ‡å’Œè®¾ç½®ï¼Œå¹¶ä»‹ç»å¯é‡å¤è¯„ä¼°çš„æœ€ä½³å®è·µã€‚\nCustom Domain Evaluationï¼šäº†è§£å¦‚ä½•åˆ›å»ºé€‚åˆæ‚¨ç‰¹å®šç”¨ä¾‹çš„è¯„ä¼°ç®¡é“ã€‚æˆ‘ä»¬å°†é€æ­¥å®Œæˆè®¾è®¡è‡ªå®šä¹‰è¯„ä¼°ä»»åŠ¡ï¼Œå®ç°ä¸“é—¨çš„åº¦é‡ï¼Œå¹¶æ„å»ºç¬¦åˆæ‚¨éœ€æ±‚çš„è¯„ä¼°æ•°æ®é›†ã€‚\nDomain Evaluation Projectï¼šæ„å»ºç‰¹å®šäºé¢†åŸŸçš„è¯„ä¼°ç®¡é“çš„å®Œæ•´ç¤ºä¾‹ã€‚æ‚¨å°†å­¦ä¹ å¦‚ä½•ç”Ÿæˆè¯„ä¼°æ•°æ®é›†ã€ä½¿ç”¨ Argilla è¿›è¡Œæ•°æ®æ³¨é‡Šã€åˆ›å»ºæ ‡å‡†åŒ–æ•°æ®é›†ä»¥åŠä½¿ç”¨ LightEval è¯„ä¼°æ¨¡å‹ã€‚\n\nAutomatic Benchmarksè‡ªåŠ¨åŸºå‡†æµ‹è¯•é€šå¸¸ç”±å¸¦æœ‰é¢„å®šä¹‰ä»»åŠ¡å’Œè¯„ä¼°æŒ‡æ ‡çš„ç²¾å¿ƒç­–åˆ’çš„æ•°æ®é›†ç»„æˆã€‚è¿™äº›åŸºå‡†æ—¨åœ¨è¯„ä¼°æ¨¡å‹èƒ½åŠ›çš„å„ä¸ªæ–¹é¢ï¼Œä»åŸºæœ¬çš„è¯­è¨€ç†è§£åˆ°å¤æ‚çš„æ¨ç†ã€‚ä½¿ç”¨è‡ªåŠ¨åŸºå‡†æµ‹è¯•çš„å…³é”®ä¼˜åŠ¿åœ¨äºå®ƒä»¬çš„æ ‡å‡†åŒ–â€”â€”å®ƒä»¬å…è®¸è·¨ä¸åŒæ¨¡å‹è¿›è¡Œä¸€è‡´çš„æ¯”è¾ƒï¼Œå¹¶æä¾›å¯é‡å¤çš„ç»“æœã€‚\nUsing LightEval for BenchmarkingLightEval ä»»åŠ¡ç”¨ä¸€ç§ç‰¹å®šçš„æ ¼å¼å®šä¹‰ï¼š\n&#123;suite&#125;|&#123;task&#125;|&#123;num_few_shot&#125;|&#123;auto_reduce&#125;\n\nsuite: The benchmark suite (e.g., â€˜mmluâ€™, â€˜truthfulqaâ€™)\ntask: Specific task within the suite (e.g., â€˜abstract_algebraâ€™)\nnum_few_shot: Number of examples to include in prompt (0 for zero-shot)\nauto_reduce: Whether to automatically reduce few-shot examples if prompt is too long (0 or 1)\n\nExample\nå®šä¹‰è¯„ä¼°ä»»åŠ¡ï¼ˆMMLU å­ä»»åŠ¡ï¼‰\nè®¾ç½® pipeline å‚æ•°\nåˆ›å»ºè¯„ä¼°è¿½è¸ªå™¨\nåŠ è½½æ¨¡å‹ + æ„å»º pipeline\n\nPipeline æ˜¯ LightEval çš„æ ¸å¿ƒç»„ä»¶ï¼Œè´Ÿè´£ï¼š\n\nå°†ä»»åŠ¡ã€æ¨¡å‹ã€è¯„ä¼°è®°å½•å™¨ç»Ÿä¸€èµ·æ¥\nè‡ªåŠ¨åŠ è½½æ•°æ®é›†ã€æ‰§è¡Œæ¨ç†ã€è®°å½•ç»“æœ\n\nfrom lighteval.tasks import Task, Pipelinefrom transformers import AutoModelForCausalLM# Define tasks to evaluatedomain_tasks = [    &quot;mmlu|anatomy|0|0&quot;,    &quot;mmlu|high_school_biology|0|0&quot;,     &quot;mmlu|high_school_chemistry|0|0&quot;,    &quot;mmlu|professional_medicine|0|0&quot;]# Configure pipeline parameterspipeline_params = &#123;    &quot;max_samples&quot;: 40,  # Number of samples to evaluate æ¯ä¸ªä»»åŠ¡æœ€å¤šè¯„ä¼° 40 æ¡æ ·æœ¬    &quot;batch_size&quot;: 1,    # Batch size for inference æ¨ç†æ‰¹æ¬¡å¤§å°ä¸º 1ï¼ˆèŠ‚çœæ˜¾å­˜ï¼‰    &quot;num_workers&quot;: 4    # Number of worker processes å¤šè¿›ç¨‹åŠ è½½æ•°æ®æˆ–å¤„ç†ä»»åŠ¡&#125;# Create evaluation tracker# åˆ›å»ºè¯„ä¼°è¿½è¸ªå™¨ï¼Œä¿å­˜æ¨ç†è¿‡ç¨‹ä¸­çš„ç­”æ¡ˆï¼ˆgenerationsï¼‰evaluation_tracker = EvaluationTracker(    output_path=&quot;./results&quot;,    save_generations=True)# Load model and create pipelinemodel = AutoModelForCausalLM.from_pretrained(&quot;your-model-name&quot;)pipeline = Pipeline(    tasks=domain_tasks,    pipeline_parameters=pipeline_params,    evaluation_tracker=evaluation_tracker,    model=model)# Run evaluationpipeline.evaluate()# Get and display resultsresults = pipeline.get_results()pipeline.show_results()\n\nCustom Domain Evaluationè™½ç„¶æ ‡å‡†åŸºå‡†æä¾›äº†æœ‰ä»·å€¼çš„è§è§£ï¼Œä½†è®¸å¤šåº”ç”¨ç¨‹åºéœ€è¦é’ˆå¯¹ç‰¹å®šé¢†åŸŸæˆ–ç”¨ä¾‹å®šåˆ¶çš„ä¸“é—¨è¯„ä¼°æ–¹æ³•ã€‚æœ¬æŒ‡å—å°†å¸®åŠ©æ‚¨åˆ›å»ºè‡ªå®šä¹‰è¯„ä¼°ç®¡é“ï¼Œä»¥å‡†ç¡®åœ°è¯„ä¼°æ‚¨çš„æ¨¡å‹åœ¨ç›®æ ‡é¢†åŸŸä¸­çš„æ€§èƒ½ã€‚\nImplementation with LightEvalLightEval ä¸ºå®ç°è‡ªå®šä¹‰è¯„ä¼°æä¾›äº†ä¸€ä¸ªçµæ´»çš„æ¡†æ¶ã€‚ä¸‹é¢æ˜¯å¦‚ä½•åˆ›å»ºè‡ªå®šä¹‰ä»»åŠ¡ï¼š\nfrom lighteval.tasks import Task, Docfrom lighteval.metrics import SampleLevelMetric, MetricCategory, MetricUseCaseclass CustomEvalTask(Task):    def __init__(self):        super().__init__(            name=&quot;custom_task&quot;,            version=&quot;0.0.1&quot;,            metrics=[&quot;accuracy&quot;, &quot;f1&quot;],  # Your chosen metrics            description=&quot;Description of your custom evaluation task&quot;        )        def get_prompt(self, sample):        # Format your input into a prompt        return f&quot;Question: &#123;sample[&#x27;question&#x27;]&#125;\\nAnswer:&quot;        def process_response(self, response, ref):        # Process model output and compare to reference        return response.strip() == ref.strip()\n\n\nTask: LightEval ä¸­è¯„ä¼°ä»»åŠ¡çš„åŸºç±»ã€‚æ‰€æœ‰è¯„ä¼°ä»»åŠ¡éƒ½å¿…é¡»ç»§æ‰¿è‡ªå®ƒã€‚\nDoc: ï¼ˆè™½ç„¶æœªä½¿ç”¨ï¼‰é€šå¸¸è¡¨ç¤ºè¯„ä¼°ä¸­çš„ä¸€ä¸ªæ ·æœ¬ç»“æ„ã€‚\nprompt æ„é€ é€»è¾‘ï¼šæ–¹æ³•æ¥æ”¶ä¸€ä¸ªæ ·æœ¬ï¼ˆå­—å…¸ sampleï¼‰ï¼Œä»ä¸­æå–å­—æ®µï¼ˆå¦‚ â€œquestionâ€ï¼‰æ¥æ„å»º promptã€‚\næ¨¡å‹è¾“å‡ºçš„å¤„ç†å’Œæ¯”è¾ƒæ–¹æ³•ï¼š\nresponse: æ¨¡å‹ç”Ÿæˆçš„å›ç­”ï¼ˆå­—ç¬¦ä¸²ï¼‰\nref: æ ‡å‡†ç­”æ¡ˆï¼ˆreferenceï¼‰\nè¿”å› True&#x2F;False è¡¨ç¤ºè¯¥æ ·æœ¬æ˜¯å¦æ­£ç¡®\n\n\n\nCustom Metricsç‰¹å®šäºé¢†åŸŸçš„ä»»åŠ¡é€šå¸¸éœ€è¦ä¸“é—¨çš„åº¦é‡æ ‡å‡†ã€‚LightEval æä¾›äº†ä¸€ä¸ªçµæ´»çš„æ¡†æ¶ï¼Œç”¨äºåˆ›å»ºæ•è·é¢†åŸŸç›¸å…³æ€§èƒ½æ–¹é¢çš„è‡ªå®šä¹‰æŒ‡æ ‡ï¼š\nfrom aenum import extend_enumfrom lighteval.metrics import Metrics, SampleLevelMetric, SampleLevelMetricGroupingimport numpy as np# Define a sample-level metric functiondef custom_metric(predictions: list[str], formatted_doc: Doc, **kwargs) -&gt; dict:    &quot;&quot;&quot;Example metric that returns multiple scores per sample&quot;&quot;&quot;    response = predictions[0]    return &#123;        &quot;accuracy&quot;: response == formatted_doc.choices[formatted_doc.gold_index],        &quot;length_match&quot;: len(response) == len(formatted_doc.reference)    &#125;# Create a metric that returns multiple values per samplecustom_metric_group = SampleLevelMetricGrouping(    metric_name=[&quot;accuracy&quot;, &quot;length_match&quot;],  # Names of sub-metrics    higher_is_better=&#123;  # Whether higher values are better for each metric        &quot;accuracy&quot;: True,        &quot;length_match&quot;: True    &#125;,    category=MetricCategory.CUSTOM,    use_case=MetricUseCase.SCORING,    sample_level_fn=custom_metric,    corpus_level_fn=&#123;  # How to aggregate each metric        &quot;accuracy&quot;: np.mean,        &quot;length_match&quot;: np.mean    &#125;)# Register the metric with LightEvalextend_enum(Metrics, &quot;custom_metric_name&quot;, custom_metric_group)\n\n\nè‡ªå®šä¹‰è¯„ä¼°å‡½æ•° custom_metricï¼Œè¿™ä¸ªå‡½æ•°å¯¹æ¯ä¸€ä¸ªæ ·æœ¬è¿”å›å¤šä¸ªè¯„ä»·æŒ‡æ ‡\npredictions: æ¨¡å‹çš„è¾“å‡ºåˆ—è¡¨ï¼ˆé€šå¸¸åªæœ‰ä¸€ä¸ªé¢„æµ‹å€¼ï¼‰\nformatted_doc: Doc å¯¹è±¡ï¼ŒåŒ…å«æ ‡å‡†å‚è€ƒä¿¡æ¯\nè¿”å›å€¼æ˜¯ä¸€ä¸ªå­—å…¸ï¼ŒåŒ…å«å¤šä¸ªæŒ‡æ ‡ï¼ˆä¾‹å¦‚ accuracy å’Œ length_matchï¼‰\n\n\nå°†è¯¥å‡½æ•°åŒ…è£…ä¸º SampleLevelMetricGrouping\nmetric_name: åŒ…å«è¯¥åˆ†ç»„ä¸‹çš„æ‰€æœ‰å­æŒ‡æ ‡å\nhigher_is_better: å®šä¹‰æ¯ä¸ªæŒ‡æ ‡çš„â€œæœ€ä¼˜æ–¹å‘â€\nsample_level_fn: æ ·æœ¬çº§è¯„ä¼°å‡½æ•°\ncorpus_level_fn: æ€»ä½“è¯„ä¼°å¦‚ä½•èšåˆï¼ˆè¿™é‡Œä½¿ç”¨ np.meanï¼‰\n\n\næ³¨å†Œè‡ªå®šä¹‰æŒ‡æ ‡åˆ° LightEval å†…éƒ¨æšä¸¾ç³»ç»Ÿä¸­\nç»™ Metrics æ³¨å†Œäº†æ–°çš„æšä¸¾é¡¹ â€œcustom_metric_nameâ€ï¼Œå®ƒå°†ä¸ä»»åŠ¡ç»‘å®šã€‚\n\n\n\nåªæœ‰å•ä¸ªæŒ‡æ ‡çš„æƒ…å†µï¼š\ndef simple_metric(predictions: list[str], formatted_doc: Doc, **kwargs) -&gt; bool:    &quot;&quot;&quot;Example metric that returns a single score per sample&quot;&quot;&quot;    response = predictions[0]    return response == formatted_doc.choices[formatted_doc.gold_index]simple_metric_obj = SampleLevelMetric(    metric_name=&quot;simple_accuracy&quot;,    higher_is_better=True,    category=MetricCategory.CUSTOM,    use_case=MetricUseCase.SCORING,    sample_level_fn=simple_metric,    corpus_level_fn=np.mean  # How to aggregate across samples)extend_enum(Metrics, &quot;simple_metric&quot;, simple_metric_obj)\n\nç„¶åï¼Œå¯ä»¥é€šè¿‡åœ¨ä»»åŠ¡é…ç½®ä¸­å¼•ç”¨è‡ªå®šä¹‰æŒ‡æ ‡æ¥åœ¨è¯„ä¼°ä»»åŠ¡ä¸­ä½¿ç”¨å®ƒä»¬ã€‚åº¦é‡å°†åœ¨æ‰€æœ‰æ ·æœ¬ä¸­è‡ªåŠ¨è®¡ç®—ï¼Œå¹¶æ ¹æ®æ‚¨æŒ‡å®šçš„åŠŸèƒ½è¿›è¡Œæ±‡æ€»ã€‚\n","categories":["LLM"],"tags":["trl","smol"]},{"title":"ã€Smol Courseã€‘5-è§†è§‰è¯­è¨€æ¨¡å‹","url":"/blog/LLM/smol5/","content":"VLM Usageè§†è§‰è¯­è¨€æ¨¡å‹ï¼ˆvlmï¼‰å¼¥åˆäº†å›¾åƒå’Œæ–‡æœ¬ä¹‹é—´çš„å·®è·ï¼Œå®ç°äº†é«˜çº§ä»»åŠ¡ï¼Œå¦‚ç”Ÿæˆå›¾åƒå­—å¹•ï¼ŒåŸºäºè§†è§‰å›ç­”é—®é¢˜ï¼Œæˆ–ç†è§£æ–‡æœ¬å’Œè§†è§‰æ•°æ®ä¹‹é—´çš„å…³ç³»ã€‚å®ƒä»¬çš„æ¶æ„æ—¨åœ¨æ— ç¼åœ°å¤„ç†è¿™ä¸¤ç§æ¨¡å¼ã€‚\nChat Formatè®¸å¤š vlm çš„ç»“æ„ä»¥ç±»ä¼¼èŠå¤©æœºå™¨äººçš„æ–¹å¼è¿›è¡Œäº¤äº’ï¼Œä»è€Œå¢å¼ºäº†å¯ç”¨æ€§ã€‚è¯¥æ ¼å¼åŒ…æ‹¬ï¼š\n\nä¸ºæ¨¡å‹è®¾ç½®è§’è‰²æˆ–ä¸Šä¸‹æ–‡çš„ç³»ç»Ÿæ¶ˆæ¯ï¼Œä¾‹å¦‚â€œæ‚¨æ˜¯åˆ†æå¯è§†åŒ–æ•°æ®çš„åŠ©æ‰‹â€ã€‚\nç»“åˆæ–‡æœ¬è¾“å…¥å’Œç›¸å…³å›¾åƒçš„ç”¨æˆ·æŸ¥è¯¢ã€‚\nè¾…åŠ©å“åº”æä¾›æ¥è‡ªå¤šæ¨¡æ€åˆ†æçš„æ–‡æœ¬è¾“å‡ºã€‚\n\nè¿™ç§ä¼šè¯ç»“æ„æ˜¯ç›´è§‚çš„ï¼Œç¬¦åˆç”¨æˆ·çš„æœŸæœ›ï¼Œç‰¹åˆ«æ˜¯å¯¹äºäº¤äº’å¼åº”ç”¨ç¨‹åºï¼Œå¦‚å®¢æˆ·æœåŠ¡æˆ–æ•™è‚²å·¥å…·ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªæ ¼å¼åŒ–è¾“å…¥çš„ç¤ºä¾‹\n[    &#123;        &quot;role&quot;: &quot;system&quot;,        &quot;content&quot;: [&#123;&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: &quot;You are a Vision Language Model specialized in interpreting visual data from chart images...&quot;&#125;]    &#125;,    &#123;        &quot;role&quot;: &quot;user&quot;,        &quot;content&quot;: [            &#123;&quot;type&quot;: &quot;image&quot;, &quot;image&quot;: &quot;&lt;image_data&gt;&quot;&#125;,            &#123;&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: &quot;What is the highest value in the bar chart?&quot;&#125;        ]    &#125;,    &#123;        &quot;role&quot;: &quot;assistant&quot;,        &quot;content&quot;: [&#123;&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: &quot;42&quot;&#125;]    &#125;]\n\nvlm è¿˜å¯ä»¥é€šè¿‡è°ƒæ•´è¾“å…¥ç»“æ„æ¥é€‚åº”é¡ºåºæˆ–å¹¶è¡Œè§†è§‰è¾“å…¥ï¼Œä»è€Œå¤„ç†å¤šä¸ªå›¾åƒç”šè‡³è§†é¢‘ã€‚å¯¹äºè§†é¢‘ï¼Œå¸§å¯ä»¥ä½œä¸ºå•ç‹¬çš„å›¾åƒè¿›è¡Œæå–å’Œå¤„ç†ï¼ŒåŒæ—¶ä¿æŒæ—¶é—´é¡ºåºã€‚\nPracticeåŠ è½½æ¨¡å‹\nimport torch, PILfrom transformers import AutoProcessor, AutoModelForVision2Seq, BitsAndBytesConfigfrom transformers.image_utils import load_imagedevice = (    &quot;cuda&quot;    if torch.cuda.is_available()    else &quot;mps&quot; if torch.backends.mps.is_available() else &quot;cpu&quot;)model_name = &quot;HuggingFaceTB/SmolVLM-Instruct&quot;model = AutoModelForVision2Seq.from_pretrained(    model_name,    cache_dir=&quot;D:\\study\\smol-course\\data\\SmolVLM-Instruct&quot;).to(device)processor = AutoProcessor.from_pretrained(&quot;HuggingFaceTB/SmolVLM-Instruct&quot;, cache_dir=&quot;D:\\study\\smol-course\\data\\SmolVLM-Instruct&quot;)print(processor.image_processor.size)\n\nAutoProcessor.from_pretrained è‡ªåŠ¨åŠ è½½è¯¥æ¨¡å‹æ‰€éœ€çš„å›¾åƒé¢„å¤„ç†å™¨å’Œæ–‡æœ¬åˆ†è¯å™¨ï¼Œå°è£…ä¸ºä¸€ä¸ª processor å¯¹è±¡ï¼Œåç»­å¯ç›´æ¥ç”¨å®ƒå°†è¾“å…¥å›¾åƒ + é—®é¢˜å¤„ç†æˆæ¨¡å‹æ‰€éœ€çš„æ ¼å¼ã€‚\nå¤„ç†å•å¼ å›¾åƒ# Load  one imageimage1 = load_image(image_url1)# Create input messagesmessages = [    &#123;        &quot;role&quot;: &quot;user&quot;,        &quot;content&quot;: [            &#123;&quot;type&quot;: &quot;image&quot;&#125;,            &#123;&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: &quot;Can you describe the image?&quot;&#125;        ]    &#125;,]# Prepare inputsprompt = processor.apply_chat_template(messages, add_generation_prompt=True)inputs = processor(text=prompt, images=[image1], return_tensors=&quot;pt&quot;)inputs = inputs.to(device)# Generate outputsgenerated_ids = model.generate(**inputs, max_new_tokens=500)generated_texts = processor.batch_decode(    generated_ids,    skip_special_tokens=True,)print(generated_texts)\n\næ³¨æ„ï¼š\n\nå›¾åƒæ•°æ® å¹¶ä¸æ˜¯æ”¾åœ¨ messages é‡Œï¼Œè€Œæ˜¯é€šè¿‡ processor(â€¦, images&#x3D;[image1]) ä¼ è¿›å»çš„ï¼Œmessages åªæ˜¯ å‘Šè¯‰æ¨¡å‹â€œè¿™é‡Œåº”è¯¥æœ‰ä¸€å¼ å›¾â€ï¼Œå®é™…çš„å›¾åƒå¼ é‡ï¼ˆtokenï¼‰ç”± processor è‡ªåŠ¨æ’å…¥å¹¶å¯¹é½ã€‚\nprocessor.apply_chat_template æœ¬è´¨ä¸Šæ˜¯å°† messages è½¬æ¢ä¸ºï¼š&lt;|user|&gt; \\&lt;image&gt; Can you describe the image? &lt;|assistant|&gt;\n&lt;image&gt; æ˜¯ä¸€ä¸ª ç‰¹æ®Š token å ä½ç¬¦ï¼Œä¸æ˜¯å›¾åƒæ•°æ®ï¼Œè€Œæ˜¯å‘Šè¯‰æ¨¡å‹â€œè¿™é‡Œä¼šæ’å…¥å›¾åƒçš„è§†è§‰ tokenâ€\næ¥ä¸‹æ¥åœ¨ processor(text&#x3D;prompt, images&#x3D;[image1], return_tensors&#x3D;â€ptâ€) ä¸­ï¼š\nimages&#x3D;[image1]ï¼šçœŸæ­£ä¼ å…¥å›¾åƒæ•°æ®çš„ä½ç½®\nprocessor ä¼šè‡ªåŠ¨å°† image1ï¼š\nresizeã€normalize\nè½¬ä¸º tensor\nå¹¶å¯¹é½åˆ° prompt ä¸­çš„ &lt;image&gt; token ä½ç½®\n\n\n\n\n\n\n\nå¤„ç†å¤šå¼ å›¾åƒå°† message æ›´æ”¹ä¸ºï¼š\nmessages = [    &#123;        &quot;role&quot;: &quot;user&quot;,        &quot;content&quot;: [            &#123;&quot;type&quot;: &quot;image&quot;&#125;,            &#123;&quot;type&quot;: &quot;image&quot;&#125;,            &#123;&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: &quot;What event do they both represent?&quot;&#125;        ]    &#125;,]\næ·»åŠ äº†ä¸€ä¸ª iamge å ä½ç¬¦ï¼Œç›¸åº”çš„ï¼Œåœ¨è°ƒç”¨ processor æ—¶ï¼Œä¹Ÿè¦ä¼ å…¥ä¸¤ä¸ª image å¯¹è±¡ï¼š\nprompt = processor.apply_chat_template(messages, add_generation_prompt=True)inputs = processor(text=prompt, images=[image1, image2], return_tensors=&quot;pt&quot;)inputs = inputs.to(device)\n\nå¤„ç†è§†é¢‘æŠ½å–è§†é¢‘å…³é”®å¸§ï¼Œå°†å…¶ä½œä¸ºå¤šå¼ å›¾åƒæ¥ä¼ é€’ç»™æ¨¡å‹ã€‚é¦–å…ˆå®šä¹‰æŠ½å¸§å’Œç¼©æ”¾å‡½æ•°ï¼š\nfrom IPython.display import Videoimport cv2import numpy as npdef extract_frames(video_path, max_frames=50, target_size=None):    cap = cv2.VideoCapture(video_path)    if not cap.isOpened():        raise ValueError(f&quot;Could not open video: &#123;video_path&#125;&quot;)        total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))    frame_indices = np.linspace(0, total_frames - 1, max_frames, dtype=int)    frames = []    for idx in frame_indices:        cap.set(cv2.CAP_PROP_POS_FRAMES, idx)        ret, frame = cap.read()        if ret:            frame = PIL.Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))            if target_size:                frames.append(resize_and_crop(frame, target_size))            else:                frames.append(frame)    cap.release()    return framesdef resize_and_crop(image, target_size):    width, height = image.size    scale = target_size / min(width, height)    image = image.resize((int(width * scale), int(height * scale)), PIL.Image.Resampling.LANCZOS)    left = (image.width - target_size) // 2    top = (image.height - target_size) // 2    return image.crop((left, top, left + target_size, top + target_size))\n\nextract_frames å°†è§†é¢‘æŠ½å¸§åï¼Œä½¿ç”¨ opencv æ¥è¿›è¡Œè¯»å–ï¼Œå¹¶ä¸”è½¬æ¢ä¸º numpy æ•°ç»„ã€‚ \nresize_and_crop æ ¹æ®éœ€è¦å°†è§†é¢‘å¸§è¿›è¡Œè£å‰ª\n\næ¥ä¸‹æ¥å®šä¹‰äº†ä¸€ä¸ª generate_response å‡½æ•°ï¼Œç”¨äºç”Ÿæˆå›ç­”ã€‚\ndef generate_response(model, processor, frames, question):    image_tokens = [&#123;&quot;type&quot;: &quot;image&quot;&#125; for _ in frames]    messages = [        &#123;            &quot;role&quot;: &quot;user&quot;,            &quot;content&quot;: [                &#123;                    &quot;type&quot;: &quot;text&quot;,                     &quot;text&quot;: &quot;Following are the frames of a video in temporal order.&quot;                &#125;,                     *image_tokens,                 &#123;                    &quot;type&quot;: &quot;text&quot;,                    &quot;text&quot;: question                &#125;            ]        &#125;    ]    inputs = processor(        text=processor.apply_chat_template(messages, add_generation_prompt=True),        images=frames,        return_tensors=&quot;pt&quot;    ).to(model.device)    outputs = model.generate(        **inputs, max_new_tokens=100, num_beams=5, temperature=0.7, do_sample=True, use_cache=True    )    return processor.decode(outputs[0], skip_special_tokens=True)\n\næ³¨æ„ï¼š \n\nmessage é‡Œé¢çš„ image_tokensï¼Œé‡å¤äº† len(frames) æ¬¡ï¼Œå³å°†è§†é¢‘å¸§ä½œä¸ºå¤šå¼ å›¾åƒä¼ å…¥ã€‚\ngenerate çš„å‚æ•°ï¼š\n\nQwenVL å¤„ç†è§†é¢‘Qwen æ”¯æŒå¤šç§æ–¹æ³•ä¼ å…¥è§†é¢‘ï¼š\n# Messages containing a images list as a video and a text querymessages = [    &#123;        &quot;role&quot;: &quot;user&quot;,        &quot;content&quot;: [            &#123;                &quot;type&quot;: &quot;video&quot;,                &quot;video&quot;: [                    &quot;file:///path/to/frame1.jpg&quot;,                    &quot;file:///path/to/frame2.jpg&quot;,                    &quot;file:///path/to/frame3.jpg&quot;,                    &quot;file:///path/to/frame4.jpg&quot;,                ],            &#125;,            &#123;&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: &quot;Describe this video.&quot;&#125;,        ],    &#125;]# Messages containing a local video path and a text querymessages = [    &#123;        &quot;role&quot;: &quot;user&quot;,        &quot;content&quot;: [            &#123;                &quot;type&quot;: &quot;video&quot;,                &quot;video&quot;: &quot;file:///path/to/video1.mp4&quot;,                &quot;max_pixels&quot;: 360 * 420,                &quot;fps&quot;: 1.0,            &#125;,            &#123;&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: &quot;Describe this video.&quot;&#125;,        ],    &#125;]# Messages containing a video url and a text querymessages = [    &#123;        &quot;role&quot;: &quot;user&quot;,        &quot;content&quot;: [            &#123;                &quot;type&quot;: &quot;video&quot;,                &quot;video&quot;: &quot;https://qianwen-res.oss-cn-beijing.aliyuncs.com/Qwen2-VL/space_woaudio.mp4&quot;,            &#125;,            &#123;&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: &quot;Describe this video.&quot;&#125;,        ],    &#125;]\n\næ ¸å¿ƒå¤„ç†æ–¹æ³•ä¸º process_vision_infoï¼š\n\nä¸‹è½½&#x2F;è¯»å–æœ¬åœ°è§†é¢‘æˆ–å›¾ç‰‡å¸§\nè‡ªåŠ¨æŠ½å¸§ï¼ˆåŸºäº message ä¸­ç»™çš„ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼Œä¾‹å¦‚ä¸Šè¿°çš„ç¬¬äºŒç§æƒ…å†µï¼‰ï¼‰\næ ‡å‡†åŒ–å›¾ç‰‡å°ºå¯¸ï¼ˆåŸºäº message ä¸­ç»™çš„ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼Œä¾‹å¦‚ä¸Šè¿°çš„ç¬¬äºŒç§æƒ…å†µï¼‰ï¼‰\nè¿”å›ä¸‰ç±»ä¿¡æ¯ï¼š\nimage_inputs: å›¾åƒåˆ—è¡¨ï¼ˆå¦‚æœæœ‰ï¼‰\nvideo_inputs: è§†é¢‘å¸§å›¾åƒåˆ—è¡¨ï¼ˆtensor æ ¼å¼ï¼‰\nvideo_kwargs: ä¸è§†é¢‘å¤„ç†ç›¸å…³çš„å‚æ•°ï¼ˆå¦‚å¸§æ—¶é—´æˆ³ã€ç»´åº¦ç­‰ï¼‰\n\n\n\nimage_inputs, video_inputs, video_kwargs = process_vision_info(messages, return_video_kwargs=True)\n\nVLM Fine-TuningEfficient Fine-TuningQuantizationé‡åŒ–é™ä½äº†æ¨¡å‹æƒé‡å’Œæ¿€æ´»çš„ç²¾åº¦ï¼Œæ˜¾è‘—é™ä½äº†å†…å­˜ä½¿ç”¨å¹¶åŠ å¿«äº†è®¡ç®—é€Ÿåº¦ã€‚ä¾‹å¦‚ï¼Œä» float32 åˆ‡æ¢åˆ° bfloat16 å¯ä»¥åœ¨ä¿æŒæ€§èƒ½çš„åŒæ—¶å‡å°‘æ¯ä¸ªå‚æ•°çš„å†…å­˜éœ€æ±‚ã€‚å¯¹äºæ›´æ¿€è¿›çš„å‹ç¼©ï¼Œå¯ä»¥ä½¿ç”¨ 8 ä½å’Œ 4 ä½é‡åŒ–ï¼Œè¿›ä¸€æ­¥å‡å°‘å†…å­˜ä½¿ç”¨ï¼Œä½†ä»£ä»·æ˜¯ä¸€å®šçš„å‡†ç¡®æ€§ã€‚è¿™äº›æŠ€æœ¯å¯ä»¥åº”ç”¨äºæ¨¡å‹å’Œä¼˜åŒ–å™¨è®¾ç½®ï¼Œä»è€Œåœ¨æœ‰é™çš„èµ„æºä¸‹å¯¹ç¡¬ä»¶è¿›è¡Œæœ‰æ•ˆçš„è®­ç»ƒã€‚\nPEFT &amp; LoRALoRA ï¼ˆLow-Rank Adaptationï¼‰ä¸“æ³¨äºå­¦ä¹ ç´§å‡‘çš„ç§©åˆ†è§£çŸ©é˜µï¼ŒåŒæ—¶ä¿æŒåŸå§‹æ¨¡å‹æƒå€¼ä¸å˜ã€‚è¿™å¤§å¤§å‡å°‘äº†å¯è®­ç»ƒå‚æ•°çš„æ•°é‡ï¼Œæ˜¾è‘—å‡å°‘äº†èµ„æºéœ€æ±‚ã€‚å½“LoRAä¸PEFTé›†æˆæ—¶ï¼Œåªéœ€è°ƒæ•´ä¸€å°éƒ¨åˆ†å¯è®­ç»ƒçš„å‚æ•°å­é›†ï¼Œå°±å¯ä»¥å¯¹å¤§å‹æ¨¡å‹è¿›è¡Œå¾®è°ƒã€‚è¿™ç§æ–¹æ³•å¯¹äºç‰¹å®šäºä»»åŠ¡çš„è°ƒæ•´ç‰¹åˆ«æœ‰æ•ˆï¼Œåœ¨ä¿æŒæ€§èƒ½çš„åŒæ—¶å°†æ•°åäº¿ä¸ªå¯è®­ç»ƒå‚æ•°å‡å°‘åˆ°æ•°ç™¾ä¸‡ä¸ªã€‚\nBatch Size Optimizationä¸ºäº†ä¼˜åŒ–æ‰¹å¤§å°ä»¥è¿›è¡Œå¾®è°ƒï¼Œå¯ä»¥ä»ä¸€ä¸ªè¾ƒå¤§çš„å€¼å¼€å§‹ï¼Œå¹¶åœ¨å‘ç”Ÿå†…å­˜ä¸è¶³ï¼ˆOOMï¼‰é”™è¯¯æ—¶å‡å°å®ƒã€‚é€šè¿‡å¢åŠ  gradient_accumulation_steps è¿›è¡Œè¡¥å¿ï¼Œæœ‰æ•ˆåœ°ç»´æŠ¤å¤šä¸ªæ›´æ–°çš„æ€»æ‰¹å¤§å°ã€‚æ­¤å¤–ï¼Œå¯ç”¨ gradient_checkpointingï¼Œé€šè¿‡åœ¨åå‘ä¼ é€’æœŸé—´é‡æ–°è®¡ç®—ä¸­é—´çŠ¶æ€æ¥é™ä½å†…å­˜ä½¿ç”¨ï¼Œä»¥å‡å°‘è®¡ç®—æ—¶é—´æ¥å‡å°‘æ¿€æ´»å†…å­˜éœ€æ±‚ã€‚è¿™äº›ç­–ç•¥æœ€å¤§é™åº¦åœ°æé«˜äº†ç¡¬ä»¶åˆ©ç”¨ç‡ï¼Œå¹¶æœ‰åŠ©äºå…‹æœå†…å­˜é™åˆ¶ã€‚\nç®€å•æ¥è¯´ï¼Œbatch size è¿‡å¤§ä¼šå¯¼è‡´ OOMï¼ˆOut-Of-Memoryï¼‰ï¼Œå¯ä»¥ä½¿ç”¨ä»¥ä¸‹ç­–ç•¥ï¼š\n\nè®¾ç½®å¦‚ä¸‹ï¼š\nfrom transformers import TrainingArgumentstraining_args = TrainingArguments(    output_dir=&quot;./fine_tuned_model&quot;,  # Directory for model checkpoints    per_device_train_batch_size=4,   # Batch size per device (GPU/TPU)    num_train_epochs=3,              # Total training epochs    learning_rate=5e-5,              # Learning rate    save_steps=1000,                 # Save checkpoint every 1000 steps    bf16=True,                       # Use mixed precision for training    gradient_checkpointing=True,     # Enable to reduce activation memory usage    gradient_accumulation_steps=16,  # Accumulate gradients over 16 steps    logging_steps=50                 # Log metrics every 50 steps)\n\nSupervised Fine-Tuningç›‘ç£å¾®è°ƒï¼ˆSFTï¼‰é€šè¿‡åˆ©ç”¨åŒ…å«æˆå¯¹è¾“å…¥ï¼ˆå¦‚å›¾åƒå’Œç›¸åº”æ–‡æœ¬ï¼‰çš„æ ‡è®°æ•°æ®é›†ï¼Œä½¿é¢„è®­ç»ƒçš„è§†è§‰è¯­è¨€æ¨¡å‹ï¼ˆVLMï¼‰é€‚åº”ç‰¹å®šä»»åŠ¡ã€‚è¯¥æ–¹æ³•å¢å¼ºäº†æ¨¡å‹æ‰§è¡Œç‰¹å®šé¢†åŸŸæˆ–ç‰¹å®šä»»åŠ¡åŠŸèƒ½çš„èƒ½åŠ›ï¼Œä¾‹å¦‚å¯è§†åŒ–é—®é¢˜å›ç­”ã€å›¾åƒå­—å¹•æˆ–å›¾è¡¨è§£é‡Šã€‚\nPreference Optimizationåå¥½ä¼˜åŒ–ï¼Œç‰¹åˆ«æ˜¯ç›´æ¥åå¥½ä¼˜åŒ–ï¼ˆDPOï¼‰ï¼Œè®­ç»ƒè§†è§‰è¯­è¨€æ¨¡å‹ï¼ˆVLMï¼‰ä¸äººç±»åå¥½ä¿æŒä¸€è‡´ã€‚è¯¥æ¨¡å‹ä¸æ˜¯ä¸¥æ ¼éµå¾ªé¢„å®šä¹‰çš„æŒ‡ä»¤ï¼Œè€Œæ˜¯å­¦ä¼šä¼˜å…ˆè€ƒè™‘äººç±»ä¸»è§‚ä¸Šå–œæ¬¢çš„è¾“å‡ºã€‚è¿™ç§æ–¹æ³•å¯¹äºæ¶‰åŠåˆ›é€ æ€§åˆ¤æ–­ã€ç»†è‡´æ¨ç†æˆ–ä¸åŒå¯æ¥å—ç­”æ¡ˆçš„ä»»åŠ¡ç‰¹åˆ«æœ‰ç”¨ã€‚\nPractice with SFTåŠ è½½æ¨¡å‹\nmodel_name = &quot;HuggingFaceTB/SmolVLM-Instruct&quot;model = AutoModelForVision2Seq.from_pretrained(    model_name,    quantization_config=quantization_config,    torch_dtype=torch.bfloat16,).to(device)processor = AutoProcessor.from_pretrained(&quot;HuggingFaceTB/SmolVLM-Instruct&quot;)\n\nè®¾ç½® LoRAã€‚æ³¨æ„è¿™é‡Œä½¿ç”¨çš„æ˜¯ get_peft_model æ–¹æ³•ã€‚å‰é¢çš„ä»£ç åœ¨åŠ è½½æ¨¡å‹æ—¶å°±æ·»åŠ äº† peft å‚æ•°ï¼Œä½†æ˜¯æ›´æ¨èä¸‹é¢è¿™ç§æ–¹æ³•ï¼Œå³å…ˆåŠ è½½æ¨¡å‹ï¼Œç„¶åå†å°†å¯è®­ç»ƒçš„å‚æ•°ç»“åˆåˆ°æ¨¡å‹ä¸­ã€‚\nfrom peft import LoraConfig, get_peft_model# Configure LoRApeft_config = LoraConfig(    lora_alpha=16,    lora_dropout=0.05,    r=8,    bias=&quot;none&quot;,    target_modules=[&quot;q_proj&quot;, &quot;v_proj&quot;],    task_type=&quot;CAUSAL_LM&quot;,)# Apply PEFT model adaptationpeft_model = get_peft_model(model, peft_config)# Print trainable parameterspeft_model.print_trainable_parameters()\n\nå®šä¹‰ collate_fn å‡½æ•°ç”¨äºé¢„å¤„ç†æ•°æ®ï¼Œç›®çš„æ˜¯å°†ä¸€ä¸ªæ‰¹æ¬¡ï¼ˆbatchï¼‰çš„å›¾æ–‡å¯¹è¯æ ·æœ¬ï¼Œæ•´ç†ä¸ºæ¨¡å‹å¯ä»¥ç›´æ¥ä½¿ç”¨çš„å¼ é‡è¾“å…¥æ ¼å¼ã€‚\n\nexamples æ˜¯ä¸€ä¸ª batch çš„åŸå§‹æ ·æœ¬åˆ—è¡¨ã€‚\nå¯¹äº batch ä¸­çš„æ¯ä¸ªæ ·æœ¬ï¼Œéƒ½æ„å»ºä¸€ä¸ª message å­—å…¸ã€‚\nå¯¹æ„é€ å¥½çš„ message æ·»åŠ èŠå¤©æ¨¡æ¿ï¼Œç„¶åå­˜æ”¾åœ¨ text_inputs ä¸­\nå¯¹å½“å‰å›¾åƒè¿›è¡Œé¢„å¤„ç†ï¼Œåœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼ŒåŠ è½½çš„æ•°æ®é›†ç»“æ„å¦‚ä¸‹ï¼Œimage å­—æ®µå·²ç»æ˜¯ä¸€ä¸ª PIL å¯¹è±¡ã€‚å°†å¤„ç†å¥½çš„ image ä¿å­˜åˆ° image_inputs ä¸­ã€‚print(ds)DatasetDict(&#123;    train: Dataset(&#123;        features: [&#x27;image&#x27;, &#x27;query&#x27;, &#x27;label&#x27;, &#x27;human_or_machine&#x27;],        num_rows: 28299    &#125;)    val: Dataset(&#123;        features: [&#x27;image&#x27;, &#x27;query&#x27;, &#x27;label&#x27;, &#x27;human_or_machine&#x27;],        num_rows: 1920    &#125;)    test: Dataset(&#123;        features: [&#x27;image&#x27;, &#x27;query&#x27;, &#x27;label&#x27;, &#x27;human_or_machine&#x27;],        num_rows: 2500    &#125;)&#125;)print(type(ds[&#x27;train&#x27;][0][&#x27;image&#x27;]))&lt;class &#x27;PIL.PngImagePlugin.PngImageFile&#x27;&gt;\nå°†æ–‡æœ¬ prompt + å›¾åƒè¾“å…¥é€å…¥ processorï¼Œè¿”å›çš„ batch ä¸ºä¸€ä¸ª listï¼Œå…¶ä¸­çš„ä¸€ä¸ªå…ƒç´ åŒ…å«ï¼š\ninput_idsï¼ˆæ–‡æœ¬ token idsï¼‰\npixel_valuesï¼ˆå›¾åƒ tensorï¼‰\nattention_mask ï¼ˆmaskï¼‰\n\n\næ„é€  labels å­—æ®µ,æŠŠ padding token çš„ä½ç½®ç½®ä¸º -100ï¼Œå‘Šè¯‰ loss ä¸è®¡ç®—è¿™äº›ä½ç½®\nå°† image token ä½ç½®åŒæ ·ä¹Ÿè®¾ç½®ä¸º -100ï¼Œå›¾åƒåœ¨æ–‡æœ¬ä¸­æ˜¯é€šè¿‡ä¸€ä¸ªç‰¹æ®Š tokenï¼ˆå¦‚ &lt;image&gt;ï¼‰å ä½çš„ï¼Œä½†è¿™ä¸ª token ä¸æ˜¯æ¨¡å‹è¦é¢„æµ‹çš„ç›®æ ‡ï¼Œæ‰€ä»¥ä¹Ÿå°†å…¶è®¾ä¸º -100 ä»¥å±è”½ loss\næœ€ç»ˆè¿”å›æ„é€ å¥½çš„æ ·æœ¬:\ninput_ids\nattention_mask\npixel_values\nlabels\n\n\n\ndef collate_fn(examples):    # System message template for the VLM    system_message = &quot;&quot;&quot;You are a Vision Language Model specialized in interpreting visual data from chart images.    Your task is to analyze the provided chart image and respond to queries with concise answers, usually a single word, number, or short phrase.    The charts include a variety of types (e.g., line charts, bar charts) and contain colors, labels, and text.    Focus on delivering accurate, succinct answers based on the visual information. Avoid additional explanation unless absolutely necessary.&quot;&quot;&quot;    # Initialize lists for text and image inputs    text_inputs = []    image_inputs = []    # Process all examples in one loop    for example in examples:        # Format the chat structure for the processor        formatted_example = &#123;            &quot;messages&quot;: [                &#123;                    &quot;role&quot;: &quot;system&quot;,                    &quot;content&quot;: [&#123;&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: system_message&#125;],                &#125;,                &#123;                    &quot;role&quot;: &quot;user&quot;,                    &quot;content&quot;: [                        &#123;                            &quot;type&quot;: &quot;image&quot;,                        &#125;,                        &#123;                            &quot;type&quot;: &quot;text&quot;,                            &quot;text&quot;: example[&quot;query&quot;],                        &#125;,                    ],                &#125;,            ]        &#125;        # Apply chat template and strip extra spaces        text_inputs.append(processor.apply_chat_template(formatted_example[&quot;messages&quot;], tokenize=False).strip())                # Ensure images are in RGB mode        image = example[&quot;image&quot;]        if image.mode != &#x27;RGB&#x27;:            image = image.convert(&#x27;RGB&#x27;)        image_inputs.append( [image] )    # Tokenize the texts and process the images    batch = processor(        text=text_inputs,        images=image_inputs,        return_tensors=&quot;pt&quot;,        padding=True    )    # Clone input IDs for labels    labels = batch[&quot;input_ids&quot;].clone()    labels[labels == processor.tokenizer.pad_token_id] = -100  # Mask padding tokens in labels    # Ensure image_token is converted to string if it is an AddedToken    # In some processor, processor.image_token return a list for each image.    # TODO: AutoProcessor.from_pretrained(&quot;HuggingFaceTB/SmolVLM-Instruct&quot;) only have one ?    image_token_id = processor.tokenizer.convert_tokens_to_ids(str(processor.image_token))    # Mask image token IDs in the labels    labels[labels == image_token_id] = -100    # Add labels back to the batch    batch[&quot;labels&quot;] = labels    return batch\n\næœ€åé…ç½®å‚æ•°ã€‚æ³¨æ„åœ¨ SFTConfig ä¸­ï¼š\n\ndataset_text_field&#x3D;â€â€ï¼šæŒ‡å®šæ•°æ®é›†ä¸­ç”¨ä½œæ–‡æœ¬è¾“å…¥çš„å­—æ®µï¼Œè¿™é‡Œç•™ç©ºï¼ˆå› ä½¿ç”¨è‡ªå®šä¹‰ collate_fnï¼‰\nskip_prepare_dataset&#x3D;Trueï¼šå‘Šè¯‰ trl ä¸éœ€è¦è‡ªåŠ¨é¢„å¤„ç†æ•°æ®é›†ï¼Œæˆ‘ä»¬æ‰‹åŠ¨å¤„ç†\nremove_unused_columns&#x3D;Falseï¼šä¿ç•™æ‰€æœ‰å­—æ®µï¼Œå¦åˆ™åªä¼šä¿ç•™ tokenizer ç”¨åˆ°çš„å­—æ®µï¼Œä¼šä¸¢å›¾åƒç­‰ä¿¡æ¯\n\nSFTTrainer ä¸­ï¼Œè®¾ç½® data_collator&#x3D;collate_fnï¼Œè¡¨ç¤ºè‡ªå®šä¹‰çš„æ‰¹å¤„ç†å‡½æ•°ï¼Œç”¨äºå›¾æ–‡æ··åˆæ•°æ®\nfrom trl import SFTConfig, SFTTrainer# Configure the Trainertraining_args = SFTConfig(    output_dir=&quot;sft_output&quot;,  # Directory to save the model    num_train_epochs=3,                     # number of training epochs    per_device_train_batch_size=1,          # batch size per device during training    gradient_accumulation_steps=16,         # number of steps before performing a backward/update pass    gradient_checkpointing=True,            # use gradient checkpointing to save memory    optim=&quot;adamw_torch_fused&quot;,              # use fused adamw optimizer    logging_steps=5,                        # log every 10 steps    save_strategy=&quot;epoch&quot;,                  # save checkpoint every epoch    learning_rate=2e-4,                     # learning rate, based on QLoRA paper    bf16=True,                              # use bfloat16 precision    tf32=True,                              # use tf32 precision    max_grad_norm=0.3,                      # max gradient norm based on QLoRA paper    warmup_ratio=0.03,                      # warmup ratio based on QLoRA paper    lr_scheduler_type=&quot;constant&quot;,           # use constant learning rate scheduler    push_to_hub=True,                       # push model to hub    gradient_checkpointing_kwargs = &#123;&quot;use_reentrant&quot;: False&#125;, # use reentrant checkpointing    # dataloader_num_workers=16,     dataset_text_field=&quot;&quot;, # need a dummy field for collator    dataset_kwargs = &#123;&quot;skip_prepare_dataset&quot;: True&#125;, # important for collator    remove_unused_columns = False                    # necessary else features except label will be removed)# Initialize the Trainertrainer = SFTTrainer(    model=model,    args=training_args,    train_dataset=ds[&quot;train&quot;],    eval_dataset=ds[&quot;test&quot;],    data_collator=collate_fn,    peft_config=peft_config,    tokenizer=processor.tokenizer,)\n","categories":["LLM"],"tags":["trl","smol"]},{"title":"ã€Smol Courseã€‘3-å‚æ•°é«˜æ•ˆå¾®è°ƒ","url":"/blog/LLM/smol3/","content":"Parameter-Efficient Fine-Tuning (PEFT)éšç€è¯­è¨€æ¨¡å‹å˜å¾—è¶Šæ¥è¶Šå¤§ï¼Œä¼ ç»Ÿçš„å¾®è°ƒå˜å¾—è¶Šæ¥è¶Šå…·æœ‰æŒ‘æˆ˜æ€§ã€‚å³ä½¿æ˜¯ 1.7B å‚æ•°æ¨¡å‹çš„å…¨é¢å¾®è°ƒä¹Ÿéœ€è¦å¤§é‡çš„ GPU å†…å­˜ï¼Œä½¿å­˜å‚¨å•ç‹¬çš„æ¨¡å‹å‰¯æœ¬å˜å¾—æ˜‚è´µï¼Œå¹¶ä¸”æœ‰å¯èƒ½ç¾éš¾æ€§åœ°å¿˜è®°æ¨¡å‹çš„åŸå§‹åŠŸèƒ½ã€‚å‚æ•°æœ‰æ•ˆå¾®è°ƒï¼ˆPEFTï¼‰æ–¹æ³•é€šè¿‡ä»…ä¿®æ”¹æ¨¡å‹å‚æ•°çš„ä¸€å°éƒ¨åˆ†è€Œä¿æŒå¤§éƒ¨åˆ†æ¨¡å‹ä¸å˜æ¥è§£å†³è¿™äº›æŒ‘æˆ˜ã€‚\nä¼ ç»Ÿçš„å¾®è°ƒåœ¨è®­ç»ƒè¿‡ç¨‹ä¸­æ›´æ–°æ‰€æœ‰çš„æ¨¡å‹å‚æ•°ï¼Œè¿™å¯¹äºå¤§å‹æ¨¡å‹æ¥è¯´æ˜¯ä¸åˆ‡å®é™…çš„ã€‚PEFT æ–¹æ³•å¼•å…¥äº†ä½¿ç”¨è¾ƒå°‘å¯è®­ç»ƒå‚æ•°ï¼ˆé€šå¸¸å°äºåŸå§‹æ¨¡å‹å¤§å°çš„ 1%ï¼‰æ¥è°ƒæ•´æ¨¡å‹çš„æ–¹æ³•ã€‚å¯è®­ç»ƒå‚æ•°çš„å¤§å¹…å‡å°‘ä½¿ï¼š\n\nåœ¨ GPU å†…å­˜æœ‰é™çš„æ¶ˆè´¹è€…ç¡¬ä»¶ä¸Šè¿›è¡Œå¾®è°ƒ\næœ‰æ•ˆåœ°å­˜å‚¨å¤šä¸ªç‰¹å®šäºä»»åŠ¡çš„é€‚åº”æ€§\nåœ¨ä½æ•°æ®åœºæ™¯ä¸‹æ›´å¥½çš„æ³›åŒ–\næ›´å¿«çš„è®­ç»ƒå’Œè¿­ä»£å‘¨æœŸ\n\nLoRA (Low-Rank Adaptation)LoRA å·²æˆä¸ºæœ€å¹¿æ³›é‡‡ç”¨çš„ PEFT æ–¹æ³•ã€‚å®ƒçš„å·¥ä½œåŸç†æ˜¯å°†å°ç§©åˆ†è§£çŸ©é˜µæ·»åŠ åˆ°æ³¨æ„åŠ›æƒé‡ä¸­ï¼Œé€šå¸¸ä¼šå°†å¯è®­ç»ƒå‚æ•°å‡å°‘çº¦ 90%ã€‚åœ¨æ¨ç†æœŸé—´ï¼Œè¿™äº›é€‚é…å™¨æƒé‡å¯ä»¥ä¸åŸºæœ¬æ¨¡å‹åˆå¹¶ï¼Œä»è€Œä¸ä¼šäº§ç”Ÿé¢å¤–çš„å»¶è¿Ÿå¼€é”€ã€‚LoRA å¯¹äºä½¿å¤§å‹è¯­è¨€æ¨¡å‹é€‚åº”ç‰¹å®šçš„ä»»åŠ¡æˆ–é¢†åŸŸï¼ŒåŒæ—¶ä¿æŒèµ„æºéœ€æ±‚å¯ç®¡ç†ç‰¹åˆ«æœ‰ç”¨ã€‚\nLoading LoRA Adapterså¯ä»¥ä½¿ç”¨ load_adapter() å°†é€‚é…å™¨åŠ è½½åˆ°é¢„è®­ç»ƒçš„æ¨¡å‹ä¸­ï¼Œè¿™å¯¹äºå°è¯•æœªåˆå¹¶æƒé‡çš„ä¸åŒé€‚é…å™¨éå¸¸æœ‰ç”¨ã€‚ä½¿ç”¨ set_adapter() å‡½æ•°è®¾ç½®æ´»åŠ¨é€‚é…å™¨æƒé‡ã€‚è¦è¿”å›åŸºæœ¬æ¨¡å‹ï¼Œå¯ä»¥ä½¿ç”¨ unload() å¸è½½æ‰€æœ‰çš„ LoRA æ¨¡å—ã€‚è¿™ä½¿å¾—åœ¨ä¸åŒçš„ä»»åŠ¡ç‰¹å®šæƒé‡ä¹‹é—´åˆ‡æ¢å˜å¾—å¾ˆå®¹æ˜“ã€‚\nfrom transformers import AutoModelForCausalLMfrom peft import PeftModelbase_model = AutoModelForCausalLM.from_pretrained(&quot;&lt;base_model_name&gt;&quot;)peft_model_id = &quot;&lt;peft_adapter_id&gt;&quot;model = PeftModel.from_pretrained(base_model, peft_model_id)\n\nMerging LoRA Adaptersåœ¨ä½¿ç”¨ LoRA è¿›è¡Œè®­ç»ƒä¹‹åï¼Œæ‚¨å¯èƒ½å¸Œæœ›å°†é€‚é…å™¨æƒé‡åˆå¹¶å›åŸºæœ¬æ¨¡å‹ä¸­ï¼Œä»¥ä¾¿äºéƒ¨ç½²ã€‚è¿™å°†åˆ›å»ºå…·æœ‰ç»„åˆæƒé‡çš„å•ä¸ªæ¨¡å‹ï¼Œä»è€Œæ¶ˆé™¤äº†åœ¨æ¨ç†æœŸé—´å•ç‹¬åŠ è½½é€‚é…å™¨çš„éœ€è¦ã€‚\nåˆå¹¶è¿‡ç¨‹éœ€è¦æ³¨æ„å†…å­˜ç®¡ç†å’Œç²¾åº¦ã€‚ç”±äºæ‚¨éœ€è¦åŒæ—¶åŠ è½½åŸºæœ¬æ¨¡å‹å’Œé€‚é…å™¨æƒé‡ï¼Œå› æ­¤è¯·ç¡®ä¿æœ‰è¶³å¤Ÿçš„ GPU&#x2F;CPU å†…å­˜å¯ç”¨ã€‚åœ¨ transformer ä¸­ä½¿ç”¨ device_map&#x3D;â€autoâ€ å°†æœ‰åŠ©äºè‡ªåŠ¨å†…å­˜ç®¡ç†ã€‚åœ¨æ•´ä¸ªè¿‡ç¨‹ä¸­ä¿æŒä¸€è‡´çš„ç²¾åº¦ï¼ˆä¾‹å¦‚ï¼Œfloat16ï¼‰ï¼ŒåŒ¹é…è®­ç»ƒæœŸé—´ä½¿ç”¨çš„ç²¾åº¦ï¼Œå¹¶ä»¥ç›¸åŒçš„æ ¼å¼ä¿å­˜åˆå¹¶æ¨¡å‹ä»¥ä¾›éƒ¨ç½²ã€‚åœ¨éƒ¨ç½²ä¹‹å‰ï¼Œå§‹ç»ˆé€šè¿‡å°†å…¶è¾“å‡ºå’Œæ€§èƒ½æŒ‡æ ‡ä¸åŸºäºé€‚é…å™¨çš„ç‰ˆæœ¬è¿›è¡Œæ¯”è¾ƒæ¥éªŒè¯åˆå¹¶æ¨¡å‹ã€‚\nimport torchfrom transformers import AutoModelForCausalLMfrom peft import PeftModel# 1. Load the base modelbase_model = AutoModelForCausalLM.from_pretrained(    &quot;base_model_name&quot;,    torch_dtype=torch.float16,    device_map=&quot;auto&quot;)# 2. Load the PEFT model with adapterpeft_model = PeftModel.from_pretrained(    base_model,    &quot;path/to/adapter&quot;,    torch_dtype=torch.float16)# 3. Merge adapter weights with base modeltry:    merged_model = peft_model.merge_and_unload()except RuntimeError as e:    print(f&quot;Merging failed: &#123;e&#125;&quot;)    # Implement fallback strategy or memory optimization# 4. Save the merged modelmerged_model.save_pretrained(&quot;path/to/save/merged_model&quot;)\n\næ³¨æ„ï¼ŒPEFT ä¿å­˜çš„æ¨¡å‹åªä¿å­˜ adapterï¼ˆå¦‚ LoRA æƒé‡ï¼‰éƒ¨åˆ†ï¼Œä½†æ˜¯ï¼ŒAutoPeftModelForCausalLM ä¼šï¼š\n\nè‡ªåŠ¨åŠ è½½ base modelï¼ˆå¦‚ LLaMAã€Qwenã€GPT-NeoXï¼‰ï¼šé€šè¿‡åœ¨ adapter config ä¸­ä¿å­˜çš„ base model è·¯å¾„ï¼ˆæˆ–ä½ ä¼ çš„è·¯å¾„ï¼‰ï¼›\nç„¶ååœ¨æ­¤åŸºç¡€ä¸ŠåŠ è½½ adapter æƒé‡ï¼›\nå¾—åˆ°ä¸€ä¸ªå®Œæ•´çš„ã€å¯è¿è¡Œçš„ PEFT æ¨¡å‹ã€‚\næ¢å¥è¯è¯´ï¼Œä¼ å…¥çš„ args.output_dir å®é™…ä¸Šæ˜¯åŒ…å«ï¼š\nadapter æƒé‡\nadapter é…ç½®\nä¸€ä¸ªå¯è§£æçš„ base_model_name_or_path å­—æ®µï¼ˆæŒ‡å‘åŸå§‹æ¨¡å‹ï¼‰\n\n\n\nUsing TRL with PEFTfrom peft import LoraConfigfrom transformers import AutoModelForCausalLM# Load model with PEFT configlora_config = LoraConfig(    r=16,    lora_alpha=32,    lora_dropout=0.05,    bias=&quot;none&quot;,    task_type=&quot;CAUSAL_LM&quot;)# Load model on specific devicemodel = AutoModelForCausalLM.from_pretrained(    &quot;your-model-name&quot;,    load_in_8bit=True,  # Optional: use 8-bit precision    device_map=&quot;auto&quot;,    peft_config=lora_config)\n\nPracticeParameterså®šä¹‰ PEFT å‚æ•°\nfrom peft import LoraConfig# TODO: Configure LoRA parameters# r: rank dimension for LoRA update matrices (smaller = more compression)rank_dimension = 6# lora_alpha: scaling factor for LoRA layers (higher = stronger adaptation)lora_alpha = 8# lora_dropout: dropout probability for LoRA layers (helps prevent overfitting)lora_dropout = 0.05peft_config = LoraConfig(    r=rank_dimension,  # Rank dimension - typically between 4-32    lora_alpha=lora_alpha,  # LoRA scaling factor - typically 2x rank    lora_dropout=lora_dropout,  # Dropout probability for LoRA layers    bias=&quot;none&quot;,  # Bias type for LoRA. the corresponding biases will be updated during training.    target_modules=&quot;all-linear&quot;,  # Which modules to apply LoRA to    task_type=&quot;CAUSAL_LM&quot;,  # Task type for model architecture)\n\nå°† PEFT å‚æ•°æ·»åŠ åˆ° SFTTrainer ä¸­ã€‚\nmax_seq_length = 1512  # max sequence length for model and packing of the dataset# Create SFTTrainer with LoRA configurationtrainer = SFTTrainer(    model=model,    args=args,    train_dataset=dataset[&quot;train&quot;],    peft_config=peft_config,  # LoRA configuration    max_seq_length=max_seq_length,  # Maximum sequence length    tokenizer=tokenizer,    packing=True,  # Enable input packing for efficiency    dataset_kwargs=&#123;        &quot;add_special_tokens&quot;: False,  # Special tokens handled by template        &quot;append_concat_token&quot;: False,  # No additional separator needed    &#125;,)\n\nLoad adapters from the Hub\né¦–å…ˆåŠ è½½çš„æ˜¯ PeftConfig\nç„¶ååŸºäº PeftConfig åŠ è½½ base model\næœ€ååŠ è½½å¸¦ LoRA çš„æ¨¡å‹\n\nimport torchimport transformersfrom datasets import load_datasetfrom peft import LoraConfig, get_peft_modelfrom peft import PeftModel, PeftConfigfrom transformers import AutoModelForCausalLM, AutoTokenizerpeft_model_id = &quot;ybelkada/opt-6.7b-lora&quot;config = PeftConfig.from_pretrained(peft_model_id)model = AutoModelForCausalLM.from_pretrained(    config.base_model_name_or_path,    return_dict=True,    load_in_8bit=True,    device_map=&quot;auto&quot;,)tokenizer = AutoTokenizer.from_pretrained(config.base_model_name_or_path)# Load the Lora modelmodel = PeftModel.from_pretrained(model, peft_model_id)\n\nPrompt Tuningæç¤ºè°ƒä¼˜æ˜¯ä¸€ç§å‚æ•°é«˜æ•ˆçš„æ–¹æ³•ï¼Œå®ƒä¿®æ”¹è¾“å…¥è¡¨ç¤ºï¼Œè€Œä¸æ˜¯æ¨¡å‹æƒé‡ã€‚ä¸æ›´æ–°æ‰€æœ‰æ¨¡å‹å‚æ•°çš„ä¼ ç»Ÿå¾®è°ƒä¸åŒï¼Œæç¤ºè°ƒä¼˜åœ¨ä¿æŒåŸºæœ¬æ¨¡å‹ä¸å˜çš„åŒæ—¶æ·»åŠ å¹¶ä¼˜åŒ–äº†ä¸€å°ç»„å¯è®­ç»ƒçš„ä»¤ç‰Œã€‚æç¤ºè°ƒä¼˜å°†å¯è®­ç»ƒçš„è¿ç»­å‘é‡ï¼ˆè½¯æç¤ºï¼‰æ·»åŠ åˆ°è¾“å…¥æ–‡æœ¬ä¸­ã€‚\nè¿™äº›è½¯æç¤ºæ˜¯æ¨¡å‹åµŒå…¥ç©ºé—´ä¸­çš„è¿ç»­å‘é‡ï¼Œåœ¨è®­ç»ƒè¿‡ç¨‹ä¸­å¾—åˆ°ä¼˜åŒ–ã€‚ä¸ä½¿ç”¨è‡ªç„¶è¯­è¨€æ ‡è®°çš„ä¼ ç»Ÿç¦»æ•£æç¤ºä¸åŒï¼Œè½¯æç¤ºæ²¡æœ‰å›ºæœ‰çš„å«ä¹‰ï¼Œè€Œæ˜¯é€šè¿‡æ¢¯åº¦ä¸‹é™å­¦ä¹ ä»å†»ç»“æ¨¡å‹ä¸­å¼•å‡ºæ‰€éœ€çš„è¡Œä¸ºã€‚è¯¥æŠ€æœ¯å¯¹äºå¤šä»»åŠ¡åœºæ™¯ç‰¹åˆ«æœ‰æ•ˆï¼Œå› ä¸ºæ¯ä¸ªä»»åŠ¡åªéœ€è¦å­˜å‚¨ä¸€ä¸ªå°çš„æç¤ºå‘é‡ï¼ˆé€šå¸¸æ˜¯å‡ ç™¾ä¸ªå‚æ•°ï¼‰ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªå®Œæ•´çš„æ¨¡å‹å‰¯æœ¬ã€‚è¿™ç§æ–¹æ³•ä¸ä»…ä¿æŒäº†æœ€å°çš„å†…å­˜å ç”¨ï¼Œè€Œä¸”è¿˜æ”¯æŒå¿«é€Ÿçš„ä»»åŠ¡åˆ‡æ¢ã€‚\nåœ¨è®­ç»ƒè¿‡ç¨‹ä¸­ï¼Œåªæ›´æ–°æç¤ºå‚æ•°ï¼Œè€ŒåŸºæœ¬æ¨¡å‹ä¿æŒå†»ç»“ã€‚è¿™ç§é›†ä¸­çš„æ–¹æ³•ä½¿ç”¨æ ‡å‡†çš„è®­ç»ƒç›®æ ‡ï¼Œä½†éœ€è¦ä»”ç»†æ³¨æ„æç¤ºç¬¦å·çš„å­¦ä¹ ç‡å’Œæ¢¯åº¦è¡Œä¸ºã€‚\nImplementation with PEFTfrom peft import PromptTuningConfig, TaskType, get_peft_modelfrom transformers import AutoModelForCausalLM, AutoTokenizer# Load base modelmodel = AutoModelForCausalLM.from_pretrained(&quot;your-base-model&quot;)tokenizer = AutoTokenizer.from_pretrained(&quot;your-base-model&quot;)# Configure prompt tuningpeft_config = PromptTuningConfig(    task_type=TaskType.CAUSAL_LM,    num_virtual_tokens=8,  # Number of trainable tokens    prompt_tuning_init=&quot;TEXT&quot;,  # Initialize from text    prompt_tuning_init_text=&quot;Classify if this text is positive or negative:&quot;,    tokenizer_name_or_path=&quot;your-base-model&quot;,)# Create prompt-tunable modelmodel = get_peft_model(model, peft_config)\n\nComparison\n\n\nMethod\nParameters\nMemory\nTask Switching\n\n\n\nPrompt Tuning\nVery Low\nMinimal\nEasy\n\n\nLoRA\nLow\nLow\nRequires Loading\n\n\nFull Fine-tuning\nHigh\nHigh\nNew Model Copy\n\n\næç¤ºè°ƒä¼˜åœ¨ä»¥ä¸‹å‡ ä¸ªåœºæ™¯ä¸­è¡¨ç°å‡ºè‰²ï¼š\n\nå¤šä»»åŠ¡éƒ¨ç½²\nèµ„æºå—é™çš„ç¯å¢ƒ\nå¿«é€Ÿä»»åŠ¡é€‚åº”\néšç§çš„åº”ç”¨ç¨‹åº\n\n","categories":["LLM"],"tags":["trl","smol"]},{"title":"ã€Smol Courseã€‘7-æ¨ç†","url":"/blog/LLM/smol7/","content":"Inferenceæ¨ç†æ˜¯ä½¿ç”¨ç»è¿‡è®­ç»ƒçš„è¯­è¨€æ¨¡å‹æ¥ç”Ÿæˆé¢„æµ‹æˆ–å“åº”çš„è¿‡ç¨‹ã€‚è™½ç„¶æ¨ç†å¯èƒ½çœ‹èµ·æ¥å¾ˆç®€å•ï¼Œä½†å¤§è§„æ¨¡æœ‰æ•ˆåœ°éƒ¨ç½²æ¨¡å‹éœ€è¦ä»”ç»†è€ƒè™‘å„ç§å› ç´ ï¼Œå¦‚æ€§èƒ½ã€æˆæœ¬å’Œå¯é æ€§ã€‚å¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆllmï¼‰ç”±äºå…¶å¤§å°å’Œè®¡ç®—éœ€æ±‚è€Œæå‡ºäº†ç‹¬ç‰¹çš„æŒ‘æˆ˜ã€‚\nLLM æ¨ç†å¯ä»¥åˆ†ä¸ºä¸¤ç§ä¸»è¦æ–¹æ³•ï¼š\n\nç”¨äºå¼€å‘å’Œæµ‹è¯•çš„åŸºäºç®¡é“çš„ç®€å•æ¨ç†ï¼Œ\nç”¨äºç”Ÿäº§éƒ¨ç½²çš„ä¼˜åŒ–æœåŠ¡è§£å†³æ–¹æ¡ˆã€‚\n\næˆ‘ä»¬å°†ä»‹ç»è¿™ä¸¤ç§æ–¹æ³•ï¼Œä»ç®€å•çš„ç®¡é“æ–¹æ³•å¼€å§‹ï¼Œç„¶åè½¬å‘ç”Ÿäº§å°±ç»ªçš„è§£å†³æ–¹æ¡ˆã€‚\nBasic Inference with Transformers PipelineğŸ¤— transformer ä¸­çš„ pipeline æŠ½è±¡æä¾›äº†ä¸€ç§ç®€å•çš„æ–¹æ³•ï¼Œå¯ä»¥å¯¹æ¥è‡ª huggingface çš„ä»»ä½•æ¨¡å‹è¿è¡Œæ¨ç†ã€‚å®ƒå¤„ç†æ‰€æœ‰çš„é¢„å¤„ç†å’Œåå¤„ç†æ­¥éª¤ï¼Œä½¿å¾—æ— éœ€æ·±å…¥äº†è§£å…¶ä½“ç³»ç»“æ„æˆ–éœ€æ±‚å°±å¯ä»¥è½»æ¾ä½¿ç”¨æ¨¡å‹ã€‚\nä¸‰ä¸ªå…³é”®é˜¶æ®µï¼š\n\nPreprocessing\nModel Inference\nPostprocessing\n\nåŸºç¡€ç”¨æ³•from transformers import pipeline# Create a pipeline with a specific modelgenerator = pipeline(    &quot;text-generation&quot;,    model=&quot;HuggingFaceTB/SmolLM2-1.7B-Instruct&quot;,    torch_dtype=&quot;auto&quot;,    device_map=&quot;auto&quot;)# Generate textresponse = generator(    &quot;Write a short poem about coding:&quot;,    max_new_tokens=100,    do_sample=True,    temperature=0.7)print(response[0][&#x27;generated_text&#x27;])\n\nè¯¦ç»†çš„å‚æ•°è¯´æ˜\nresponse = generator(    &quot;Translate this to French:&quot;,    max_new_tokens=100,     # ç”Ÿæˆæ–‡æœ¬çš„æœ€å¤§é•¿åº¦    do_sample=True,         # è§£ç æ—¶ç”¨é‡‡æ ·çš„ç­–ç•¥ï¼Œè€Œä¸æ˜¯è´ªå¿ƒç­–ç•¥    temperature=0.7,        # è¿™ä¸ªå‚æ•°å¯ä»¥æ§åˆ¶éšæœºæ€§ï¼Œå€¼è¶Šå¤§è¶Šéšæœº    top_k=50,               # é‡‡æ ·æ—¶ï¼Œåªè€ƒè™‘æœ€é å‰çš„å‰ k ä¸ª token    top_p=0.95,             # é‡‡æ ·æ—¶ï¼Œæ¦‚ç‡å€¼çš„é˜ˆå€¼    num_return_sequences=1  # é’ˆå¯¹ä¸€ä¸ªè¾“å…¥è¾“å‡ºå‡ ä¸ªè¾“å‡º)\n\nText Generation Inference (TGI)Text Generation Inferenceï¼ˆç®€ç§° TGIï¼‰æ˜¯ä¸€ä¸ªç”± Hugging Face å¼€å‘çš„å·¥å…·åŒ…ï¼Œä¸»è¦ç”¨äºå¯¹å¤§è¯­è¨€æ¨¡å‹è¿›è¡Œéƒ¨ç½²å’ŒæœåŠ¡æ­å»ºã€‚å®ƒæ—¨åœ¨ä¸ºå¸¸ç”¨çš„å¼€æºå¤§è¯­è¨€æ¨¡å‹ï¼ˆLLMsï¼‰å®ç°é«˜æ€§èƒ½æ–‡æœ¬ç”Ÿæˆã€‚TGI è¢« Hugging Chat ç”¨äºå®é™…ç”Ÿäº§ï¼ŒHugging Chat æ˜¯ä¸€ä¸ªé¢å‘å¼€æºæ¨¡å‹çš„å¼€æºäº¤äº’ç•Œé¢ã€‚\nå³è°ƒç”¨ API çš„è¿‡ç¨‹\nfrom openai import OpenAI# init the client but point it to TGIclient = OpenAI(    base_url=&quot;http://localhost:8080/v1/&quot;,    api_key=&quot;-&quot;)chat_completion = client.chat.completions.create(    model=&quot;tgi&quot;,    messages=[        &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a helpful assistant.&quot; &#125;,        &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;What is deep learning?&quot;&#125;    ],    stream=True)# iterate and print streamfor message in chat_completion:    print(message)","categories":["LLM"],"tags":["trl","smol"]},{"title":"ã€Smol Courseã€‘6-åˆæˆæ•°æ®","url":"/blog/LLM/smol6/","content":"åˆæˆæ•°æ®æ˜¯æ¨¡æ‹ŸçœŸå®ä¸–ç•Œä½¿ç”¨æƒ…å†µçš„äººå·¥ç”Ÿæˆçš„æ•°æ®ã€‚å®ƒå…è®¸é€šè¿‡æ‰©å±•æˆ–å¢å¼ºæ•°æ®é›†æ¥å…‹æœæ•°æ®é™åˆ¶ã€‚å°½ç®¡åˆæˆæ•°æ®å·²ç»ç”¨äºä¸€äº›ç”¨ä¾‹ï¼Œä½†å¤§å‹è¯­è¨€æ¨¡å‹ä½¿å¾—åˆæˆæ•°æ®é›†åœ¨è®­ç»ƒå‰å’Œè®­ç»ƒåä»¥åŠè¯­è¨€æ¨¡å‹çš„è¯„ä¼°ä¸­æ›´å—æ¬¢è¿ã€‚\n","categories":["LLM"],"tags":["trl","smol"]},{"title":"ã€Smol Courseã€‘8-æ™ºèƒ½ä½“","url":"/blog/LLM/smol8/","content":"AgentAI æ™ºèƒ½ä½“ï¼ˆAI Agentsï¼‰æ˜¯ä¸€ç§è‡ªä¸»ç³»ç»Ÿï¼Œèƒ½å¤Ÿç†è§£ç”¨æˆ·è¯·æ±‚ã€å°†è¯·æ±‚æ‹†è§£ä¸ºå¤šä¸ªæ­¥éª¤ï¼Œç„¶åæ‰§è¡Œç›¸åº”è¡ŒåŠ¨ä»¥å®Œæˆä»»åŠ¡ã€‚å®ƒä»¬å°†è¯­è¨€æ¨¡å‹ä¸å·¥å…·åŠå¤–éƒ¨åŠŸèƒ½ç›¸ç»“åˆï¼Œä»è€Œä¸æ‰€å¤„ç¯å¢ƒè¿›è¡Œäº¤äº’ã€‚æœ¬æ¨¡ç« å°†è®²è§£å¦‚ä½•ä½¿ç”¨ smolagents åº“æ„å»ºé«˜æ•ˆçš„æ™ºèƒ½ä½“ï¼Œè¯¥åº“ä¸ºåˆ›å»ºå¼ºå¤§çš„ AI æ™ºèƒ½ä½“æä¾›äº†ä¸€ä¸ªè½»é‡çº§æ¡†æ¶ã€‚\né«˜æ•ˆçš„æ™ºèƒ½ä½“é€šå¸¸å…·å¤‡ä¸‰ç§å…³é”®èƒ½åŠ›ï¼š\n\næ£€ç´¢èƒ½åŠ›ï¼šæ™ºèƒ½ä½“éœ€è¦èƒ½å¤Ÿä»å„ç§ä¿¡æ¯æ¥æºè·å–å’Œä½¿ç”¨ç›¸å…³ä¿¡æ¯ã€‚\nå‡½æ•°è°ƒç”¨ï¼šè¿™ä½¿å¾—æ™ºèƒ½ä½“èƒ½å¤Ÿåœ¨æ‰€å¤„ç¯å¢ƒä¸­é‡‡å–å…·ä½“è¡ŒåŠ¨ã€‚\nç‰¹å®šé¢†åŸŸçš„çŸ¥è¯†å’Œå·¥å…·ï¼šè¿™èƒ½è®©æ™ºèƒ½ä½“å¯ä»¥æ‰§è¡Œè¯¸å¦‚ä»£ç æ“ä½œè¿™ç±»ä¸“ä¸šä»»åŠ¡ã€‚\n\nBuilding Agentic RAG Systemsè‡ªä¸»æ€§æ£€ç´¢å¢å¼ºç”Ÿæˆï¼ˆRAG æˆ– Retrieval Augmented Generationï¼‰å°†æœ‰è‡ªä¸»æ€§çš„æ™ºèƒ½ä½“çš„èƒ½åŠ›ä¸çŸ¥è¯†æ£€ç´¢èƒ½åŠ›ç›¸ç»“åˆã€‚ä¼ ç»Ÿçš„ RAG ç³»ç»Ÿåªæ˜¯åˆ©ç”¨å¤§è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰ï¼ŒåŸºäºæ£€ç´¢åˆ°çš„ä¿¡æ¯æ¥å›ç­”è¯¢é—®ã€‚è€Œè‡ªä¸»æ€§ RAG æ›´è¿›ä¸€æ­¥ï¼Œå…è®¸ç³»ç»Ÿæ™ºèƒ½åœ°æ§åˆ¶è‡ªèº«çš„æ£€ç´¢å’Œå›ç­”è¿‡ç¨‹ã€‚ä¼ ç»Ÿ RAG å­˜åœ¨å…³é”®å±€é™ â€”â€” å®ƒä»…æ‰§è¡Œå•ä¸€çš„æ£€ç´¢æ­¥éª¤ï¼Œä¸”ä¾èµ–ä¸ç”¨æˆ·è¯¢é—®çš„ç›´æ¥è¯­ä¹‰ç›¸ä¼¼æ€§ï¼Œè¿™å¯èƒ½ä¼šé—æ¼ç›¸å…³ä¿¡æ¯ã€‚è‡ªä¸»æ€§ RAG é€šè¿‡è®©æ™ºèƒ½ä½“èƒ½å¤Ÿè‡ªè¡Œåˆ¶å®šæœç´¢æŸ¥è¯¢ã€è¯„ä¼°ç»“æœï¼Œå¹¶æ ¹æ®éœ€è¦æ‰§è¡Œå¤šä¸ªæ£€ç´¢æ­¥éª¤ï¼Œæ¥åº”å¯¹è¿™äº›æŒ‘æˆ˜ã€‚\nBasic Retrieval with DuckDuckGoä»æ„å»ºä¸€ä¸ªç®€å•çš„ä»£ç†å¼€å§‹ï¼Œå®ƒå¯ä»¥ä½¿ç”¨ DuckDuckGo æœç´¢ webã€‚è¯¥ä»£ç†å°†èƒ½å¤Ÿé€šè¿‡æ£€ç´¢ç›¸å…³ä¿¡æ¯å’Œç»¼åˆå“åº”æ¥å›ç­”é—®é¢˜ã€‚\nfrom smolagents import CodeAgent, DuckDuckGoSearchTool, HfApiModel# Initialize the search toolsearch_tool = DuckDuckGoSearchTool()# Initialize the modelmodel = HfApiModel()agent = CodeAgent(    model = model,    tools=[search_tool])# Example usageresponse = agent.run(    &quot;What are the latest developments in fusion energy?&quot;)print(response)\n\nä¸Šè¿°ä»£ç å°†ï¼š\n\nåˆ†ææŸ¥è¯¢ä»¥ç¡®å®šéœ€è¦å“ªäº›ä¿¡æ¯\nä½¿ç”¨ DuckDuckGo æœç´¢ç›¸å…³å†…å®¹\nå°†æ£€ç´¢åˆ°çš„ä¿¡æ¯åˆæˆä¸ºè¿è´¯çš„å“åº”\nå°†äº¤äº’å­˜å‚¨åœ¨å†…å­˜ä¸­ä»¥ä¾›å°†æ¥å‚è€ƒ\n\næ³¨æ„ï¼š\n\nHfApiModel()ï¼šåˆ›å»ºä¸€ä¸ªåŸºäº HuggingFace æ¨¡å‹ API çš„è¯­è¨€æ¨¡å‹å®ä¾‹ã€‚HfApiModel() å¯èƒ½é»˜è®¤ä½¿ç”¨ä¸€ä¸ªå¼€æºæ¨¡å‹ï¼Œå®é™…éƒ¨ç½²æ—¶å¯é…ç½®æ¨¡å‹åã€token ç­‰ã€‚\nCodeAgent()ï¼šæ„é€ ä¸€ä¸ª CodeAgent å®ä¾‹ï¼Œå®ƒæ‹¥æœ‰ï¼š\nä¸€ä¸ªè¯­è¨€æ¨¡å‹ï¼ˆmodelï¼‰ï¼Œç”¨äºç†è§£æŒ‡ä»¤ã€ç”Ÿæˆæ–‡æœ¬ï¼›\nä¸€ä¸ªå·¥å…·åˆ—è¡¨ï¼ˆtoolsï¼‰ï¼Œå…¶ä¸­åŒ…æ‹¬ç½‘ç»œæœç´¢åŠŸèƒ½ã€‚\n\n\n\nCustom Knowledge Base Toolå¯¹äºç‰¹å®šé¢†åŸŸçš„åº”ç”¨ç¨‹åºï¼Œæˆ‘ä»¬é€šå¸¸å¸Œæœ›å°† web æœç´¢ä¸æˆ‘ä»¬è‡ªå·±çš„çŸ¥è¯†åº“ç»“åˆèµ·æ¥ã€‚è®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªå¯ä»¥æŸ¥è¯¢æŠ€æœ¯æ–‡æ¡£çŸ¢é‡æ•°æ®åº“çš„è‡ªå®šä¹‰å·¥å…·ã€‚\nfrom smolagents import Toolclass RetrieverTool(Tool):    name = &quot;retriever&quot;    description = &quot;Uses semantic search to retrieve the parts of transformers documentation that could be most relevant to answer your query.&quot;    inputs = &#123;        &quot;query&quot;: &#123;            &quot;type&quot;: &quot;string&quot;,            &quot;description&quot;: &quot;The query to perform. This should be semantically close to your target documents. Use the affirmative form rather than a question.&quot;,        &#125;    &#125;    output_type = &quot;string&quot;    def __init__(self, docs, **kwargs):        super().__init__(**kwargs)        self.retriever = BM25Retriever.from_documents(            docs, k=10        )    def forward(self, query: str) -&gt; str:        assert isinstance(query, str), &quot;Your search query must be a string&quot;        docs = self.retriever.invoke(            query,        )        return &quot;\\nRetrieved documents:\\n&quot; + &quot;&quot;.join(            [                f&quot;\\n\\n===== Document &#123;str(i)&#125; =====\\n&quot; + doc.page_content                for i, doc in enumerate(docs)            ]        )retriever_tool = RetrieverTool(docs_processed)\n\n\nä¸Šè¿°ä»£ç ç»§æ‰¿è‡ª smolagents.Toolï¼Œä»£è¡¨è¿™æ˜¯ä¸€ä¸ªå¯ä¾›æ™ºèƒ½ä½“ (Agent) è°ƒç”¨çš„å·¥å…·ã€‚\nåˆå§‹åŒ–æ–¹æ³•ä¸­\næ¥æ”¶ä¸€ä¸ªé¢„å¤„ç†å¥½çš„æ–‡æ¡£åˆ—è¡¨ docs\nBM25Retriever.from_documents(â€¦)ï¼šæ„å»ºä¸€ä¸ª BM25 æ£€ç´¢å™¨ï¼Œä» docs ä¸­æ„é€ å€’æ’ç´¢å¼•ï¼ˆç”¨äºåŸºäºå…³é”®è¯çš„ç›¸å…³æ€§æ£€ç´¢ï¼‰ã€‚\n\n\nforward() æ–¹æ³•ï¼š\næ˜¯å·¥å…·çš„ä¸»å…¥å£ï¼Œç”¨äºæ¥æ”¶ queryã€æ‰§è¡Œæ£€ç´¢å¹¶è¿”å›å­—ç¬¦ä¸²æ ¼å¼çš„ç»“æœã€‚\nè°ƒç”¨ self.retriever.invoke(query) è¿”å› top-k ä¸ªæ–‡æ¡£ã€‚\næœ€åå°†æ¯ä¸ªæ–‡æ¡£å†…å®¹æ‹¼æ¥æˆå­—ç¬¦ä¸²è¾“å‡º\n\n\n\nEnhanced Retrieval Capabilitieså½“æ„å»ºè‡ªä¸»æ€§æ£€ç´¢å¢å¼ºç”Ÿæˆï¼ˆRAGï¼‰ç³»ç»Ÿæ—¶ï¼Œæ™ºèƒ½ä½“è¿˜å¯ä»¥å€Ÿé‰´ä»¥ä¸‹å¤æ‚ç­–ç•¥ï¼š\n\næŸ¥è¯¢é‡æ„ï¼šæ™ºèƒ½ä½“å¹¶éç›´æ¥ä½¿ç”¨ç”¨æˆ·çš„åŸå§‹æŸ¥è¯¢ï¼Œè€Œæ˜¯ç²¾å¿ƒè®¾è®¡ä¼˜åŒ–åçš„æœç´¢è¯ï¼Œä½¿å…¶ä¸ç›®æ ‡æ–‡æ¡£æ›´åŒ¹é…ã€‚\nå¤šæ­¥æ£€ç´¢ï¼šæ™ºèƒ½ä½“å¯ä»¥æ‰§è¡Œå¤šæ¬¡æœç´¢ï¼Œä¾æ®åˆå§‹æ£€ç´¢ç»“æœæ¥è°ƒæ•´åç»­çš„æŸ¥è¯¢ã€‚\næ¥æºæ•´åˆï¼šæ•´åˆæ¥è‡ªå¤šä¸ªæ¸ é“çš„ä¿¡æ¯ï¼Œå¦‚ç½‘é¡µæœç´¢å’Œæœ¬åœ°æ–‡æ¡£ã€‚\nç»“æœéªŒè¯ï¼šåœ¨å°†æ£€ç´¢åˆ°çš„å†…å®¹çº³å…¥å›å¤ä¹‹å‰ï¼Œä¼šå¯¹å…¶ç›¸å…³æ€§å’Œå‡†ç¡®æ€§è¿›è¡Œåˆ†æã€‚\n\nCode Agentsä»£ç ä»£ç†é€šè¿‡è‡ªåŠ¨åŒ–é‡å¤ä»»åŠ¡æ¥åŠ é€Ÿå¼€å‘ï¼ŒåŒæ—¶ä¿æŒä»£ç è´¨é‡ã€‚ä»–ä»¬æ“…é•¿ç”Ÿæˆæ ·æ¿ä»£ç ã€æ‰§è¡Œç³»ç»Ÿé‡æ„ä»¥åŠé€šè¿‡é™æ€åˆ†æè¯†åˆ«æ½œåœ¨é—®é¢˜ã€‚ä»£ç†å°†è®¿é—®å¤–éƒ¨æ–‡æ¡£å’Œå­˜å‚¨åº“çš„æ£€ç´¢åŠŸèƒ½ä¸å‡½æ•°è°ƒç”¨ç›¸ç»“åˆï¼Œä»¥æ‰§è¡Œåˆ›å»ºæ–‡ä»¶æˆ–è¿è¡Œæµ‹è¯•ç­‰å…·ä½“æ“ä½œã€‚\nåœ¨ä»¥ä¸‹ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªä»£ç æ™ºèƒ½ä½“ï¼Œå®ƒèƒ½å¤Ÿè·å–ä¸¤ä¸ªä½ç½®ä¹‹é—´çš„è¿åŠ¨æ—¶é—´ã€‚è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨ @tool è£…é¥°å™¨æ¥å®šä¹‰ä¸€ä¸ªå¯ç”¨ä½œå·¥å…·çš„è‡ªå®šä¹‰å‡½æ•°ã€‚\nfrom smolagents import CodeAgent, HfApiModel, tool@tooldef get_travel_duration(start_location: str, destination_location: str, departure_time: Optional[int] = None) -&gt; str:    &quot;&quot;&quot;Gets the travel time in car between two places.        Args:        start_location: the place from which you start your ride        destination_location: the place of arrival        departure_time: the departure time, provide only a `datetime.datetime` if you want to specify this    &quot;&quot;&quot;    import googlemaps # All imports are placed within the function, to allow for sharing to Hub.    import os    gmaps = googlemaps.Client(os.getenv(&quot;GMAPS_API_KEY&quot;))    if departure_time is None:        from datetime import datetime        departure_time = datetime(2025, 1, 6, 11, 0)    directions_result = gmaps.directions(        start_location,        destination_location,        mode=&quot;transit&quot;,        departure_time=departure_time    )    return directions_result[0][&quot;legs&quot;][0][&quot;duration&quot;][&quot;text&quot;]agent = CodeAgent(tools=[get_travel_duration], model=HfApiModel(), additional_authorized_imports=[&quot;datetime&quot;])agent.run(&quot;Can you give me a nice one-day trip around Paris with a few locations and the times? Could be in the city or outside, but should fit in one day. I&#x27;m travelling only via public transportation.&quot;)\n\nCustom Function Agentsè‡ªå®šä¹‰å‡½æ•°æ™ºèƒ½ä½“æ˜¯ä¸€ç±»å€ŸåŠ©ä¸“é—¨çš„å‡½æ•°è°ƒç”¨ï¼ˆæˆ–ç§°ä¸º toolsï¼‰æ¥æ‰§è¡Œä»»åŠ¡çš„äººå·¥æ™ºèƒ½æ™ºèƒ½ä½“ã€‚ä¸é€šç”¨æ™ºèƒ½ä½“ä¸åŒï¼Œè‡ªå®šä¹‰å‡½æ•°æ™ºèƒ½ä½“ä¸“æ³¨äºé€šè¿‡ç›´æ¥ä¸åº”ç”¨ç¨‹åºçš„é€»è¾‘ç›¸é›†æˆï¼Œä¸ºé«˜çº§å·¥ä½œæµç¨‹æä¾›æ”¯æŒã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥å°†æ•°æ®åº“æŸ¥è¯¢ã€ç³»ç»Ÿå‘½ä»¤æˆ–ä»»ä½•è‡ªå®šä¹‰å®ç”¨ç¨‹åºä½œä¸ºç‹¬ç«‹å‡½æ•°å¼€æ”¾ï¼Œä»¥ä¾›æ™ºèƒ½ä½“è°ƒç”¨ã€‚\n","categories":["LLM"],"tags":["trl","smol"]},{"title":"ã€ML2025ã€‘1-ç”Ÿæˆå¼äººå·¥æ™ºèƒ½","url":"/blog/ML2025/gen-AI/","content":"\næå®æ¯…è€å¸ˆã€Šæœºå™¨å­¦ä¹ ã€‹2025å­¦ä¹ è®°å½•\n\n\nç”Ÿæˆå¼äººå·¥æ™ºèƒ½æœ‰ä»€ä¹ˆæ ·çš„è¡Œä¸ºï¼Ÿ\nç°æœ‰çš„æ¨¡å‹é€šå¸¸ä¼šä½“ç°â€œæ€è€ƒâ€çš„è¿‡ç¨‹ï¼ˆè„‘å†…å°å‰§åœºï¼Ÿï¼Ÿï¼‰ã€‚\næœªæ¥ AI çš„å·¥ä½œä¸å†å±€é™äºâ€œä¸€é—®ä¸€ç­”â€ï¼Œå¾ˆå¤šä»»åŠ¡éœ€è¦å¤šä¸ªæ­¥éª¤æ¥å®Œæˆ â€“&gt; AI agent\nä½¿ç”¨ AI agent æ¥è®­ç»ƒæ¨¡å‹ï¼Ÿï¼Ÿ\n\nè¿ä½œæœºåˆ¶\nç”Ÿæˆå¼äººå·¥æ™ºèƒ½çš„åŸºæœ¬åŸç†ï¼šè¾“å…¥ä¸€æ®µ tokenï¼Œè¾“å‡ºå¦ä¸€æ®µ tokenã€‚ä»»ä½•äº‹ç‰©éƒ½å¯ä»¥ç”±å¤šä¸ª token è¡¨ç¤ºï¼š\nThose tokens were words, some of the tokens of course could now be images, or charts, or tables, songs â€¦ speech, videos. Those tokens could be anything.Â token å¯ä»¥æ˜¯å•è¯ï¼Œå›¾ç‰‡ã€è¡¨ã€æ­Œæ›²ã€å¯¹è¯ç­‰ç­‰â€¦â€¦\n\n\n\n\n\nä¸è®ºä»€ä¹ˆä»»åŠ¡ï¼Œæœ¬è´¨ä¸Šéƒ½æ˜¯ token åˆ° tokenã€‚\n\nå…·ä½“æ¥è¯´ï¼Œæ˜¯ç»™è¾“å…¥ token åºåˆ—ï¼Œé¢„æµ‹ä¸‹ä¸€ä¸ª tokenã€‚\nç„¶åå°†é¢„æµ‹çš„ token ä¸è¾“å…¥çš„ token åºåˆ—æ‹¼æ¥ï¼Œç„¶åå†æ¬¡è¾“å…¥åˆ°æ¨¡å‹ä¸­ï¼Œé¢„æµ‹ä¸‹ä¸€ä¸ª tokenï¼Œé‡å¤ä¸Šè¿°æ­¥éª¤ï¼Œç›´åˆ°ç»“æŸã€‚\n\n\nä¾‹å¦‚ï¼Œè¾“å…¥å›¾åƒï¼Œè¾“å‡ºæ–‡å­—ï¼Œé‚£ä¹ˆ z å°±ä»£è¡¨æ‰€æœ‰æ–‡å­— token å’Œå›¾åƒ token çš„é›†åˆ\n\né€šå¸¸æ˜¯ä½¿ç”¨æ·±åº¦ç½‘ç»œæ¥é¢„æµ‹ä¸‹ä¸€ä¸ª tokenã€‚ä¸€ä¸ªä¸æ°å½“çš„æ¯”å–»ï¼Œå‡è®¾ä»»åŠ¡ä¸ºä¸‰ä¸ªæ•°å­—ç›¸åŠ ï¼Œæ¯ä¸€ä¸ªå±‚ä¸ºä¸€ä¸ªæŸ¥è¡¨æ“ä½œï¼Œå¦‚æœåªç”¨ä¸€ä¸ªå±‚ï¼Œé‚£ä¹ˆéœ€è¦å­˜10^3ç§å¯èƒ½ï¼Œå¦‚æœåˆ†ä¸ºä¸¤å±‚ï¼Œé‚£ä¹ˆåªéœ€è¦10*10+19*10ç§å¯èƒ½ã€‚\n\næœ¬è´¨ä¸Šï¼Œè®©æ¨¡å‹â€œæ€è€ƒâ€ï¼ˆreasonï¼‰ä¹Ÿæ˜¯ä¸€ç§â€œæ·±åº¦â€ã€‚\n\nå›°éš¾çš„é—®é¢˜éœ€è¦æ€è€ƒå¾ˆå¤šæ­¥ï¼Œlayer çš„æ·±åº¦ä¸å¤Ÿäº†ï¼Ÿ\næ·±åº¦ä¸å¤Ÿï¼Œé•¿åº¦æ¥å‡‘ï¼\n\n\n\nå†…å®¹æ˜¯æ€æ ·äº§ç”Ÿå‡ºæ¥çš„ï¼Ÿ\næˆ‘ä»¬è¦æ€æ ·å¾—åˆ°å¯ä»¥ç”Ÿæˆå†…å®¹çš„æ¨¡å‹ï¼Ÿä¸‰æ­¥èµ°ï¼\nFind Function with Unknown Parameters\nDefine Loss from Training Data\nOptimation\n\n\nç”Ÿæˆå¼æ¨¡å‹ä¹Ÿä¸æ˜¯æ–°çš„é—®é¢˜ï¼šä»â€œä¸“æ‰â€åˆ°â€œé€šæ‰â€çš„è½¬å˜\nå¦‚ä½•å®ç°è¿™ä¸ªè½¬å˜ï¼Ÿå¤§æ¦‚åŒ…å«ä»¥ä¸‹ä¸‰ä¸ªé˜¶æ®µ\né˜¶æ®µä¸€ï¼šè®­ç»ƒé€šç”¨çš„ç¼–ç å™¨ï¼Œåªèƒ½å°†è¾“å…¥ token è½¬æ¢ä¸º embeddingï¼Œè¦å®ç°ä¸‹æ¸¸ä»»åŠ¡ï¼Œéœ€è¦æ¥å¯¹åº”çš„è§£ç å™¨ã€‚  \né˜¶æ®µäºŒï¼šæ²¡é‚£ä¹ˆå¥½ç”¨çš„æ¨¡å‹ï¼Œåªèƒ½ç”Ÿæˆ tokenï¼Œéœ€è¦åœ¨ç‰¹å®šä»»åŠ¡ä¸Šå¾®è°ƒï¼ˆç›¸åŒæ¶æ„ï¼Œä¸åŒçš„å‚æ•°ï¼‰  \né˜¶æ®µä¸‰ï¼šå¤§æ¨¡å‹æ—¶ä»£ï¼ä¸€ä¸ªæ¨¡å‹å¯ä»¥è§£å†³æ‰€æœ‰çš„é—®é¢˜ï¼ˆç›¸åŒæ¶æ„ï¼Œç›¸åŒå‚æ•°ï¼‰  \n\n\n\nå¦‚ä½•èµ‹äºˆæ¨¡å‹æ–°çš„èƒ½åŠ›ï¼Ÿ\næ–¹æ³•1ï¼šå¾®è°ƒ\n\næ–¹æ³•2ï¼šæ¨¡å‹ç¼–è¾‘\n\næ–¹æ³•3ï¼šæ¨¡å‹åˆå¹¶\n\n\n","categories":["ML2025"],"tags":["ML"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘æ•°ç»„1-äºŒåˆ†æŸ¥æ‰¾","url":"/blog/Leetcode/array1/","content":"åŸºæœ¬çŸ¥è¯†\næ•°ç»„å…ƒç´ æŒ‰ç…§é¡ºåºæ’åˆ—\næ•°ç»„å…ƒç´ æ— æ³•åˆ é™¤ï¼Œåªèƒ½æ›¿ä»£ï¼ˆå¡«å……ï¼‰\npython ä¸­ï¼Œä½¿ç”¨ listï¼Œä»£ç ä¸­ List æ˜¯ç±»å‹æ³¨è§£ä¸­çš„ä¸€ç§è¡¨ç¤ºæ–¹å¼ï¼Œé€šå¸¸å‡ºç°åœ¨ç±»å‹æç¤ºä¸­ã€‚python 3.9 ä¹‹åå¯ä»¥ä½¿ç”¨å†…ç½®çš„ list æ¥æ›¿ä»£ Listã€‚\n\n704. äºŒåˆ†æŸ¥æ‰¾\né¢˜ç›®é“¾æ¥ link\n\nç»™å®šä¸€ä¸ª n ä¸ªå…ƒç´ æœ‰åºçš„ï¼ˆå‡åºï¼‰æ•´å‹æ•°ç»„ nums å’Œä¸€ä¸ªç›®æ ‡å€¼ target  ï¼Œå†™ä¸€ä¸ªå‡½æ•°æœç´¢ nums ä¸­çš„ targetï¼Œå¦‚æœç›®æ ‡å€¼å­˜åœ¨è¿”å›ä¸‹æ ‡ï¼Œå¦åˆ™è¿”å› -1ã€‚\n\nè¾“å…¥: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9è¾“å‡º: 4è§£é‡Š: 9 å‡ºç°åœ¨ nums ä¸­å¹¶ä¸”ä¸‹æ ‡ä¸º 4     \n\nä¸¤ä¸ªè¦ç‚¹\næ•°ç»„ä¸­å…ƒç´ æŒ‰ç…§é¡ºåºæ’åˆ—\næ— é‡å¤çš„æ•°å­—ï¼ˆå¦åˆ™å…ƒç´ ä¸‹æ ‡ä¸å”¯ä¸€ï¼‰\nå¦‚æœæœ‰é‡å¤çš„æ•°å­—ï¼Œè¦æ±‚è¿”å›æœ€å°çš„é‚£ä¸ªå‘¢ï¼Ÿ\n\n\n\nè§£æ³•\nåŒºé—´å®šä¹‰ï¼šå®šä¹‰ target æ‰€åœ¨çš„åŒºé—´æ˜¯å·¦é—­å³å¼€è¿˜æ˜¯å·¦å³å…¨é—­\næ ¸å¿ƒï¼šå°†æ•°ç»„åˆ†å‰²ä¸ºä¸‰ä¸ªéƒ¨åˆ†\nå·¦å³å…¨é—­ï¼š[0, middle-1] , middle, [middle + 1, len - 1] æˆ–è€…\nå·¦å¼€å³é—­ï¼š[0, middle) , middle, [middle + 1, len)\n\n\n\nå·¦å³å…¨é—­\nåŒºé—´ä¸º [left, right]ï¼š\nå®šä¹‰ right ä¸º len(nums) - 1ï¼Œå› ä¸º right è¦æœ‰å«ä¹‰\nå¾ªç¯æ¡ä»¶ while(left &lt;&#x3D; right) ï¼Œå› ä¸ºleft &#x3D;&#x3D; rightæ˜¯æœ‰æ„ä¹‰çš„\nåˆ¤æ–­æ¡ä»¶ï¼Œè‹¥ middle å¤§äº target ï¼Œåˆ™éå†å·¦åŒºé—´ï¼Œè®¾ç½® right &#x3D; middle - 1ï¼Œå› ä¸ºæ­¤æ—¶ä¸ºå³é—­åŒºé—´ï¼Œä¸ä¼šå†è®¿é—® middleï¼›åŒç†ï¼Œè‹¥ middle å°äº targetï¼Œåˆ™éå†å³è¾¹åŒºé—´ï¼Œè®¾ç½® left &#x3D; middle + 1ï¼ŒåŒæ ·å› ä¸ºæ˜¯é—­åŒºé—´ï¼Œä¸ä¼šå†è®¿é—® middleã€‚\n\n\nä»£ç ï¼šclass Solution:    def search(self, nums: List[int], target: int) -&gt; int:        left = 0        right = len(nums) - 1        while left &lt;= right:            middle = int((left + right) / 2)            if nums[middle] &gt; target:                right = middle - 1            elif nums[middle] &lt; target:                left = middle + 1            else:                return middle        return -1        \n\nå·¦é—­å³å¼€\nåŒºé—´ä¸º [left, right)ï¼š\n\nå®šä¹‰ right ä¸º len(nums)ï¼Œå› ä¸ºä¸ä¼šè®¿é—® rightï¼Œæ‰€ä»¥è®¾ç½®ä¸ºåŒºé—´é•¿åº¦\nå¾ªç¯æ¡ä»¶ while(left &lt; right) ï¼Œå› ä¸ºleft &#x3D;&#x3D; rightæ²¡æœ‰æ„ä¹‰ï¼ˆå³è¾¹ä¸ºå¼€åŒºé—´ï¼‰\nåˆ¤æ–­æ¡ä»¶ï¼Œè‹¥ middle å¤§äº target ï¼Œåˆ™éå†å·¦åŒºé—´ï¼Œè®¾ç½® right &#x3D; middleï¼Œå› ä¸ºæ­¤æ—¶ä¸ºå³å¼€åŒºé—´ï¼Œè®¾ç½® right&#x3D;middle å®é™…ä¸Šä¸‹ä¸€æ¬¡ä¼šè®¿é—® middle - 1 ã€‚\n\n\nä»£ç ï¼š\nclass Solution:    def search(self, nums: List[int], target: int) -&gt; int:        left = 0        right = len(nums)        while left &lt; right:            middle = int((left + right) / 2)            if nums[middle] &gt; target:                right = middle            elif nums[middle] &lt; target:                left = middle + 1            else:                return middle        return -1 \n\nç›¸å…³é¢˜ç›®1ï¼š35. æœç´¢æ’å…¥ä½ç½®\né¢˜ç›®é“¾æ¥ link\n\nç»™å®šä¸€ä¸ªæ’åºæ•°ç»„å’Œä¸€ä¸ªç›®æ ‡å€¼ï¼Œåœ¨æ•°ç»„ä¸­æ‰¾åˆ°ç›®æ ‡å€¼ï¼Œå¹¶è¿”å›å…¶ç´¢å¼•ã€‚å¦‚æœç›®æ ‡å€¼ä¸å­˜åœ¨äºæ•°ç»„ä¸­ï¼Œè¿”å›å®ƒå°†ä¼šè¢«æŒ‰é¡ºåºæ’å…¥çš„ä½ç½®ã€‚\nä½ å¯ä»¥å‡è®¾æ•°ç»„ä¸­æ— é‡å¤å…ƒç´ ã€‚\nè¦ç‚¹\næ— é‡å¤å…ƒç´  + å‡åºæ’åˆ—ï¼Œè€ƒè™‘äºŒåˆ†æŸ¥æ‰¾\n\nè¿™é“é¢˜ç›¸è¾ƒäºäºŒåˆ†æŸ¥æ‰¾ï¼Œåªæ˜¯å¤šäº†ä¸€ä¸ª target ä¸å­˜åœ¨çš„æƒ…å†µï¼Œåœ¨è¿™ä¸ªæƒ…å†µä¸‹ï¼Œä¸€å®šæ»¡è¶³ left &#x3D;&#x3D; right + 1 ï¼ˆå·¦å³éƒ½ä¸ºé—­åŒºé—´çš„æƒ…å†µï¼‰\n\nå› ä¸ºï¼Œåœ¨å¾ªç¯çš„æœ€åä¸€è½®ï¼Œæ»¡è¶³ left &#x3D;&#x3D; rightï¼Œæ­¤æ—¶ åªå‰©ä¸‹æœ€åä¸€ä¸ªæ•°å­—ï¼Œmiddle ä¹Ÿä¸º left ï¼ˆrightï¼‰ã€‚æ­¤æ—¶è‹¥ middle æ•°å°äº targetï¼Œåˆ™ left + 1ï¼Œåä¹‹åˆ™ right - 1ã€‚\nåŸºäºè¿™ä¸ªåŸç†ï¼Œè‹¥ middle æ•°å°äº targetï¼Œtarget åº”è¯¥æ”¾åœ¨ middle + 1 ä¸Šï¼Œè‹¥ middle æ•°å¤§äº targetï¼Œåˆ™ target åº”è¯¥æ”¾åœ¨ middle ä¸Š\nå¯¹æ¯”ä¸Šè¿°ä¸¤æ¡ï¼Œå¯ä»¥å‘ç°ï¼š\nmiddle æ•°å°äº targetï¼Œleft + 1ï¼Œæ”¾åœ¨ middle + 1çš„ä½ç½®\nmiddle æ•°å¤§äº targetï¼Œ right - 1, middle ä¸å˜ï¼Œæ”¾åœ¨ middle çš„ä½ç½®\nmiddle çš„å˜åŒ–å’Œ left ç›¸åŒï¼Œå³å°äºæ—¶åŠ 1ï¼Œå¤§äºæ—¶ä¸å˜ï¼Œè€Œæœ€åä¸€è½®å¾ªç¯æ—¶ middleã€leftã€right å‡ç›¸åŒï¼Œåˆ™æœ€åçš„ç»“æœä¸€å®šä¸º leftã€‚\n\n\n\n\nä»£ç å¦‚ä¸‹ï¼Œåªéœ€å°†äºŒåˆ†æŸ¥æ‰¾çš„ä»£ç çš„æœ€åä¸€è¡Œï¼Œæ”¹ä¸º return left å³å¯\nclass Solution:    def search(self, nums: List[int], target: int) -&gt; int:        left = 0        right = len(nums) - 1        while left &lt;= right:            middle = int((left + right) / 2)            if nums[middle] &gt; target:                right = middle - 1            elif nums[middle] &lt; target:                left = middle + 1            else:                return middle        return left\n\nç›¸å…³é¢˜ç›®2ï¼š34. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®\né¢˜ç›®é“¾æ¥ linkç»™å®šä¸€ä¸ªæŒ‰ç…§å‡åºæ’åˆ—çš„æ•´æ•°æ•°ç»„ numsï¼Œå’Œä¸€ä¸ªç›®æ ‡å€¼ targetã€‚æ‰¾å‡ºç»™å®šç›®æ ‡å€¼åœ¨æ•°ç»„ä¸­çš„å¼€å§‹ä½ç½®å’Œç»“æŸä½ç½®ã€‚\n\nå¦‚æœæ•°ç»„ä¸­ä¸å­˜åœ¨ç›®æ ‡å€¼ targetï¼Œè¿”å› [-1, -1]ã€‚\nè¿›é˜¶ï¼šä½ å¯ä»¥è®¾è®¡å¹¶å®ç°æ—¶é—´å¤æ‚åº¦ä¸º $O(\\log n)$ çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜å—ï¼Ÿ\nç¤ºä¾‹ 1ï¼š\n\nè¾“å…¥ï¼šnums &#x3D; [5,7,7,8,8,10], target &#x3D; 8è¾“å‡ºï¼š[3,4]\n\nç¤ºä¾‹ 2ï¼š\n\nè¾“å…¥ï¼šnums &#x3D; [5,7,7,8,8,10], target &#x3D; 6è¾“å‡ºï¼š[-1,-1]\n\nç¤ºä¾‹ 3ï¼š\n\nè¾“å…¥ï¼šnums &#x3D; [], target &#x3D; 0è¾“å‡ºï¼š[-1,-1]\n\næ€è·¯\nç›¸ä¼¼äºäºŒåˆ†æŸ¥æ‰¾ï¼Œåˆ†åˆ«æ‰¾å·¦è¾¹ç•Œå’Œå³è¾¹ç•Œï¼Œæ‰¾åˆ°ä¸€ä¸ªç›®æ ‡å\nè‹¥è¦æ‰¾å·¦è¾¹ç•Œï¼Œåˆ™åœ¨æ‰¾åˆ°çš„ç›®æ ‡çš„å·¦è¾¹æ•°ç»„ä¸­å†æ¬¡æŸ¥æ‰¾ï¼Œright &#x3D; middle - 1ã€‚å³è®¤ä¸ºå½“å‰æ‰¾åˆ°çš„æ•°æ¯”å®é™…çš„ target å¤§ã€‚\nç›¸ä¼¼çš„ï¼Œè‹¥è¦æ‰¾å³è¾¹ç•Œï¼Œåˆ™åœ¨æ‰¾åˆ°çš„ç›®æ ‡çš„å³è¾¹æ•°ç»„ä¸­å†æ¬¡æŸ¥æ‰¾ï¼Œleft &#x3D; middle + 1ã€‚å³è®¤ä¸ºå½“å‰æ‰¾åˆ°çš„æ•°æ¯”å®é™…çš„ target å°ã€‚class Solution:    def searchRange(self, nums: List[int], target: int) -&gt; int:                leftb = mySearch(nums, target, True)        rightb = mySearch(nums, target, False)        def mySearch(nums: List[int], target: int, side: bool):            left = 0            right = len(nums) - 1            res = -1            while left &lt;= right:                middle = int((left + right) / 2)                if nums[middle] &gt; target:                    right = middle - 1                elif nums[middle] &lt; target:                    left = middle + 1                else:                    res = middle                    if side:                        # å·¦è¾¹ç•Œ                        right = middle - 1                    else:                        left = middle + 1            return res        return [leftb, rightb]\n\n\n\nç›¸å…³é¢˜ç›®3ï¼š367. æœ‰æ•ˆçš„å®Œå…¨å¹³æ–¹æ•°\né¢˜ç›®é“¾æ¥ linkç»™ä½ ä¸€ä¸ªéè´Ÿæ•´æ•° x ï¼Œè®¡ç®—å¹¶è¿”å› x çš„ ç®—æœ¯å¹³æ–¹æ ¹ ã€‚\n\nç”±äºè¿”å›ç±»å‹æ˜¯æ•´æ•°ï¼Œç»“æœåªä¿ç•™ æ•´æ•°éƒ¨åˆ† ï¼Œå°æ•°éƒ¨åˆ†å°†è¢« èˆå» ã€‚\næ³¨æ„ï¼šä¸å…è®¸ä½¿ç”¨ä»»ä½•å†…ç½®æŒ‡æ•°å‡½æ•°å’Œç®—ç¬¦ï¼Œä¾‹å¦‚ pow(x, 0.5) æˆ–è€… x ** 0.5 ã€‚\nç¤ºä¾‹ 1ï¼š\n\nè¾“å…¥ï¼šx &#x3D; 4è¾“å‡ºï¼š2\n\nç¤ºä¾‹ 2ï¼š\n\nè¾“å…¥ï¼šx &#x3D; 8è¾“å‡ºï¼š2è§£é‡Šï¼š8 çš„ç®—æœ¯å¹³æ–¹æ ¹æ˜¯ 2.82842â€¦, ç”±äºè¿”å›ç±»å‹æ˜¯æ•´æ•°ï¼Œå°æ•°éƒ¨åˆ†å°†è¢«èˆå»ã€‚\n\næ€è·¯\näºŒåˆ†æŸ¥æ‰¾ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªå¹³æ–¹ä¸å¤§äº x çš„æ•°å­—ã€‚class Solution:    def mySqrt(self, x: int) -&gt; int:        left = 0        right = x - 1        if x == 0: return 0        if x == 1: return 1        while left &lt;= right:            middle = int((left + right) / 2)            if middle * middle &gt; x:                right = middle - 1            elif middle * middle &lt; x:                left = middle + 1            else:                return middle        return right        \n\n","categories":["Leetcode"],"tags":["Array"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘æ•°ç»„2-åŒæŒ‡é’ˆæ³•","url":"/blog/Leetcode/array2/","content":"27. ç§»é™¤å…ƒç´ \né¢˜ç›®é“¾æ¥ link\n\nç»™ä½ ä¸€ä¸ªæ•°ç»„ nums å’Œä¸€ä¸ªå€¼ valï¼Œä½ éœ€è¦ åŸåœ° ç§»é™¤æ‰€æœ‰æ•°å€¼ç­‰äº val çš„å…ƒç´ ï¼Œå¹¶è¿”å›ç§»é™¤åæ•°ç»„çš„æ–°é•¿åº¦ã€‚\nä¸è¦ä½¿ç”¨é¢å¤–çš„æ•°ç»„ç©ºé—´ï¼Œä½ å¿…é¡»ä»…ä½¿ç”¨ O(1) é¢å¤–ç©ºé—´å¹¶åŸåœ°ä¿®æ”¹è¾“å…¥æ•°ç»„ã€‚\nå…ƒç´ çš„é¡ºåºå¯ä»¥æ”¹å˜ã€‚ä½ ä¸éœ€è¦è€ƒè™‘æ•°ç»„ä¸­è¶…å‡ºæ–°é•¿åº¦åé¢çš„å…ƒç´ ã€‚\nç¤ºä¾‹ 1: \n\nç»™å®š nums &#x3D; [3,2,2,3], val &#x3D; 3, å‡½æ•°åº”è¯¥è¿”å›æ–°çš„é•¿åº¦ 2, å¹¶ä¸” nums ä¸­çš„å‰ä¸¤ä¸ªå…ƒç´ å‡ä¸º 2ã€‚ ä½ ä¸éœ€è¦è€ƒè™‘æ•°ç»„ä¸­è¶…å‡ºæ–°é•¿åº¦åé¢çš„å…ƒç´ ã€‚\n\nç¤ºä¾‹ 2: \n\nç»™å®š nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2, å‡½æ•°åº”è¯¥è¿”å›æ–°çš„é•¿åº¦ 5, å¹¶ä¸” nums ä¸­çš„å‰äº”ä¸ªå…ƒç´ ä¸º 0, 1, 3, 0, 4ã€‚\n\nä½ ä¸éœ€è¦è€ƒè™‘æ•°ç»„ä¸­è¶…å‡ºæ–°é•¿åº¦åé¢çš„å…ƒç´ ã€‚\næ³¨æ„ï¼šéœ€è¦æ”¹åŠ¨åŸæ¥çš„æ•°ç»„ï¼Œè™½ç„¶æ²¡æœ‰ç›´æ¥è¿”å›æ”¹åŠ¨åçš„æ•°ç»„\næš´åŠ›è§£æ³•ä¸¤ä¸ªå¾ªç¯ï¼Œåˆ†åˆ«ç”¨äºæŸ¥æ‰¾ val å’Œç§»åŠ¨åç»­å…ƒç´ ã€‚æ³¨æ„ç¬¬ä¸€ä¸ªå¾ªç¯è¦ç”¨ whileï¼Œå› ä¸ºç§»åŠ¨åç»­å…ƒç´ æ—¶å‡å°‘äº†ä¸€ä½ï¼Œfor å¾ªç¯æ— æ³•æ§åˆ¶å˜é‡ iã€‚\nclass Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        size = len(nums)        i = 0        while i &lt; size:            if nums[i] == val:                for j in range(i+1, size):                    nums[j-1] = nums[j]                size -= 1                i -= 1            i += 1        return size\n\nåŒæŒ‡é’ˆæ³•åŒæŒ‡é’ˆæ³•ï¼ˆå¿«æ…¢æŒ‡é’ˆæ³•ï¼‰ï¼š é€šè¿‡ä¸€ä¸ªå¿«æŒ‡é’ˆå’Œæ…¢æŒ‡é’ˆåœ¨ä¸€ä¸ªforå¾ªç¯ä¸‹å®Œæˆä¸¤ä¸ªforå¾ªç¯çš„å·¥ä½œã€‚æœ¬é¢˜ä¸­ï¼Œä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«ä»£è¡¨ï¼š\n\nå¿«æŒ‡é’ˆï¼šæŸ¥æ‰¾çš„ç´¢å¼•\næ…¢æŒ‡é’ˆï¼šæ›´æ”¹åçš„æ•°ç»„çš„ç´¢å¼•æ­¤å¤–ï¼Œæ¯ä¸€æ­¥éƒ½éœ€è¦æŠŠå¿«æŒ‡é’ˆçš„å€¼èµ‹å€¼ç»™æ…¢æŒ‡é’ˆï¼ˆæ— è®ºæ˜¯å¦é‡åˆ°ç­‰äºï¼‰class Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        size = len(nums)        fast, slow = 0, 0        while fast &lt; size:            nums[slow] = nums[fast]            if nums[fast] == val:                slow -= 1            fast += 1            slow += 1                return slow\n\n26. åˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹\né¢˜ç›®é“¾æ¥ link\n\nç»™ä½ ä¸€ä¸ª éä¸¥æ ¼é€’å¢æ’åˆ— çš„æ•°ç»„ nums ï¼Œè¯·ä½  åŸåœ° åˆ é™¤é‡å¤å‡ºç°çš„å…ƒç´ ï¼Œä½¿æ¯ä¸ªå…ƒç´  åªå‡ºç°ä¸€æ¬¡ ï¼Œè¿”å›åˆ é™¤åæ•°ç»„çš„æ–°é•¿åº¦ã€‚å…ƒç´ çš„ ç›¸å¯¹é¡ºåº åº”è¯¥ä¿æŒ ä¸€è‡´ ã€‚ç„¶åè¿”å› nums ä¸­å”¯ä¸€å…ƒç´ çš„ä¸ªæ•°ã€‚\nè€ƒè™‘ nums çš„å”¯ä¸€å…ƒç´ çš„æ•°é‡ä¸º k ï¼Œä½ éœ€è¦åšä»¥ä¸‹äº‹æƒ…ç¡®ä¿ä½ çš„é¢˜è§£å¯ä»¥è¢«é€šè¿‡ï¼š\næ›´æ”¹æ•°ç»„ nums ï¼Œä½¿ nums çš„å‰ k ä¸ªå…ƒç´ åŒ…å«å”¯ä¸€å…ƒç´ ï¼Œå¹¶æŒ‰ç…§å®ƒä»¬æœ€åˆåœ¨ nums ä¸­å‡ºç°çš„é¡ºåºæ’åˆ—ã€‚nums çš„å…¶ä½™å…ƒç´ ä¸ nums çš„å¤§å°ä¸é‡è¦ã€‚è¿”å› k ã€‚\nç¤ºä¾‹ 1ï¼š\n\nè¾“å…¥ï¼šnums &#x3D; [1,1,2]è¾“å‡ºï¼š2, nums &#x3D; [1,2,_]è§£é‡Šï¼šå‡½æ•°åº”è¯¥è¿”å›æ–°çš„é•¿åº¦ 2 ï¼Œå¹¶ä¸”åŸæ•°ç»„ nums çš„å‰ä¸¤ä¸ªå…ƒç´ è¢«ä¿®æ”¹ä¸º 1, 2 ã€‚ä¸éœ€è¦è€ƒè™‘æ•°ç»„ä¸­è¶…å‡ºæ–°é•¿åº¦åé¢çš„å…ƒç´ ã€‚\n\nç¤ºä¾‹ 2ï¼š\n\nè¾“å…¥ï¼šnums &#x3D; [0,0,1,1,1,2,2,3,3,4]è¾“å‡ºï¼š5, nums &#x3D; [0,1,2,3,4]è§£é‡Šï¼šå‡½æ•°åº”è¯¥è¿”å›æ–°çš„é•¿åº¦ 5 ï¼Œ å¹¶ä¸”åŸæ•°ç»„ nums çš„å‰äº”ä¸ªå…ƒç´ è¢«ä¿®æ”¹ä¸º 0, 1, 2, 3, 4 ã€‚ä¸éœ€è¦è€ƒè™‘æ•°ç»„ä¸­è¶…å‡ºæ–°é•¿åº¦åé¢çš„å…ƒç´ ã€‚\n\næ€è·¯ä»ç„¶æ˜¯å¿«æ…¢æŒ‡é’ˆæ³•ï¼Œåªæ˜¯æ²¡æœ‰ç»™å®š valï¼Œéœ€è¦åœ¨å¾ªç¯ä¸­åŠ¨æ€æ›´æ–° valã€‚æ›´æ–° val çš„è§„åˆ™ä¸ºï¼Œå¦‚æœå½“å‰ fast å¯¹åº”çš„å€¼ä¸ç­‰äº valï¼Œåˆ™å°†å…¶èµ‹å€¼ç»™ valã€‚å› ä¸ºæ•°ç»„å‡åºæ’åˆ—ï¼Œç›¸åŒçš„æ•°å­—åœ¨ä¸€èµ·ï¼Œå¦‚æœ fast å¯¹åº”çš„å€¼å’Œ valï¼ˆä¸Šä¸€ä¸ªæ•°å­—ï¼‰ä¸ç›¸ç­‰ï¼Œè¯´æ˜ä¸Šä¸€ä¸ªæ•°å­—å·²ç»ä¸é‡å¤äº†ã€‚\nclass Solution:    def removeDuplicates(self, nums: List[int]) -&gt; int:        slow, fast = 0, 0        size = len(nums)        val = None               while fast &lt; size:            nums[slow] = nums[fast]            if val == nums[fast]:                slow -= 1            else:                val = nums[fast]            slow += 1            fast += 1        return slow\n283. ç§»åŠ¨é›¶\né¢˜ç›®é“¾æ¥ link\n\nç»™å®šä¸€ä¸ªæ•°ç»„ numsï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°å°†æ‰€æœ‰ 0 ç§»åŠ¨åˆ°æ•°ç»„çš„æœ«å°¾ï¼ŒåŒæ—¶ä¿æŒéé›¶å…ƒç´ çš„ç›¸å¯¹é¡ºåºã€‚\nè¯·æ³¨æ„ ï¼Œå¿…é¡»åœ¨ä¸å¤åˆ¶æ•°ç»„çš„æƒ…å†µä¸‹åŸåœ°å¯¹æ•°ç»„è¿›è¡Œæ“ä½œã€‚\nç¤ºä¾‹ 1:\n\nè¾“å…¥: nums &#x3D; [0,1,0,3,12]è¾“å‡º: [1,3,12,0,0]\n\nç¤ºä¾‹ 2:\n\nè¾“å…¥: nums &#x3D; [0]è¾“å‡º: [0]\n\næ€è·¯ç›¸å½“äºæ˜¯ val ä¸º 0 çš„åˆ é™¤å…ƒç´ ï¼ŒåŒæ ·ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆæ³•ï¼Œåªæ˜¯æœ€åéœ€è¦å°† [slow, fast) åŒºé—´å†…çš„å…ƒç´ èµ‹å€¼ä¸º 0ã€‚\nclass Solution:    def moveZeroes(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        slow, fast, size = 0, 0, len(nums)        while fast &lt; size:            nums[slow] = nums[fast]            if nums[fast] == 0:                slow -= 1            slow += 1            fast += 1                if fast != slow:            for i in range(slow, fast):                nums[i] = 0\n844. æ¯”è¾ƒå«é€€æ ¼çš„å­—ç¬¦ä¸²\né¢˜ç›®é“¾æ¥ link\n\nç»™å®š s å’Œ t ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œå½“å®ƒä»¬åˆ†åˆ«è¢«è¾“å…¥åˆ°ç©ºç™½çš„æ–‡æœ¬ç¼–è¾‘å™¨åï¼Œå¦‚æœä¸¤è€…ç›¸ç­‰ï¼Œè¿”å› true ã€‚# ä»£è¡¨é€€æ ¼å­—ç¬¦ã€‚\næ³¨æ„ï¼šå¦‚æœå¯¹ç©ºæ–‡æœ¬è¾“å…¥é€€æ ¼å­—ç¬¦ï¼Œæ–‡æœ¬ç»§ç»­ä¸ºç©ºã€‚\nç¤ºä¾‹ 1ï¼š\n\nè¾“å…¥ï¼šs &#x3D; â€œab#câ€, t &#x3D; â€œad#câ€è¾“å‡ºï¼štrueè§£é‡Šï¼šs å’Œ t éƒ½ä¼šå˜æˆ â€œacâ€ã€‚\n\nç¤ºä¾‹ 2ï¼š\n\nè¾“å…¥ï¼šs &#x3D; â€œab##â€, t &#x3D; â€œc#d#â€è¾“å‡ºï¼štrueè§£é‡Šï¼šs å’Œ t éƒ½ä¼šå˜æˆ â€œâ€ã€‚\n\nç¤ºä¾‹ 3ï¼š\n\nè¾“å…¥ï¼šs &#x3D; â€œa#câ€, t &#x3D; â€œbâ€è¾“å‡ºï¼šfalseè§£é‡Šï¼šs ä¼šå˜æˆ â€œcâ€ï¼Œä½† t ä»ç„¶æ˜¯ â€œbâ€ã€‚\n\næ€è·¯1åŒæŒ‡é’ˆæ³•ï¼Œç›¸å½“äºæ˜¯æŸ¥æ‰¾ â€œ#â€ å­—ç¬¦ï¼ŒæŸ¥æ‰¾åˆ°ä¹‹ååˆ é™¤ # ä»¥åŠå…¶ä¹‹å‰çš„å­—ç¬¦ã€‚æ³¨æ„è¦è€ƒè™‘ # ä¹‹å‰æ²¡æœ‰å­—ç¬¦çš„æƒ…å†µã€‚\nclass Solution:    def backspaceCompare(self, s: str, t: str) -&gt; bool:        def dele(nums: list):            slow, fast, size = 0, 0, len(nums)            while fast &lt; size:                nums[slow] = nums[fast]                if nums[fast] == &quot;#&quot;:                    if slow == 0:                        slow -= 1                    else:                        slow -= 2                                slow += 1                fast += 1            if slow &lt; 0:                return []            else:                return nums[0: slow]                s1 = dele(list(s))        t1 = dele(list(t))        s = &quot;&quot;.join(s1)        t = &quot;&quot;.join(t1)        if s == t:            return True        else:            return False\n\næ€è·¯2ä½¿ç”¨æ ˆçš„æ€æƒ³ï¼Œéå†åˆ° # å­—ç¬¦ï¼Œåˆ™å½“å‰æ ˆé¡¶çš„å­—ç¬¦ popã€‚æ³¨æ„ list çš„ pop æ–¹æ³•éœ€è¦ list ä¸ä¸ºç©ºï¼Œæ‰€ä»¥éœ€è¦è¿›è¡Œåˆ¤æ–­ã€‚\nclass Solution:    def backspaceCompare(self, s: str, t: str) -&gt; bool:        def dele(nums: list):            ret = list()            for i in nums:                                if i != &quot;#&quot;:                                        ret.append(i)                elif len(ret) != 0:                    ret.pop()                        return &quot;&quot;.join(ret)        s = dele(list(s))        t = dele(list(t))                if s == t:            return True        else:            return False\n\n977. æœ‰åºæ•°ç»„çš„å¹³æ–¹\né¢˜ç›®é“¾æ¥ linkç»™ä½ ä¸€ä¸ªæŒ‰ éé€’å‡é¡ºåº æ’åºçš„æ•´æ•°æ•°ç»„ numsï¼Œè¿”å› æ¯ä¸ªæ•°å­—çš„å¹³æ–¹ ç»„æˆçš„æ–°æ•°ç»„ï¼Œè¦æ±‚ä¹ŸæŒ‰ éé€’å‡é¡ºåº æ’åºã€‚\n\nç¤ºä¾‹ 1ï¼š\n\nè¾“å…¥ï¼šnums &#x3D; [-4,-1,0,3,10]è¾“å‡ºï¼š[0,1,9,16,100]è§£é‡Šï¼šå¹³æ–¹åï¼Œæ•°ç»„å˜ä¸º [16,1,0,9,100]æ’åºåï¼Œæ•°ç»„å˜ä¸º [0,1,9,16,100]\n\nç¤ºä¾‹ 2ï¼š\n\nè¾“å…¥ï¼šnums &#x3D; [-7,-3,2,3,11]è¾“å‡ºï¼š[4,9,9,49,121]\n\næ€è·¯åŒæŒ‡é’ˆæ³•ï¼Œå·¦å³åˆ†åˆ«ä¸¤ä¸ªæŒ‡é’ˆï¼Œä¾æ¬¡æ¯”è¾ƒå¤§å°ï¼Œç›´åˆ°å·¦æŒ‡é’ˆå¤§äºå³æŒ‡é’ˆã€‚æ³¨æ„ï¼Œè¿™é‡Œéœ€è¦è¿”å›æ–°çš„æ•°ç»„ï¼Œå’Œä¸Šé¢çš„é¢˜ç›®ä¸ä¸€æ ·ï¼Œæ‰€ä»¥å¯ä»¥æ–°å»ºæ•°ç»„ï¼Œä¸éœ€è¦åœ¨åŸæœ‰æ•°ç»„ä¸Šæ“ä½œã€‚\nclass Solution:    def sortedSquares(self, nums: List[int]) -&gt; List[int]:        left, right = 0, len(nums) - 1        new_nums = [0] * len(nums)        i = len(nums) - 1        while left &lt;= right:            if nums[left] * nums[left] &lt; nums[right] * nums[right]:                new_nums[i] = nums[right] * nums[right]                right -= 1            else:                new_nums[i] = nums[left] * nums[left]                left += 1            i -= 1        return new_nums        \n","categories":["Leetcode"],"tags":["Array"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘æ•°ç»„3-æ»‘åŠ¨çª—å£æ³•","url":"/blog/Leetcode/array3/","content":"209.é•¿åº¦æœ€å°çš„å­æ•°ç»„\né¢˜ç›®é“¾æ¥ linkç»™å®šä¸€ä¸ªå«æœ‰ n ä¸ªæ­£æ•´æ•°çš„æ•°ç»„å’Œä¸€ä¸ªæ­£æ•´æ•° target ã€‚\n\næ‰¾å‡ºè¯¥æ•°ç»„ä¸­æ»¡è¶³å…¶æ€»å’Œå¤§äºç­‰äº target çš„é•¿åº¦æœ€å°çš„ å­æ•°ç»„ [numsl, numsl+1, â€¦, numsr-1, numsr] ï¼Œå¹¶è¿”å›å…¶é•¿åº¦ã€‚å¦‚æœä¸å­˜åœ¨ç¬¦åˆæ¡ä»¶çš„å­æ•°ç»„ï¼Œè¿”å› 0 ã€‚\nç¤ºä¾‹ 1ï¼š\n\nè¾“å…¥ï¼štarget &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]è¾“å‡ºï¼š2è§£é‡Šï¼šå­æ•°ç»„ [4,3] æ˜¯è¯¥æ¡ä»¶ä¸‹çš„é•¿åº¦æœ€å°çš„å­æ•°ç»„ã€‚\n\nç¤ºä¾‹ 2ï¼š\n\nè¾“å…¥ï¼štarget &#x3D; 4, nums &#x3D; [1,4,4]è¾“å‡ºï¼š1\n\nç¤ºä¾‹ 3ï¼š\n\nè¾“å…¥ï¼štarget &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]è¾“å‡ºï¼š0\n\nè§£æ³•1ï¼šæš´åŠ›å¾ªç¯ä¸¤ä¸ª for å¾ªç¯å³å¯è§£å†³ï¼Œåˆ†åˆ«éå†å­æ•°ç»„çš„å¼€å¤´ä»¥åŠå­æ•°ç»„å†…éƒ¨ã€‚ä½¿ç”¨ python å¯èƒ½ä¼šè¶…å‡ºæ—¶é—´é™åˆ¶ã€‚\nclass Solution:    def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:        min_len = 0        for i in range(len(nums)):            array_sum = 0            for j in range(i, len(nums)):                                array_sum += nums[j]                if array_sum &gt;= target:                    cur_len = j - i + 1                    if min_len == 0 or min_len &gt; cur_len:                        min_len = cur_len                    break                return min_len\n\nè§£æ³•2ï¼šå‰ç¼€å’Œ+äºŒåˆ†æŸ¥æ‰¾æ–¹æ³•ä¸€ä¸­ï¼Œç¡®å®šäº†æ•°ç»„çš„å¼€å§‹ä½ç½®ï¼ŒæŸ¥æ‰¾ç»“æŸä½ç½®çš„æ—¶é—´å¤æ‚åº¦ä¸º O(n)ï¼Œå¦‚æœä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾ï¼Œå¯ä»¥ä¼˜åŒ–åˆ° O(logn)ã€‚ä¸ºäº†ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾ï¼Œéœ€è¦é¢å¤–åˆ›å»ºä¸€ä¸ªæ•°ç»„ sums ç”¨äºå­˜å‚¨æ•°ç»„ nums çš„å‰ç¼€å’Œï¼Œå…¶ä¸­ sums[i] è¡¨ç¤ºä» nums[0] åˆ° nums[iâˆ’1] çš„å…ƒç´ å’Œã€‚å¾—åˆ°å‰ç¼€å’Œä¹‹åï¼Œå¯¹äºæ¯ä¸ªå¼€å§‹ä¸‹æ ‡ iï¼Œå¯é€šè¿‡äºŒåˆ†æŸ¥æ‰¾å¾—åˆ°å¤§äºæˆ–ç­‰äº i çš„æœ€å°ä¸‹æ ‡ boundï¼Œä½¿å¾— sums[bound]âˆ’sums[iâˆ’1]â‰¥targetï¼Œå¹¶æ›´æ–°å­æ•°ç»„çš„æœ€å°é•¿åº¦ï¼ˆæ­¤æ—¶å­æ•°ç»„çš„é•¿åº¦æ˜¯ boundâˆ’(iâˆ’1)ï¼‰ã€‚\nç›¸å½“äºæ˜¯æŸ¥æ‰¾ç‰¹å®šå…ƒç´ çš„æ’å…¥ä½ç½®ï¼Œè¿™ä¸ªå€¼å°±æ˜¯é¢˜ç›®ä¸­ç»™å®šçš„ targetï¼Œä½†æ˜¯è¦æ³¨æ„ï¼Œå½“çª—å£çš„èµ·å§‹ä½ç½®ä¸ä¸º 0 æ—¶ï¼Œtarget éœ€è¦åŠ ä¸Šå½“å‰çª—å£çš„èµ·å§‹å‰ç¼€å’Œï¼Œå› ä¸ºæˆ‘ä»¬çš„çª—å£è¦æ»¡è¶³æ¡ä»¶ sums[end] - sums[start] &gt;&#x3D; sï¼Œå³ sums[end] &gt;&#x3D; s + sums[start]ï¼Œè¦æ‰¾åˆ°æ»¡è¶³è¿™ä¸ªæ¡ä»¶çš„ endï¼Œæ‰€ä»¥äºŒåˆ†æŸ¥æ‰¾çš„ target1 å®šä¹‰ä¸º target &#x3D; s + sums[start]ã€‚\nclass Solution:    def minSubArrayLen(self, s: int, nums: List[int]) -&gt; int:        if not nums:            return 0                n = len(nums)        ans = n + 1        sums = [0]        for i in range(n):            sums.append(sums[-1] + nums[i])                for i in range(1, n + 1):            target = s + sums[i - 1]            bound = bisect.bisect_left(sums, target)            if bound != len(sums):                ans = min(ans, bound - (i - 1))                return 0 if ans == n + 1 else ans\n\n\nè§£æ³•3ï¼šæ»‘åŠ¨çª—å£åœ¨æš´åŠ›è§£æ³•ä¸­ï¼Œæ˜¯ä¸€ä¸ªforå¾ªç¯æ»‘åŠ¨çª—å£çš„èµ·å§‹ä½ç½®ï¼Œä¸€ä¸ªforå¾ªç¯ä¸ºæ»‘åŠ¨çª—å£çš„ç»ˆæ­¢ä½ç½®ï¼Œç”¨ä¸¤ä¸ªforå¾ªç¯å®Œæˆäº†ä¸€ä¸ªä¸æ–­æœç´¢åŒºé—´çš„è¿‡ç¨‹ã€‚\nåªç”¨ä¸€ä¸ªforå¾ªç¯ï¼Œé‚£ä¹ˆè¿™ä¸ªå¾ªç¯çš„ç´¢å¼•ï¼Œä¸€å®šæ˜¯è¡¨ç¤ºæ»‘åŠ¨çª—å£çš„ç»ˆæ­¢ä½ç½®ã€‚å¯¹äºçª—å£çš„èµ·å§‹ä½ç½®ï¼Œåˆ™åŸºäºçª—å£çš„å’Œæ¥åˆ¤æ–­æ˜¯å¦éœ€è¦ç§»åŠ¨ã€‚ä½¿ç”¨ä¸€ä¸ª while å¾ªç¯æ¥è¡¨ç¤ºï¼Œå¦‚æœå­æ•°ç»„çš„å’Œå¤§äº targetï¼Œåˆ™å‡å»çª—å£èµ·å§‹ä½ç½®çš„å€¼ï¼Œå¹¶ä½¿çª—å£èµ·å§‹ä½ç½® +1ã€‚\næ­¤å¤–ï¼Œä¸è¦ä»¥ä¸ºforé‡Œæ”¾ä¸€ä¸ªwhileå°±ä»¥ä¸ºæ˜¯O(n^2)ï¼Œ ä¸»è¦æ˜¯çœ‹æ¯ä¸€ä¸ªå…ƒç´ è¢«æ“ä½œçš„æ¬¡æ•°ï¼Œæ¯ä¸ªå…ƒç´ åœ¨æ»‘åŠ¨çª—åè¿›æ¥æ“ä½œä¸€æ¬¡ï¼Œå‡ºå»æ“ä½œä¸€æ¬¡ï¼Œæ¯ä¸ªå…ƒç´ éƒ½æ˜¯è¢«æ“ä½œä¸¤æ¬¡ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦æ˜¯ 2 Ã— n ä¹Ÿå°±æ˜¯O(n)ã€‚\nclass Solution:    def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:        min_len = 0        start = 0        array_sum = 0        for end in range(len(nums)):            array_sum += nums[end]            while array_sum &gt;= target:                cur_len = end - start + 1                if min_len == 0 or min_len &gt; cur_len:                    min_len = cur_len                array_sum -= nums[start]                start += 1        return min_len\n\n904. æ°´æœæˆç¯®\né¢˜ç›®é“¾æ¥ link\n\nä½ æ­£åœ¨æ¢è®¿ä¸€å®¶å†œåœºï¼Œå†œåœºä»å·¦åˆ°å³ç§æ¤äº†ä¸€æ’æœæ ‘ã€‚è¿™äº›æ ‘ç”¨ä¸€ä¸ªæ•´æ•°æ•°ç»„ fruits è¡¨ç¤ºï¼Œå…¶ä¸­ fruits[i] æ˜¯ç¬¬ i æ£µæ ‘ä¸Šçš„æ°´æœç§ç±» ã€‚\nä½ æƒ³è¦å°½å¯èƒ½å¤šåœ°æ”¶é›†æ°´æœã€‚ç„¶è€Œï¼Œå†œåœºçš„ä¸»äººè®¾å®šäº†ä¸€äº›ä¸¥æ ¼çš„è§„çŸ©ï¼Œä½ å¿…é¡»æŒ‰ç…§è¦æ±‚é‡‡æ‘˜æ°´æœï¼š\nä½ åªæœ‰ ä¸¤ä¸ª ç¯®å­ï¼Œå¹¶ä¸”æ¯ä¸ªç¯®å­åªèƒ½è£… å•ä¸€ç±»å‹ çš„æ°´æœã€‚æ¯ä¸ªç¯®å­èƒ½å¤Ÿè£…çš„æ°´æœæ€»é‡æ²¡æœ‰é™åˆ¶ã€‚ä½ å¯ä»¥é€‰æ‹©ä»»æ„ä¸€æ£µæ ‘å¼€å§‹é‡‡æ‘˜ï¼Œä½ å¿…é¡»ä» æ¯æ£µ æ ‘ï¼ˆåŒ…æ‹¬å¼€å§‹é‡‡æ‘˜çš„æ ‘ï¼‰ä¸Š æ°å¥½æ‘˜ä¸€ä¸ªæ°´æœ ã€‚é‡‡æ‘˜çš„æ°´æœåº”å½“ç¬¦åˆç¯®å­ä¸­çš„æ°´æœç±»å‹ã€‚æ¯é‡‡æ‘˜ä¸€æ¬¡ï¼Œä½ å°†ä¼šå‘å³ç§»åŠ¨åˆ°ä¸‹ä¸€æ£µæ ‘ï¼Œå¹¶ç»§ç»­é‡‡æ‘˜ã€‚ä¸€æ—¦ä½ èµ°åˆ°æŸæ£µæ ‘å‰ï¼Œä½†æ°´æœä¸ç¬¦åˆç¯®å­çš„æ°´æœç±»å‹ï¼Œé‚£ä¹ˆå°±å¿…é¡»åœæ­¢é‡‡æ‘˜ã€‚ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ fruits ï¼Œè¿”å›ä½ å¯ä»¥æ”¶é›†çš„æ°´æœçš„ æœ€å¤§ æ•°ç›®ã€‚\nç¤ºä¾‹ 1ï¼š\n\nè¾“å…¥ï¼šfruits &#x3D; [1,2,1]è¾“å‡ºï¼š3è§£é‡Šï¼šå¯ä»¥é‡‡æ‘˜å…¨éƒ¨ 3 æ£µæ ‘ã€‚\n\nç¤ºä¾‹ 2ï¼š\n\nè¾“å…¥ï¼šfruits &#x3D; [0,1,2,2]è¾“å‡ºï¼š3è§£é‡Šï¼šå¯ä»¥é‡‡æ‘˜ [1,2,2] è¿™ä¸‰æ£µæ ‘ã€‚å¦‚æœä»ç¬¬ä¸€æ£µæ ‘å¼€å§‹é‡‡æ‘˜ï¼Œåˆ™åªèƒ½é‡‡æ‘˜ [0,1] è¿™ä¸¤æ£µæ ‘ã€‚\n\nç¤ºä¾‹ 3ï¼š\n\nè¾“å…¥ï¼šfruits &#x3D; [1,2,3,2,2]è¾“å‡ºï¼š4è§£é‡Šï¼šå¯ä»¥é‡‡æ‘˜ [2,3,2,2] è¿™å››æ£µæ ‘ã€‚å¦‚æœä»ç¬¬ä¸€æ£µæ ‘å¼€å§‹é‡‡æ‘˜ï¼Œåˆ™åªèƒ½é‡‡æ‘˜ [1,2] è¿™ä¸¤æ£µæ ‘ã€‚\n\nç¤ºä¾‹ 4ï¼š\n\nè¾“å…¥ï¼šfruits &#x3D; [3,3,3,1,2,1,1,2,3,3,4]è¾“å‡ºï¼š5è§£é‡Šï¼šå¯ä»¥é‡‡æ‘˜ [1,2,1,1,2] è¿™äº”æ£µæ ‘ã€‚\n\næ€è·¯ç›¸å½“äºæ˜¯åªåŒ…å«ä¸¤ä¸ªæ•°å­—çš„æœ€é•¿å­æ•°ç»„ï¼Œä½¿ç”¨äº†ä¸€ä¸ª Counter ç±»ï¼ŒCounter æ˜¯ä¸€ä¸ªè®¡æ•°å™¨å­—å…¸ï¼Œå¯ä»¥è‡ªåŠ¨ç»Ÿè®¡å…ƒç´ å‡ºç°çš„æ¬¡æ•°ã€‚pop æ–¹æ³•ç”¨äºåˆ é™¤æŒ‡å®šçš„ keyï¼Œå¹¶å¯ä»¥è¿”å›å…¶ valueã€‚\nclass Solution:    def totalFruit(self, fruits: List[int]) -&gt; int:        max_len = 0        start = 0        cnt = Counter()        for end in range(0, len(fruits)):            cnt[fruits[end]] += 1            while len(cnt) &gt; 2:                cnt[fruits[start]] -= 1                if cnt[fruits[start]] == 0:                    cnt.pop(fruits[start])                            start += 1            max_len = max(max_len, end - start + 1)                return max_len\n\nCounter ç±»ç­‰ä»·äº\ncnt = &#123;&#125;cnt[x] = cnt.get(x, 0)\n\nget æ–¹æ³•æŸ¥æ‰¾æŒ‡å®š key å¯¹åº”çš„ valueï¼Œæ‰¾ä¸åˆ°æ—¶è¿”å›é»˜è®¤å€¼ï¼Œä½¿ç”¨åŸå§‹ dict çš„ä»£ç å¦‚ä¸‹ï¼š\nclass Solution:    def totalFruit(self, fruits: List[int]) -&gt; int:        max_len = 0        start = 0        cnt = dict()        for end in range(0, len(fruits)):            cnt[fruits[end]] = cnt.get(fruits[end], 0) + 1            while len(cnt) &gt; 2:                cnt[fruits[start]] -= 1                if cnt[fruits[start]] == 0:                    cnt.pop(fruits[start])                            start += 1            max_len = max(max_len, end - start + 1)                return max_len            \n\n76. æœ€å°è¦†ç›–å­ä¸²ï¼ˆHardï¼‰\né¢˜ç›®é“¾æ¥ link\n\nç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s ã€ä¸€ä¸ªå­—ç¬¦ä¸² t ã€‚è¿”å› s ä¸­æ¶µç›– t æ‰€æœ‰å­—ç¬¦çš„æœ€å°å­ä¸²ã€‚å¦‚æœ s ä¸­ä¸å­˜åœ¨æ¶µç›– t æ‰€æœ‰å­—ç¬¦çš„å­ä¸²ï¼Œåˆ™è¿”å›ç©ºå­—ç¬¦ä¸² â€œâ€ ã€‚\næ³¨æ„ï¼š\nå¯¹äº t ä¸­é‡å¤å­—ç¬¦ï¼Œæˆ‘ä»¬å¯»æ‰¾çš„å­å­—ç¬¦ä¸²ä¸­è¯¥å­—ç¬¦æ•°é‡å¿…é¡»ä¸å°‘äº t ä¸­è¯¥å­—ç¬¦æ•°é‡ã€‚å¦‚æœ s ä¸­å­˜åœ¨è¿™æ ·çš„å­ä¸²ï¼Œæˆ‘ä»¬ä¿è¯å®ƒæ˜¯å”¯ä¸€çš„ç­”æ¡ˆã€‚\nç¤ºä¾‹ 1ï¼š\n\nè¾“å…¥ï¼šs &#x3D; â€œADOBECODEBANCâ€, t &#x3D; â€œABCâ€è¾“å‡ºï¼šâ€BANCâ€è§£é‡Šï¼šæœ€å°è¦†ç›–å­ä¸² â€œBANCâ€ åŒ…å«æ¥è‡ªå­—ç¬¦ä¸² t çš„ â€˜Aâ€™ã€â€™Bâ€™ å’Œ â€˜Câ€™ã€‚  \n\nç¤ºä¾‹ 2ï¼š\n\nè¾“å…¥ï¼šs &#x3D; â€œaâ€, t &#x3D; â€œaâ€è¾“å‡ºï¼šâ€aâ€è§£é‡Šï¼šæ•´ä¸ªå­—ç¬¦ä¸² s æ˜¯æœ€å°è¦†ç›–å­ä¸²ã€‚\n\nç¤ºä¾‹ 3:\n\nè¾“å…¥: s &#x3D; â€œaâ€, t &#x3D; â€œaaâ€è¾“å‡º: â€œâ€è§£é‡Š: t ä¸­ä¸¤ä¸ªå­—ç¬¦ â€˜aâ€™ å‡åº”åŒ…å«åœ¨ s çš„å­ä¸²ä¸­ï¼Œå› æ­¤æ²¡æœ‰ç¬¦åˆæ¡ä»¶çš„å­å­—ç¬¦ä¸²ï¼Œè¿”å›ç©ºå­—ç¬¦ä¸²ã€‚\n\næ»‘åŠ¨çª—å£\næ ¸å¿ƒä¸ºå¦‚ä½•åˆ¤æ–­å½“å‰ s çš„çª—å£æ˜¯å¦è¦†ç›–äº† tã€‚å¯ä»¥ä½¿ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨æ¥è®°å½•ï¼ŒåŒæ—¶ï¼Œt ä¸­å¯èƒ½æœ‰é‡å¤çš„å­—ç¬¦ï¼Œæ‰€ä»¥éœ€è¦è®°å½•å­—ç¬¦çš„ä¸ªæ•°ï¼ˆä¸¤ä¸ªè®¡æ•°å™¨ï¼Œéœ€è¦çš„å­—ç¬¦ä¸ªæ•°ï¼Œå’Œå½“å‰çª—å£å·²ç»æœ‰çš„ä¸ªæ•°ï¼‰ã€‚æ­¤å¤–ï¼ŒCounter å¯ä»¥ç›´æ¥ä½¿ç”¨å¤§äºå’Œå°äºè¿ç®—ç¬¦æ¥è¿›è¡Œåˆ¤æ–­æ˜¯å¦è¦†ç›–ã€‚æ‰€ä»¥å¯ä»¥å†™å‡ºä»¥ä¸‹ä»£ç ï¼š\nclass Solution:    def minWindow(self, s: str, t: str) -&gt; str:        min_str = &quot;&quot;        s_list = list(s)        t_list = list(t)        start = 0        t_cnt = Counter()        s_cnt = Counter()        for i in t_list:            t_cnt[i] += 1          for end in range(len(s_list)):            s_cnt[s_list[end]] += 1            while s_cnt &gt;= t_cnt:                if min_str == &quot;&quot; or len(min_str) &gt; end - start + 1:                    min_str = &quot;&quot;.join(s_list[start: end + 1])                s_cnt[s_list[start]] -= 1                start += 1                return min_str\nä½†æ˜¯ï¼Œä¸Šè¿°ä»£ç ä¼šæç¤ºè¶…æ—¶ï¼ŒåŸå› æ˜¯æ¯æ¬¡æ›´æ–°æœ€å°å­å­—ç¬¦ä¸²æ—¶ï¼Œéƒ½ä¼šè¿›è¡Œåˆ‡ç‰‡æ“ä½œï¼Œ ä¹Ÿæ˜¯æ–°å»ºå­—ç¬¦ä¸²å¯¹è±¡ï¼ˆO(end - start)ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨ä¸¤ä¸ªå˜é‡ ans_start å’Œ ans_end æ¥è®°å½•å¯¹åº”çš„ä¸‹æ ‡ï¼Œåªåœ¨æœ€åå¯¹å­—ç¬¦ä¸²è¿›è¡Œæ“ä½œã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œans_end ä¸èƒ½ä¸€å¼€å§‹å°±è®¾ç½®ä¸º0ï¼Œå› ä¸ºå¦‚æœæ²¡æœ‰æ»¡è¶³çš„å­å­—ç¬¦ä¸²ï¼Œä¼šç›´æ¥è¿”å› s[0ï¼š1]ï¼Œä¸ç¬¦åˆè¦æ±‚ã€‚å¯ä»¥æŠŠ ans_end è®¾ç½®ä¸º len(s)ã€‚\nclass Solution:    def minWindow(self, s: str, t: str) -&gt; str:        s_list = list(s)        t_list = list(t)        start = 0        t_cnt = Counter()        s_cnt = Counter()        ans_start = 0        ans_end = len(s)        for i in t_list:            t_cnt[i] += 1          for end in range(len(s_list)):            s_cnt[s_list[end]] += 1            while s_cnt &gt;= t_cnt:                if ans_end == len(s) or ans_end - ans_start &gt; end - start:                    ans_end = end                    ans_start = start                s_cnt[s_list[start]] -= 1                start += 1        if ans_end == len(s):            return &quot;&quot;        else:            return &quot;&quot;.join(s_list[ans_start: ans_end + 1])\n\nCounter æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ª dictï¼Œå¦‚æœä½¿ç”¨ dictï¼Œéœ€è¦å®šä¹‰ä¸€ä¸ªåˆ¤æ–­å‡½æ•°ï¼Œæ³¨æ„ï¼Œè¿™é‡Œæ˜¯éå†äº† t å¯¹åº”çš„ dictï¼Œå³éœ€è¦çš„å­—ç¬¦æ•°é‡ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(|len(t)|)ï¼Œdict ä¸ºå“ˆå¸Œè¡¨ï¼Œè¯»å†™çš„æ—¶é—´å¤æ‚åº¦ä¸º O(1)ã€‚\nclass Solution:    def minWindow(self, s: str, t: str) -&gt; str:        s_list = list(s)        t_list = list(t)        start = 0        t_cnt = dict()        s_cnt = dict()        ans_start = 0        ans_end = len(s)        for i in t_list:            t_cnt[i] = t_cnt.get(i, 0) + 1          for end in range(len(s_list)):            s_cnt[s_list[end]] = s_cnt.get(s_list[end], 0) + 1            while self.check(s_cnt, t_cnt):                if ans_end == len(s) or ans_end - ans_start &gt; end - start:                    ans_end = end                    ans_start = start                s_cnt[s_list[start]] -= 1                start += 1        if ans_end == len(s):            return &quot;&quot;        else:            return &quot;&quot;.join(s_list[ans_start: ans_end + 1])                def check(self, s_cnt1, t_cnt1):        for key, value in t_cnt1.items():            if value &gt; s_cnt1.get(key, 0):                return False                return True","categories":["Leetcode"],"tags":["Array"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘æ•°ç»„4-æ¨¡æ‹Ÿè¿‡ç¨‹","url":"/blog/Leetcode/array4/","content":"59. èºæ—‹çŸ©é˜µ II\né¢˜ç›®é“¾æ¥ link\n\nç»™ä½ ä¸€ä¸ªæ­£æ•´æ•° n ï¼Œç”Ÿæˆä¸€ä¸ªåŒ…å« 1 åˆ° n^2 æ‰€æœ‰å…ƒç´ ï¼Œä¸”å…ƒç´ æŒ‰é¡ºæ—¶é’ˆé¡ºåºèºæ—‹æ’åˆ—çš„ n x n æ­£æ–¹å½¢çŸ©é˜µ matrix ã€‚\nç¤ºä¾‹ï¼š\n\nè¾“å…¥ï¼šn &#x3D; 3è¾“å‡ºï¼š[[1,2,3],[8,9,4],[7,6,5]]\n\næ€è·¯æ ¸å¿ƒï¼šå·¦é—­å³å¼€è¿›è¡Œå¡«å……ï¼Œæ¯ä¸ªåœˆæŒ‰ç…§ä»¥ä¸‹é¡ºåºæ¥ç”»ï¼š\n\nå¡«å……ä¸Šè¡Œä»å·¦åˆ°å³\nå¡«å……å³åˆ—ä»ä¸Šåˆ°ä¸‹\nå¡«å……ä¸‹è¡Œä»å³åˆ°å·¦\nå¡«å……å·¦åˆ—ä»ä¸‹åˆ°ä¸Š\n\nå¾ªç¯å˜é‡ä¸ºè¦ç”»çš„åœˆçš„æ•°é‡ï¼ˆåç§»é‡ï¼Œå› ä¸ºæ˜¯å·¦é—­å³å¼€åŒºé—´ï¼Œæ¯ä¸€è¡Œï¼ˆåˆ—ï¼‰çš„æœ€åä¸€ä½ä¸å¡«ï¼‰å®šä¹‰ï¼š\n\nèµ·ç‚¹ï¼šæ¯ä¸€åœˆçš„å·¦ä¸Šè§’çš„ç‚¹\nç»ˆç‚¹ï¼šn å‡å»åç§»é‡class Solution:    def generateMatrix(self, n: int) -&gt; List[List[int]]:        res = [[0 for _ in range(n)] for _ in range(n)]        loop = n // 2                startx, starty = 0, 0        count = 1        for offset in range(1, loop + 1):            for i in range(starty, n - offset):                res[startx][i] = count                count += 1            for i in range(startx, n - offset):                res[i][n - offset] = count                count += 1                        for i in range(n - offset, starty, -1):                res[n - offset][i] = count                count += 1                        for i in range(n - offset, startx, -1):                res[i][starty] = count                count += 1                        startx += 1            starty += 1        if n % 2 != 0:            res[n // 2][n // 2] = count        return res\n\n54. èºæ—‹çŸ©é˜µ\né¢˜ç›®é“¾æ¥ link\n\nç»™ä½ ä¸€ä¸ª m è¡Œ n åˆ—çš„çŸ©é˜µ matrix ï¼Œè¯·æŒ‰ç…§ é¡ºæ—¶é’ˆèºæ—‹é¡ºåº ï¼Œè¿”å›çŸ©é˜µä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚\nç¤ºä¾‹ï¼š\n\nè¾“å…¥ï¼šmatrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]è¾“å‡ºï¼š[1,2,3,6,9,8,7,4,5]\n\n\næ€è·¯ä¸Šä¸€ä¸ªé¢˜ç›®çš„æ‰©å±•ï¼Œå³å½¢çŠ¶ä¸ä¸€å®šä¸ºæ­£æ–¹å½¢ï¼Œæœ‰ä»¥ä¸‹å‡ ä¸ªæ–¹é¢çš„è€ƒè™‘ï¼š\n\nå¾ªç¯çš„æ¬¡æ•°ï¼ˆå‡ ä¸ª loopï¼‰å†³å®šäº matrix çš„çŸ­è¾¹\nè®¡ç®—åç§»é‡æ—¶è¦æ³¨æ„æ˜¯é•¿è¾¹å‡å»åç§»é‡è¿˜æ˜¯çŸ­è¾¹\nä¸­é—´éƒ¨åˆ†çš„å¤„ç†ï¼š\nå¦‚æœæ˜¯æ­£æ–¹å½¢ï¼Œåˆ™ç›´æ¥è¾¹é•¿ &#x2F;&#x2F; 2 è¿›è¡Œè¯»å–\nå¦‚æœæ˜¯é•¿æ–¹å½¢ï¼Œåˆ™éœ€è¦æ³¨æ„ï¼š\nåˆ¤æ–­ä¸­é—´éƒ¨åˆ†æ˜¯å“ªæ¡è¾¹\né»˜è®¤çš„æƒ…å†µæ˜¯å·¦é—­å³å¼€ï¼Œæœ¬æ¥éœ€è¦å°† offset - 1ï¼Œä½†æ˜¯ä¸­é—´éƒ¨åˆ†éœ€è¦å·¦é—­å³é—­ï¼Œåˆ™ offset ä¸ç”¨ - 1\n\n\n\n\n\nclass Solution:    def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:        x = len(matrix)        y = len(matrix[0])        loop = min(x, y) // 2        startx = 0        starty = 0        res = []        offset = 0        for offset in range(1, loop + 1):            for i in range(starty, y - offset):                res.append(matrix[startx][i])                        for i in range(startx, x - offset):                res.append(matrix[i][y - offset])                        for i in range(y - offset, starty, -1):                res.append(matrix[x - offset][i])                        for i in range(x - offset, startx, -1):                res.append(matrix[i][starty])            startx += 1            starty += 1                if x == y and x % 2 != 0:            res.append(matrix[x // 2][y // 2])        elif x &gt; y and y % 2 != 0:            for i in range(startx, x - offset):                res.append(matrix[i][y // 2])        elif x &lt; y and x % 2 != 0:            for i in range(starty, y - offset):                res.append(matrix[x // 2][i])                return res\n\n","categories":["Leetcode"],"tags":["Array"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘æ•°ç»„5-å‰ç¼€å’Œ","url":"/blog/Leetcode/array5/","content":"58. åŒºé—´å’Œ\né¢˜ç›®é“¾æ¥ link\n\nç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ Arrayï¼Œè¯·è®¡ç®—è¯¥æ•°ç»„åœ¨æ¯ä¸ªæŒ‡å®šåŒºé—´å†…å…ƒç´ çš„æ€»å’Œã€‚\nç¬¬ä¸€è¡Œè¾“å…¥ä¸ºæ•´æ•°æ•°ç»„ Array çš„é•¿åº¦ nï¼Œæ¥ä¸‹æ¥ n è¡Œï¼Œæ¯è¡Œä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºæ•°ç»„çš„å…ƒç´ ã€‚éšåçš„è¾“å…¥ä¸ºéœ€è¦è®¡ç®—æ€»å’Œçš„åŒºé—´ä¸‹æ ‡ï¼šaï¼Œb ï¼ˆb &gt; &#x3D; aï¼‰ï¼Œç›´è‡³æ–‡ä»¶ç»“æŸã€‚è¾“å‡ºæ¯ä¸ªæŒ‡å®šåŒºé—´å†…å…ƒç´ çš„æ€»å’Œã€‚  \nè¾“å…¥ç¤ºä¾‹\n\n5123450 11 3\n\nè¾“å‡ºç¤ºä¾‹\n\n39\n\næ€è·¯ï¼šå‰ç¼€å’Œé‡å¤åˆ©ç”¨è®¡ç®—è¿‡çš„å­æ•°ç»„ä¹‹å’Œï¼Œä»è€Œé™ä½åŒºé—´æŸ¥è¯¢éœ€è¦ç´¯åŠ è®¡ç®—çš„æ¬¡æ•°ã€‚ACM è¾“å…¥æ ¼å¼ã€‚æ³¨æ„ï¼š\n\nå‰ç¼€å’Œçš„å†™æ³•ï¼Œç¬¬ä¸€ä½æ˜¯ 0\næŒ‰ç…§ä¸‹é¢çš„å†™æ³•ï¼Œè®¡ç®—ä¸€æ¬¡å°±è¾“å‡ºä¸€æ¬¡ï¼Œä¼šè¶…å‡ºé™åˆ¶ï¼Œå¯ä»¥ä½¿ç”¨ä¸€ä¸ªæ•°ç»„æŠŠç»“æœå­˜èµ·æ¥ï¼Œç„¶åç»Ÿä¸€è¾“å‡º\næŒ‰ç…§ä¸‹é¢çš„å†™æ³•ï¼Œdata å¯èƒ½ä¼šè¶…å‡ºé™åˆ¶ï¼ŒæŠ¥é”™ ä¸‹æ ‡æ— æ³•è®¿é—®ï¼Œæ‰€ä»¥éœ€è¦åˆ¤æ–­æ˜¯å¦æœ‰æŸ¥è¯¢\n\nimport sysinput = sys.stdin.readdata = input().split()n = int(data[0])sums = [0]for i in range(1, n+1):    sums.append(int(data[i]) + sums[-1])for index in range(n+1, len(data), 2)    a = int(data[index])    b = int(data[index+1])    index += 2        res.append(sums[b+1] - sums[a])    print(res)\n\næ›´æ”¹åçš„ä»£ç ï¼š\nimport sysinput = sys.stdin.readdata = input().split()n = int(data[0])sums = [0]for i in range(1, n+1):    sums.append(int(data[i]) + sums[-1])index = n + 1res = []while index &lt; len(data):    a = int(data[index])    b = int(data[index+1])    index += 2        res.append(sums[b+1] - sums[a])    print(res)\n\n44. å¼€å‘å•†è´­ä¹°åœŸåœ°\né¢˜ç›®é“¾æ¥ link\n\nåœ¨ä¸€ä¸ªåŸå¸‚åŒºåŸŸå†…ï¼Œè¢«åˆ’åˆ†æˆäº†n * mä¸ªè¿ç»­çš„åŒºå—ï¼Œæ¯ä¸ªåŒºå—éƒ½æ‹¥æœ‰ä¸åŒçš„æƒå€¼ï¼Œä»£è¡¨ç€å…¶åœŸåœ°ä»·å€¼ã€‚ç›®å‰ï¼Œæœ‰ä¸¤å®¶å¼€å‘å…¬å¸ï¼ŒA å…¬å¸å’Œ B å…¬å¸ï¼Œå¸Œæœ›è´­ä¹°è¿™ä¸ªåŸå¸‚åŒºåŸŸçš„åœŸåœ°ã€‚ \nç°åœ¨ï¼Œéœ€è¦å°†è¿™ä¸ªåŸå¸‚åŒºåŸŸçš„æ‰€æœ‰åŒºå—åˆ†é…ç»™ A å…¬å¸å’Œ B å…¬å¸ã€‚\nç„¶è€Œï¼Œç”±äºåŸå¸‚è§„åˆ’çš„é™åˆ¶ï¼Œåªå…è®¸å°†åŒºåŸŸæŒ‰æ¨ªå‘æˆ–çºµå‘åˆ’åˆ†æˆä¸¤ä¸ªå­åŒºåŸŸï¼Œè€Œä¸”æ¯ä¸ªå­åŒºåŸŸéƒ½å¿…é¡»åŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ªåŒºå—ã€‚ ä¸ºäº†ç¡®ä¿å…¬å¹³ç«äº‰ï¼Œä½ éœ€è¦æ‰¾åˆ°ä¸€ç§åˆ†é…æ–¹å¼ï¼Œä½¿å¾— A å…¬å¸å’Œ B å…¬å¸å„è‡ªçš„å­åŒºåŸŸå†…çš„åœŸåœ°æ€»ä»·å€¼ä¹‹å·®æœ€å°ã€‚ \næ³¨æ„ï¼šåŒºå—ä¸å¯å†åˆ†ã€‚\nç¬¬ä¸€è¡Œè¾“å…¥ä¸¤ä¸ªæ­£æ•´æ•°ï¼Œä»£è¡¨ n å’Œ mã€‚æ¥ä¸‹æ¥çš„ n è¡Œï¼Œæ¯è¡Œè¾“å‡º m ä¸ªæ­£æ•´æ•°ã€‚è¯·è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œä»£è¡¨ä¸¤ä¸ªå­åŒºåŸŸå†…åœŸåœ°æ€»ä»·å€¼ä¹‹é—´çš„æœ€å°å·®è·ã€‚\nç¤ºä¾‹ï¼šè¾“å…¥\n\n3 31 2 32 1 31 2 3  \n\nè¾“å‡ºï¼š\n\n0\n\næ€è·¯æœ¬è´¨ä¸Šè¿˜æ˜¯åŒºé—´å’Œï¼Œä¹‹ä¸æ˜¯äºŒç»´çš„ï¼Œéœ€è¦è€ƒè™‘ä¸¤ä¸ªæ–¹å‘çš„æ±‚å’Œã€‚å¯ä»¥å…ˆé’ˆå¯¹ä¸¤ä¸ªæ–¹å‘æ±‚å‰ç¼€å’Œï¼Œç„¶åè¿›è¡Œåˆ¤æ–­ã€‚ä¾‹å¦‚æ°´å¹³åˆ†å‰²æ—¶ï¼Œå¯ä»¥å°†æ•°ç»„å…ˆæŒ‰è¡Œæ±‚å’Œï¼Œç„¶åå†è®¡ç®—å‰ç¼€å’Œã€‚\nimport sysinput = sys.stdin.readdata = input().split()n, m = int(data[0]), int(data[1])num = [[0] * m for _ in range(n)]index = 2for i in range(n):    for j in range(m):        num[i][j] = int(data[index])        index += 1# æ±‚æ¯ä¸€è¡Œçš„å’Œsumx = [sum(num[i]) for i in range(n)]# æŒ‰è¡Œçš„å‰ç¼€å’Œsumx_pre = [sumx[0]]for i in range(1, n):    sumx_pre.append(sumx[i] + sumx_pre[-1])minx = float(&#x27;inf&#x27;)# è®¡ç®—æœ€å°çš„å·®for i in range(0, n - 1):    p1 = sumx_pre[i]    p2 = sumx_pre[-1] - sumx_pre[i]    dif = abs(p2 - p1)    if minx &gt; dif:        minx = dif# æ±‚æ¯ä¸€åˆ—çš„å’Œsumy = [sum(num[i][j] for i in range(n)) for j in range(m)]# æŒ‰åˆ—çš„å‰ç¼€å’Œsumy_pre = [sumy[0]]for j in range(1, m):    sumy_pre.append(sumy[j] + sumy_pre[-1])miny = float(&#x27;inf&#x27;)for j in range(0, m - 1):    p1 = sumy_pre[j]    p2 = sumy_pre[-1] - sumy_pre[j]    dif = abs(p2 - p1)    if  miny &gt; dif:        miny = difprint(min(miny, minx))\n\nä¼˜åŒ–åœ¨è¯»å–æ•°æ®æ—¶ï¼Œç›´æ¥æ±‚æ•´ä¸ªçŸ©é˜µçš„å’Œã€‚ç„¶ååˆ†åˆ«ä¸¤ä¸ªæ–¹å‘æ±‚å’Œï¼Œæ¨¡æ‹Ÿè¡Œåˆ†å‰²å’Œåˆ—åˆ†å‰²ã€‚æ¯æ±‚å’Œä¸€è¡Œï¼ˆåˆ—ï¼‰ï¼Œå°±è®¡ç®—å·®å€¼ã€‚è¿™æ ·å¯ä»¥çœå»è®¡ç®—å‰ç¼€å’Œçš„æ­¥éª¤ã€‚\næ€»ç»“\nACM æ ¼å¼ä¸‹ï¼Œéœ€è¦è‡ªå·±å¤„ç†è¾“å…¥ï¼Œè¿™é‡Œé‡å†™äº† input æ–¹æ³•ï¼š\n\nimport sysinput = sys.stdin.readdata = input().split()\n\nsplit()ï¼šå¤šä¸ªç©ºæ ¼å½“æˆä¸€ä¸ªç©ºæ ¼ï¼›split(â€˜ â€˜)ï¼šå¤šä¸ªç©ºæ ¼éƒ½è¦åˆ†å‰²ï¼Œæ¯ä¸ªç©ºæ ¼åˆ†å‰²å‡ºæ¥ç©ºã€‚\né‡å†™çš„å’Œè‡ªå¸¦çš„æ–¹æ³•å¯¹æ¯”å¦‚ä¸‹ï¼š\né‡å†™çš„æ–¹æ³•å¯ä»¥å°†æ‰€æœ‰è¾“å…¥ä½œä¸ºä¸€æ•´ä¸ªå­—ç¬¦ä¸²è¯»å–ï¼Œå¯ä»¥å‡å°‘ IO æ—¶é—´ã€‚åç»­ä½¿ç”¨ .split() æ–¹æ³•æ¥æ‹†åˆ†æ¯ä¸ªè¾“å…¥å³å¯ã€‚\n\né¢˜ç›®è¦æ±‚æ±‚æœ€å°å€¼æ—¶ï¼Œå¯ä»¥å°†è¡¨ç¤ºæœ€å°å€¼çš„å˜é‡é¢„å…ˆå®šä¹‰ä¸ºæ­£æ— ç©· float(â€˜infâ€™)ï¼Œä¾¿äºåç»­æ¯”è¾ƒã€‚åŒç†ï¼Œæœ€å¤§å€¼å¯ä»¥å®šä¹‰ä¸ºæœåŠ¡å™¨ float(â€˜-infâ€™)ã€‚\n\næœ¬é¢˜ä¸­éœ€è¦è®¡ç®—çš„æ˜¯ä¸¤ä¸ªå—ä¹‹é—´çš„å·®ï¼Œæ³¨æ„ä½¿ç”¨ç»å¯¹å€¼ abs()ã€‚\n\n\n","categories":["Leetcode"],"tags":["Array"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘å›æº¯1-ç»„åˆé—®é¢˜","url":"/blog/Leetcode/backtrack1/","content":"å›æº¯æ³•å›æº¯æ˜¯é€’å½’çš„å‰¯äº§å“ï¼Œåªè¦æœ‰é€’å½’å°±ä¼šæœ‰å›æº¯ã€‚å›æº¯çš„æœ¬è´¨æ˜¯ç©·ä¸¾ï¼Œç©·ä¸¾æ‰€æœ‰å¯èƒ½ï¼Œç„¶åé€‰å‡ºæˆ‘ä»¬æƒ³è¦çš„ç­”æ¡ˆï¼Œå¦‚æœæƒ³è®©å›æº¯æ³•é«˜æ•ˆä¸€äº›ï¼Œå¯ä»¥åŠ ä¸€äº›å‰ªæçš„æ“ä½œï¼Œä½†ä¹Ÿæ”¹ä¸äº†å›æº¯æ³•å°±æ˜¯ç©·ä¸¾çš„æœ¬è´¨ã€‚é€šå¸¸å¯ä»¥è§£å†³ä»¥ä¸‹é—®é¢˜ï¼š\n\nç»„åˆé—®é¢˜ï¼šNä¸ªæ•°é‡Œé¢æŒ‰ä¸€å®šè§„åˆ™æ‰¾å‡ºkä¸ªæ•°çš„é›†åˆ\nåˆ‡å‰²é—®é¢˜ï¼šä¸€ä¸ªå­—ç¬¦ä¸²æŒ‰ä¸€å®šè§„åˆ™æœ‰å‡ ç§åˆ‡å‰²æ–¹å¼\nå­é›†é—®é¢˜ï¼šä¸€ä¸ªNä¸ªæ•°çš„é›†åˆé‡Œæœ‰å¤šå°‘ç¬¦åˆæ¡ä»¶çš„å­é›†\næ’åˆ—é—®é¢˜ï¼šNä¸ªæ•°æŒ‰ä¸€å®šè§„åˆ™å…¨æ’åˆ—ï¼Œæœ‰å‡ ç§æ’åˆ—æ–¹å¼\næ£‹ç›˜é—®é¢˜ï¼šNçš‡åï¼Œè§£æ•°ç‹¬ç­‰ç­‰\n\nå›æº¯æ³•è§£å†³çš„é—®é¢˜éƒ½å¯ä»¥æŠ½è±¡ä¸ºæ ‘å½¢ç»“æ„ã€‚å› ä¸ºå›æº¯æ³•è§£å†³çš„éƒ½æ˜¯åœ¨é›†åˆä¸­é€’å½’æŸ¥æ‰¾å­é›†ï¼Œé›†åˆçš„å¤§å°å°±æ„æˆäº†æ ‘çš„å®½åº¦ï¼Œé€’å½’çš„æ·±åº¦å°±æ„æˆäº†æ ‘çš„æ·±åº¦ã€‚\nå›æº¯æ³•æ¨¡æ¿\nå›æº¯å‡½æ•°è¿”å›å€¼å’Œå‚æ•°\nå›æº¯ç®—æ³•éœ€è¦çš„å‚æ•°ä¸åƒäºŒå‰æ ‘é€’å½’çš„æ—¶å€™é‚£ä¹ˆå®¹æ˜“ä¸€æ¬¡æ€§ç¡®å®šä¸‹æ¥ï¼Œæ‰€ä»¥ä¸€èˆ¬æ˜¯å…ˆå†™é€»è¾‘ï¼Œç„¶åéœ€è¦ä»€ä¹ˆå‚æ•°ï¼Œå°±å¡«ä»€ä¹ˆå‚æ•°ã€‚\n\n\nå›æº¯å‡½æ•°ç»ˆæ­¢æ¡ä»¶\nï¼Ÿ\n\n\nå›æº¯æœç´¢çš„éå†è¿‡ç¨‹\nå›æº¯æ³•ä¸€èˆ¬æ˜¯åœ¨é›†åˆä¸­é€’å½’æœç´¢ï¼Œé›†åˆçš„å¤§å°æ„æˆäº†æ ‘çš„å®½åº¦ï¼Œé€’å½’çš„æ·±åº¦æ„æˆçš„æ ‘çš„æ·±åº¦ã€‚\n\n\n\n\nfor (é€‰æ‹©ï¼šæœ¬å±‚é›†åˆä¸­å…ƒç´ ï¼ˆæ ‘ä¸­èŠ‚ç‚¹å­©å­çš„æ•°é‡å°±æ˜¯é›†åˆçš„å¤§å°ï¼‰) &#123;    å¤„ç†èŠ‚ç‚¹;    backtracking(è·¯å¾„ï¼Œé€‰æ‹©åˆ—è¡¨); // é€’å½’    å›æº¯ï¼Œæ’¤é”€å¤„ç†ç»“æœ&#125;\n\næ€»ç»“èµ·æ¥æ¨¡æ¿å¦‚ä¸‹ï¼š\nvoid backtracking(å‚æ•°) &#123;    if (ç»ˆæ­¢æ¡ä»¶) &#123;        å­˜æ”¾ç»“æœ;        return;    &#125;    for (é€‰æ‹©ï¼šæœ¬å±‚é›†åˆä¸­å…ƒç´ ï¼ˆæ ‘ä¸­èŠ‚ç‚¹å­©å­çš„æ•°é‡å°±æ˜¯é›†åˆçš„å¤§å°ï¼‰) &#123;        å¤„ç†èŠ‚ç‚¹;        backtracking(è·¯å¾„ï¼Œé€‰æ‹©åˆ—è¡¨); // é€’å½’        å›æº¯ï¼Œæ’¤é”€å¤„ç†ç»“æœ    &#125;&#125;\n\n77. ç»„åˆ\nlink\n\nç»™å®šä¸¤ä¸ªæ•´æ•° n å’Œ kï¼Œè¿”å› 1 â€¦ n ä¸­æ‰€æœ‰å¯èƒ½çš„ k ä¸ªæ•°çš„ç»„åˆã€‚\nç¤ºä¾‹: è¾“å…¥: n &#x3D; 4, k &#x3D; 2 è¾“å‡º: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]\næ€è·¯ç›´æ¥çš„æ€è·¯ä¸º k é‡å¾ªç¯ã€‚ä½†æ˜¯ k å¾ˆå¤§æ—¶å°±å†™ä¸å‡ºæ¥äº†ã€‚\nè¦è§£å†³ n ä¸º 100ï¼Œk ä¸º 50 çš„æƒ…å†µï¼Œæš´åŠ›å†™æ³•éœ€è¦åµŒå¥— 50 å±‚ for å¾ªç¯ï¼Œé‚£ä¹ˆå›æº¯æ³•å°±ç”¨é€’å½’æ¥è§£å†³åµŒå¥—å±‚æ•°çš„é—®é¢˜ã€‚\nç»„åˆé—®é¢˜å¯ä»¥æŠ½è±¡ä¸ºï¼š\n\næ¯æ¬¡ä»é›†åˆä¸­é€‰å–å…ƒç´ ï¼Œå¯é€‰æ‹©çš„èŒƒå›´éšç€é€‰æ‹©çš„è¿›è¡Œè€Œæ”¶ç¼©ï¼Œè°ƒæ•´å¯é€‰æ‹©çš„èŒƒå›´ã€‚å›¾ä¸­å¯ä»¥å‘ç° n ç›¸å½“äºæ ‘çš„å®½åº¦ï¼Œk ç›¸å½“äºæ ‘çš„æ·±åº¦ã€‚é‚£ä¹ˆå¦‚ä½•åœ¨è¿™ä¸ªæ ‘ä¸Šéå†ï¼Œç„¶åæ”¶é›†åˆ°æˆ‘ä»¬è¦çš„ç»“æœé›†å‘¢ï¼Ÿå›¾ä¸­æ¯æ¬¡æœç´¢åˆ°äº†å¶å­èŠ‚ç‚¹ï¼Œæˆ‘ä»¬å°±æ‰¾åˆ°äº†ä¸€ä¸ªç»“æœã€‚\n\né€’å½’å‡½æ•°çš„è¿”å›å€¼å’Œå‚æ•°ï¼šn å’Œ kï¼Œä»¥åŠä¸€ä¸ªèµ·å§‹ç´¢å¼• startï¼Œç”¨äºæŒ‡å®šä»å“ªä¸ªä½ç½®å¼€å§‹å–æ•°ã€‚æ­¤å¤–ï¼Œè¿˜éœ€è¦ä¸¤ä¸ªå…¨å±€å˜é‡ï¼Œä¸€ä¸ªç”¨äºå­˜æ”¾æ‰€æœ‰çš„ç»“æœ resï¼Œå¦ä¸€ä¸ªç”¨äºå­˜æ”¾å½“å‰è·¯å¾„ä¸‹çš„ç»“æœ curã€‚\né€’å½’å‡½æ•°çš„ç»ˆæ­¢æ¡ä»¶ï¼šå½“å‰è·¯å¾„ä¸‹çš„ç»“æœé•¿åº¦ç­‰äº kï¼Œå³ len(cur) &#x3D;&#x3D; kï¼Œå°±è¯´æ˜åˆ°äº†å¶å­èŠ‚ç‚¹ã€‚\nå•å±‚æœç´¢çš„è¿‡ç¨‹ï¼šå›æº¯æ³•çš„æœç´¢è¿‡ç¨‹å°±æ˜¯ä¸€ä¸ªæ ‘å‹ç»“æ„çš„éå†è¿‡ç¨‹ï¼Œfor å¾ªç¯ç”¨æ¥æ¨ªå‘éå†ï¼ˆå½“å±‚ï¼‰ï¼Œé€’å½’çš„è¿‡ç¨‹æ˜¯çºµå‘éå†ã€‚æ‰€ä»¥ for å¾ªç¯ä» start å¼€å§‹éå†ï¼Œç„¶åé€’å½’ä¸‹ä¸€å±‚ã€‚\n\nä»£ç å¦‚ä¸‹ï¼Œæ³¨æ„ä¸¤ä¸ªç‚¹ï¼š\n\næŠŠå½“å‰ç»“æœ cur åŠ å…¥æœ€ç»ˆç»“æœ res æ—¶ï¼Œä¸èƒ½ç›´æ¥ res.append(cur)ï¼Œå› ä¸º list æ˜¯å¯å˜å¯¹è±¡ï¼Œè¿™æ ·å†™æ˜¯æ·±æ‹·è´ï¼ŒåŠ å…¥ res çš„æ˜¯å¼•ç”¨ã€‚éœ€è¦å†™æˆ res.append(cur[:]) æˆ– res.append(list(cur))ã€‚\nç¬¬ä¸€æ¬¡è°ƒç”¨å›æº¯å‡½æ•°æ—¶ï¼Œstart åº”è¯¥æ˜¯ 1ï¼Œä¸æ˜¯ 0ã€‚\n\nclass Solution:    def combine(self, n: int, k: int) -&gt; List[List[int]]:        res = []        cur = []        def backtrack(n, k, start):            if len(cur) == k:                res.append(cur[:])                return                        for i in range(start, n+1):                # æŠŠå½“å‰èŠ‚ç‚¹åŠ å…¥åˆ°ç»“æœä¸­                cur.append(i)                # å¤„ç†ä¸‹ä¸€å±‚                backtrack(n, k, i + 1)                # å°†å½“å‰å…ƒç´ ç§»é™¤ï¼Œç„¶åå¤„ç†ä¸‹ä¸€ä¸ªå…ƒç´                 cur.pop()        backtrack(n, k, 1)        return res \n\nå‡æä¼˜åŒ–ä¾‹å¦‚ n &#x3D; 4ï¼Œk &#x3D; 4 çš„è¯ï¼Œé‚£ä¹ˆç¬¬ä¸€å±‚ for å¾ªç¯çš„æ—¶å€™ï¼Œä»å…ƒç´  2 å¼€å§‹çš„éå†éƒ½æ²¡æœ‰æ„ä¹‰äº†ã€‚ åœ¨ç¬¬äºŒå±‚ for å¾ªç¯ï¼Œä»å…ƒç´  3 å¼€å§‹çš„éå†éƒ½æ²¡æœ‰æ„ä¹‰äº†ã€‚\n\næ‰€ä»¥ï¼Œå¯ä»¥å‰ªæçš„åœ°æ–¹å°±åœ¨é€’å½’ä¸­æ¯ä¸€å±‚çš„ for å¾ªç¯æ‰€é€‰æ‹©çš„ç»“æŸä½ç½®ã€‚ä¼˜åŒ–è¿‡ç¨‹ä¸ºï¼š\n\nå·²ç»æœ‰çš„å…ƒç´ ä¸ªæ•° len(cur)\nè¿˜éœ€è¦çš„ä¸ªæ•° k - len(cur)\nå½“å‰é›†åˆæœ€å¤šå…è®¸çš„ç»“æŸä½ç½® n - (k - len(cur)) + 1ã€‚\nåé¢å‰©ä¸‹çš„è¦ç•™ç»™åç»­å±‚æ¥éå†ï¼Œå³åé¢è¿˜éœ€è¦å‰©ä¸‹ k - len(cur) ä¸ªå…ƒç´ \næ³¨æ„è¿™ä¸ª +1ï¼Œä¾‹å¦‚åœ¨ç¬¬äºŒå±‚ï¼Œlen(cur) &#x3D;&#x3D; 1ï¼Œè¿˜éœ€è¦ 3ï¼Œä»åå¾€å‰æ•° 3 ä¸ªï¼Œåªèƒ½åˆ° 2ï¼ˆæ˜¯åœ¨ [1, 2, 3, 4] é‡Œé¢ï¼‰ï¼Œn - (k - len(cur)) &#x3D;&#x3D; 1ï¼Œæ‰€ä»¥è¿™é‡Œæœ‰ä¸€ä¸ª +1ã€‚æ³¨æ„è¿™é‡Œä¸æ˜¯ç´¢å¼•ï¼Œè€Œæ˜¯è¦é€‰çš„æ•°å­—ã€‚\næ­¤å¤–ï¼Œç”±äº range æ˜¯å·¦é—­å³å¼€ï¼Œæ‰€ä»¥ä»£ç ä¸­æ˜¯ +2ã€‚\n\n\n\nclass Solution:    def combine(self, n: int, k: int) -&gt; List[List[int]]:        res = []        cur = []        def backtrack(n, k, start):            if len(cur) == k:                res.append(cur[:])                return            # å‡æï¼Œæ³¨æ„è¿™ä¸ª +2            for i in range(start, n - (k - len(cur)) + 2):                # æŠŠå½“å‰èŠ‚ç‚¹åŠ å…¥åˆ°ç»“æœä¸­                cur.append(i)                # å¤„ç†ä¸‹ä¸€å±‚                backtrack(n, k, i + 1)                # å°†å½“å‰å…ƒç´ ç§»é™¤ï¼Œç„¶åå¤„ç†ä¸‹ä¸€ä¸ªå…ƒç´                 cur.pop()        backtrack(n, k, 1)        return res \n\n\n17.ç”µè¯å·ç å’Œå­—æ¯çš„ç»„åˆ\nlink\n\nç»™å®šä¸€ä¸ªä»…åŒ…å«æ•°å­— 2-9 çš„å­—ç¬¦ä¸²ï¼Œè¿”å›æ‰€æœ‰å®ƒèƒ½è¡¨ç¤ºçš„å­—æ¯ç»„åˆã€‚ç­”æ¡ˆå¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ã€‚ç»™å‡ºæ•°å­—åˆ°å­—æ¯çš„æ˜ å°„å¦‚ä¸‹ï¼ˆä¸ç”µè¯æŒ‰é”®ç›¸åŒï¼‰ã€‚æ³¨æ„ 1 ä¸å¯¹åº”ä»»ä½•å­—æ¯ã€‚\n\næ€è·¯ç±»ä¼¼äº 77.ç»„åˆï¼Œåªä¸è¿‡æ¯ä¸€å±‚éå†çš„å¯¹è±¡éƒ½ä¸ä¸€æ ·ï¼Œéœ€è¦å»ºç«‹ä¸€ä¸ªæ•°å­—å’Œå­—ç¬¦ä¸²æ˜ å°„çš„å­—å…¸ã€‚é€’å½’è°ƒç”¨çš„å‚æ•°è¦åŒ…å«ä¸€ä¸ªç´¢å¼•ï¼Œè¡¨ç¤ºå½“å‰å±‚åº”è¯¥è®¿é—®çš„æ•°å­—ã€‚\nclass Solution:    def letterCombinations(self, digits: str) -&gt; List[str]:        m = &#123;            2: &quot;abc&quot;,            3: &quot;def&quot;,            4: &quot;ghi&quot;,            5: &quot;jkl&quot;,            6: &quot;mno&quot;,            7: &quot;pqrs&quot;,            8: &quot;tuv&quot;,            9: &quot;wxyz&quot;        &#125;        res = []        cur = []        def backtract(digits, index):            if len(digits) == 0:                return            if len(cur) == len(digits):                res.append(&quot;&quot;.join(cur))                return            cur_str = m[int(digits[index])]            for i in cur_str:                cur.append(i)                backtract(digits, index+1)                cur.pop()                backtract(digits, 0)        return res\n\n216.ç»„åˆæ€»å’ŒIII\nlink\n\næ‰¾å‡ºæ‰€æœ‰ç›¸åŠ ä¹‹å’Œä¸º n çš„ k ä¸ªæ•°çš„ç»„åˆï¼Œä¸”æ»¡è¶³ä¸‹åˆ—æ¡ä»¶ï¼š\nåªä½¿ç”¨æ•°å­— 1 åˆ° 9ï¼Œæ¯ä¸ªæ•°å­— æœ€å¤šä½¿ç”¨ä¸€æ¬¡ã€‚è¿”å› æ‰€æœ‰å¯èƒ½çš„æœ‰æ•ˆç»„åˆçš„åˆ—è¡¨ ã€‚è¯¥åˆ—è¡¨ä¸èƒ½åŒ…å«ç›¸åŒçš„ç»„åˆä¸¤æ¬¡ï¼Œç»„åˆå¯ä»¥ä»¥ä»»ä½•é¡ºåºè¿”å›ã€‚\n\nè¾“å…¥: k &#x3D; 3, n &#x3D; 9è¾“å‡º: [[1,2,6], [1,3,5], [2,3,4]]è§£é‡Š:1 + 2 + 6 &#x3D; 91 + 3 + 5 &#x3D; 92 + 3 + 4 &#x3D; 9  \n\næ€è·¯åŒæ ·ç±»ä¼¼äº 77.ç»„åˆï¼Œé€’å½’ä¸‰éƒ¨æ›²ï¼š\n\nå‚æ•°å’Œè¿”å›å€¼ï¼šå‚æ•°ä¸ºå½“å‰å±‚çš„èµ·å§‹å€¼ startï¼ˆåº”è¯¥ä»å“ªä¸ªæ•°å¼€å§‹é€‰ï¼‰å’Œå½“å‰çš„ç»¼åˆ totalï¼ˆé¿å…å¤šæ¬¡è°ƒç”¨ sum å‡½æ•°ï¼‰\né€’å½’ç»ˆæ­¢æ¡ä»¶ï¼šå½“å‰ç»“æœ cur é•¿åº¦ä¸º kï¼Œå¹¶ä¸”å’Œä¸º nï¼Œåˆ™å°†å½“å‰ç»“æœåŠ å…¥åˆ° resï¼›å¦‚æœå’Œå¤§äº n æˆ–è€…é•¿åº¦å¤§äº kï¼Œåˆ™ç›´æ¥è¿”å›ï¼ˆå‰ªææ“ä½œï¼‰\né€’å½’æ ¸å¿ƒé€»è¾‘ï¼šå’Œ 77.ç»„åˆ ç±»ä¼¼ã€‚\n\nclass Solution:    def combinationSum3(self, k: int, n: int) -&gt; List[List[int]]:        res = []        cur = []        def backtrack(start, total):            if len(cur) &gt; k or total &gt; n:                return            if len(cur) == k and total == n:                res.append(cur[:])                return            for i in range(start, 10):                cur.append(i)                backtrack(i + 1, total + i)                cur.pop()        backtrack(1, 0)        return res\n\n39.ç»„åˆæ€»å’Œ\nlinkç»™ä½ ä¸€ä¸ª æ— é‡å¤å…ƒç´  çš„æ•´æ•°æ•°ç»„ candidates å’Œä¸€ä¸ªç›®æ ‡æ•´æ•° target ï¼Œæ‰¾å‡º candidates ä¸­å¯ä»¥ä½¿æ•°å­—å’Œä¸ºç›®æ ‡æ•° target çš„ æ‰€æœ‰ ä¸åŒç»„åˆ ï¼Œå¹¶ä»¥åˆ—è¡¨å½¢å¼è¿”å›ã€‚ä½ å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›è¿™äº›ç»„åˆã€‚\n\ncandidates ä¸­çš„ åŒä¸€ä¸ª æ•°å­—å¯ä»¥ æ— é™åˆ¶é‡å¤è¢«é€‰å– ã€‚å¦‚æœè‡³å°‘ä¸€ä¸ªæ•°å­—çš„è¢«é€‰æ•°é‡ä¸åŒï¼Œåˆ™ä¸¤ç§ç»„åˆæ˜¯ä¸åŒçš„ã€‚ å¯¹äºç»™å®šçš„è¾“å…¥ï¼Œä¿è¯å’Œä¸º target çš„ä¸åŒç»„åˆæ•°å°‘äº 150 ä¸ªã€‚\n\nè¾“å…¥ï¼šcandidates &#x3D; [2,3,6,7], target &#x3D; 7è¾“å‡ºï¼š[[2,2,3],[7]]è§£é‡Šï¼š2 å’Œ 3 å¯ä»¥å½¢æˆä¸€ç»„å€™é€‰ï¼Œ2 + 2 + 3 &#x3D; 7 ã€‚æ³¨æ„ 2 å¯ä»¥ä½¿ç”¨å¤šæ¬¡ã€‚7 ä¹Ÿæ˜¯ä¸€ä¸ªå€™é€‰ï¼Œ 7 &#x3D; 7 ã€‚ä»…æœ‰è¿™ä¸¤ç§ç»„åˆã€‚\n\næ€è·¯ç±»ä¼¼äºä¸Šä¸€é¢˜ï¼Œåªä¸è¿‡é€’å½’çš„ä¸»é€»è¾‘ä¸­ï¼Œå†æ¬¡é€’å½’æ—¶ï¼Œæ•°ç»„è®¿é—®çš„èµ·ç‚¹å¯ä»¥å’Œå½“å‰ç›¸åŒï¼ˆå› ä¸ºå¯ä»¥é‡å¤é€‰æŸäº›æ•°å­—ï¼‰\nclass Solution:    def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:        res = []        cur = []        def backtrack(start, total):            if total == target:                res.append(cur[:])                return            elif total &gt; target:                return             for i in range(start, len(candidates)):                cur.append(candidates[i])                backtrack(i, total+candidates[i])                cur.pop()                    backtrack(0, 0)        return res\n\n\n40.ç»„åˆæ€»å’ŒII\nlink\n\nç»™å®šä¸€ä¸ªå€™é€‰äººç¼–å·çš„é›†åˆ candidates å’Œä¸€ä¸ªç›®æ ‡æ•° target ï¼Œæ‰¾å‡º candidates ä¸­æ‰€æœ‰å¯ä»¥ä½¿æ•°å­—å’Œä¸º target çš„ç»„åˆã€‚candidates ä¸­çš„æ¯ä¸ªæ•°å­—åœ¨æ¯ä¸ªç»„åˆä¸­åªèƒ½ä½¿ç”¨ ä¸€æ¬¡ ã€‚æ³¨æ„ï¼šè§£é›†ä¸èƒ½åŒ…å«é‡å¤çš„ç»„åˆã€‚candidates ä¸­å¯èƒ½æœ‰é‡å¤çš„å…ƒç´ ã€‚\nç¤ºä¾‹ 1:\nè¾“å…¥: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,è¾“å‡º:[[1,1,6],[1,2,5],[1,7],[2,6]]\næ€è·¯å’Œä¸Šä¸€é¢˜ä¸€æ ·ï¼Œåªä¸è¿‡æ·»åŠ äº†ä¸èƒ½é€‰å–é‡å¤æ•°å­—çš„é™åˆ¶ã€‚åªéœ€è¦åœ¨é€’å½’çš„é€»è¾‘ä¸­æ›´æ”¹å³å¯ã€‚ä½†æ˜¯æ³¨æ„ï¼Œcandidates ä¸­å¯èƒ½æœ‰é‡å¤å…ƒç´ ï¼Œä¾‹å¦‚ candidates &#x3D; [1,1,2]ï¼Œtarget &#x3D; 3ï¼Œä¸¤ä¸ª 1 éƒ½ä¼šè¢«é€‰ï¼Œæ‰€ä»¥ç»“æœä¸º [[1,2],[1,2]]ã€‚\næ‰€ä»¥é¦–å…ˆå°† candidates æ’åºï¼Œç„¶ååˆ¤æ–­å½“å‰æ•°å­—æ˜¯å¦å’Œä¸Šä¸€ä¸ªç›¸åŒï¼Œå¦‚æœç›¸åŒå°±è·³è¿‡ã€‚\nclass Solution:    def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]:        res = []        cur = []        candidates.sort()        def backtrack(start, total):            if total == target:                res.append(cur[:])                return            elif total &gt; target:                return             for i in range(start, len(candidates)):                # åˆ¤æ–­å½“å‰æ•°å­—æ˜¯å¦å’Œä¸Šä¸€ä¸ªç›¸åŒï¼Œå¦‚æœç›¸åŒå°±è·³è¿‡                if i &gt; start and candidates[i] == candidates[i - 1]:                    continue                cur.append(candidates[i])                backtrack(i+1, total+candidates[i])                cur.pop()                    backtrack(0, 0)        return res     ","categories":["Leetcode"],"tags":["backtrack"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘å›æº¯3-å­é›†","url":"/blog/Leetcode/backtrack3/","content":"78.å­é›†\nlinkç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œæ•°ç»„ä¸­çš„å…ƒç´  äº’ä¸ç›¸åŒ ã€‚è¿”å›è¯¥æ•°ç»„æ‰€æœ‰å¯èƒ½çš„å­é›†ï¼ˆå¹‚é›†ï¼‰ã€‚è§£é›† ä¸èƒ½ åŒ…å«é‡å¤çš„å­é›†ã€‚ä½ å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›è§£é›†ã€‚\n\næ€è·¯å¦‚æœæŠŠ å­é›†é—®é¢˜ã€ç»„åˆé—®é¢˜ã€åˆ†å‰²é—®é¢˜éƒ½æŠ½è±¡ä¸ºä¸€æ£µæ ‘çš„è¯ï¼Œé‚£ä¹ˆç»„åˆé—®é¢˜å’Œåˆ†å‰²é—®é¢˜éƒ½æ˜¯æ”¶é›†æ ‘çš„å¶å­èŠ‚ç‚¹ï¼Œè€Œå­é›†é—®é¢˜æ˜¯æ‰¾æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹ã€‚\n\nåªéœ€è¦åœ¨å›æº¯å‡½æ•°ä¸­æ¯æ¬¡éƒ½æ·»åŠ å½“å‰ç»“æœå³å¯ï¼Œæ³¨æ„å¯ä»¥ä¸æ·»åŠ ç»ˆæ­¢å‡½æ•°ã€‚\nclass Solution:    def subsets(self, nums: List[int]) -&gt; List[List[int]]:        res = []        cur = []        def backtrack(start):            res.append(cur[:])            # if start == len(nums):            #     return            for i in range(start, len(nums)):                cur.append(nums[i])                backtrack(i + 1)                cur.pop()                    backtrack(0)        return res\n90.å­é›†II\nlink\n\nå’Œä¸Šä¸€é¢˜ç±»ä¼¼ï¼Œåªä¸è¿‡ç»™å®šçš„ nums å¯èƒ½åŒ…å«é‡å¤å…ƒç´ \næ€è·¯ç›´æ¥ç”¨ä¸Šä¸€é¢˜çš„ä»£ç ä¼šé‡å¤é€‰æ‹©æŸäº›å…ƒç´ ï¼Œè§£å†³æ–¹æ³•å¯ä»¥æ˜¯å…ˆå°†æ•°æ®è¿›è¡Œæ’åºï¼Œç„¶ååˆ¤æ–­å½“å‰å…ƒç´ å’Œå‰ä¸€ä¸ªé€‰æ‹©çš„å…ƒç´ æ˜¯å¦ç›¸ç­‰ï¼Œå¦‚æœç›¸ç­‰åˆ™è·³è¿‡ã€‚\nclass Solution:    def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]:        res = []        cur = []        nums.sort()        def backtrack(start):            res.append(cur[:])            # if start == len(nums):            #     return            pre = None            for i in range(start, len(nums)):                if pre == None or pre != nums[i]:                    cur.append(nums[i])                    backtrack(i + 1)                    pre = cur.pop()                        backtrack(0)        return res\n\næ›´æ­£ç¡®ï¼ˆï¼Ÿï¼‰çš„å†™æ³•ï¼Œåˆ†æ¸…æ¥šæ ‘æå’Œæ ‘å±‚ä¹‹é—´çš„å…³ç³»ï¼Œä½¿ç”¨ä¸€ä¸ª used æ•°ç»„ï¼Œå¦‚æœå½“å‰æ•°å­—å’Œå‰ä¸€ä¸ªæ•°å­—ç›¸åŒï¼Œå¹¶ä¸” å‰ä¸€ä¸ªæ•°å­—å·²ç» usedï¼Œè¯´æ˜å½“å‰å±‚å·²ç»ç”¨è¿‡è¯¥æ•°å­—ï¼Œéœ€è¦è·³è¿‡ã€‚\n\nused[i - 1] &#x3D;&#x3D; trueï¼Œè¯´æ˜åŒä¸€æ ‘æ candidates[i - 1]ä½¿ç”¨è¿‡used[i - 1] &#x3D;&#x3D; falseï¼Œè¯´æ˜åŒä¸€æ ‘å±‚ candidates[i - 1]ä½¿ç”¨è¿‡è€Œæˆ‘ä»¬è¦å¯¹åŒä¸€æ ‘å±‚ä½¿ç”¨è¿‡çš„å…ƒç´ è¿›è¡Œè·³è¿‡  \n\n\næ³¨æ„éœ€è¦åŠ¨æ€æ›´æ–° used æ•°ç»„ã€‚\nclass Solution:    def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]:        res = []        cur = []        used = [False] * len(nums)        nums.sort()        def backtrack(start):            res.append(cur[:])                        for i in range(start, len(nums)):                if i != 0 and used[i - 1] == False and nums[i] == nums[i-1]:                    continue                cur.append(nums[i])                used[i] = True                backtrack(i + 1)                used[i] = False                cur.pop()                             backtrack(0)        return res","categories":["Leetcode"],"tags":["backtrack"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘å›æº¯2-åˆ†å‰²å›æ–‡ä¸²","url":"/blog/Leetcode/backtrack2/","content":"131.åˆ†å‰²å›æ–‡ä¸²\nlink\n\nç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œè¯·ä½ å°† s åˆ†å‰²æˆä¸€äº› å­ä¸²ï¼Œä½¿æ¯ä¸ªå­ä¸²éƒ½æ˜¯ å›æ–‡ä¸² ã€‚è¿”å› s æ‰€æœ‰å¯èƒ½çš„åˆ†å‰²æ–¹æ¡ˆã€‚\næ€è·¯ç±»ä¼¼äºç»„åˆé—®é¢˜ï¼Œä¹Ÿå¯ä»¥æŠ½çº¿æˆä¸€æ£µæ ‘\n\n\né€’å½’å‚æ•°ï¼šå½“å‰å­—ç¬¦ä¸²çš„èµ·å§‹ä½ç½®\nç»“æŸæ¡ä»¶ï¼šéå†åˆ°å­—ç¬¦ä¸²æœ«å°¾å°±ç»“æŸï¼Œå¹¶å°† cur åŠ å…¥ resã€‚ï¼ˆé€’å½’é€»è¾‘ä¸­ä¿è¯å½“å‰ cur ä¸€å®šæ˜¯æ»¡è¶³æ¡ä»¶çš„ï¼‰\né€’å½’é€»è¾‘ï¼šå¦‚æœå½“å‰å­ä¸²æ˜¯å›æ–‡ä¸²åˆ™åŠ å…¥ curï¼Œå¹¶ä¸”å‘ä¸‹é€’å½’ã€‚æ³¨æ„ï¼Œå¦‚æœå½“å‰å­ä¸²ä¸æ˜¯å›æ–‡ä¸²åˆ™ç›´æ¥å‰ªæï¼Œä¸è¿›è¡Œåç»­æ­¥éª¤ã€‚ï¼ˆä¿è¯å½“å‰ cur ä¸€å®šæ˜¯æ»¡è¶³æ¡ä»¶çš„ï¼‰\n\nclass Solution:    def partition(self, s: str) -&gt; List[List[str]]:        res = []        cur = []        def ishuiwen(start, end):            while start &lt;= end:                if s[start] != s[end]:                    return False                start += 1                end -= 1            return True        def backtrack(start):            if start == len(s):                res.append(cur[:])                return                        for i in range(start, len(s)):                if ishuiwen(start, i):                    cur.append(s[start:i+1])                    backtrack(i+1)                    cur.pop()           backtrack(0)        return res\n\n93.å¤åŸIPåœ°å€\nlink\n\næœ‰æ•ˆ IP åœ°å€ æ­£å¥½ç”±å››ä¸ªæ•´æ•°ï¼ˆæ¯ä¸ªæ•´æ•°ä½äº 0 åˆ° 255 ä¹‹é—´ç»„æˆï¼Œä¸”ä¸èƒ½å«æœ‰å‰å¯¼ 0ï¼‰ï¼Œæ•´æ•°ä¹‹é—´ç”¨ â€˜.â€™ åˆ†éš”\næ€è·¯é€’å½’çš„é€»è¾‘ä¸­ï¼Œç”±äº ip åœ°å€æœ€é•¿ä¸º 3 ä½ï¼Œæ‰€ä»¥ for å¾ªç¯åªéœ€è¦å¾ªç¯ä¸‰æ¬¡ï¼Œä½†æ˜¯è¦è€ƒè™‘åˆ°ä¸èƒ½è¶…è¿‡ s çš„é•¿åº¦ï¼Œæ‰€ä»¥ range çš„ç»“æŸç‚¹ä¸º min(start + 3, len(s))ã€‚\nclass Solution:    def restoreIpAddresses(self, s: str) -&gt; List[str]:        res = []        cur = []        def isvad(subs):            num = int(subs)            if num == 0 and len(subs) == 1:                return True            if num == 0 and len(subs) &gt; 1:                return False            elif subs[0] == &#x27;0&#x27;:                return False            elif num &gt; 255:                return False            else:                return True                def backtrack(start):            if start == len(s) and len(cur) == 4:                res.append(&quot;.&quot;.join(cur))                return            if len(cur) &gt; 4:                return                        for i in range(start, min(start + 3, len(s))):                if isvad(s[start:i+1]):                    cur.append(s[start:i+1])                    backtrack(i+1)                    cur.pop()        backtrack(0)        return res\n","categories":["Leetcode"],"tags":["backtrack"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘å›æº¯4-æ’åˆ—","url":"/blog/Leetcode/backtrack4/","content":"46.å…¨æ’åˆ—\nlink\n\nç»™å®šä¸€ä¸ªä¸å«é‡å¤æ•°å­—çš„æ•°ç»„ nums ï¼Œè¿”å›å…¶ æ‰€æœ‰å¯èƒ½çš„å…¨æ’åˆ— ã€‚ä½ å¯ä»¥ æŒ‰ä»»æ„é¡ºåº è¿”å›ç­”æ¡ˆã€‚\næ€è·¯\nå‚æ•°å’Œè¿”å›å€¼ï¼šæ’åºæ˜¯æœ‰åºçš„ï¼Œä¹Ÿå°±æ˜¯è¯´ [1,2] å’Œ [2,1] æ˜¯ä¸¤ä¸ªé›†åˆï¼Œæ‰€ä»¥å¤„ç†æ’åˆ—é—®é¢˜å°±ä¸ç”¨ä½¿ç”¨startIndexäº†ã€‚ä½†æ’åˆ—é—®é¢˜éœ€è¦ä¸€ä¸ªusedæ•°ç»„ï¼Œæ ‡è®°å·²ç»é€‰æ‹©çš„å…ƒç´ ï¼Œå¦‚å›¾æ©˜é»„è‰²éƒ¨åˆ†æ‰€ç¤ºã€‚\n\nç»ˆæ­¢æ¡ä»¶ï¼šcur é•¿åº¦ç­‰äº nums é•¿åº¦\n\nå•å±‚é€»è¾‘ï¼šæ¯æ¬¡éƒ½éœ€è¦ä»å¤´å¼€å§‹é€‰å–ï¼Œä¸èƒ½ä» start å¼€å§‹ã€‚æ­¤æ—¶ä½¿ç”¨ used æ•°ç»„æ¥æ ‡è¯†å½“å‰å…ƒç´ æ˜¯å¦è¢«ä½¿ç”¨è¿‡ã€‚\n\n\nclass Solution:    def permute(self, nums: List[int]) -&gt; List[List[int]]:        cur = []        res = []        used = [False] * len(nums)        def backtrack():            if len(cur) == len(nums):                res.append(cur[:])                return                         for i in range(len(nums)):                if used[i]:                    continue                                cur.append(nums[i])                used[i] = True                backtrack()                cur.pop()                used[i] = False        backtrack()        return res\n47.å…¨æ’åˆ— II\nlink\n\nå»é‡é€»è¾‘ç±»ä¼¼äº å­é›†IIï¼Œé¦–å…ˆå°†æ•°ç»„æ’åºï¼Œå¦‚æœå½“å‰æ•°å­—å’Œä¸Šä¸€ä¸ªæ•°å­—ç›¸åŒå¹¶ä¸”å½“å‰å±‚å·²ç»ä½¿ç”¨è¿‡ï¼Œå°±è·³è¿‡\n\nused[i - 1] &#x3D;&#x3D; trueï¼Œè¯´æ˜åŒä¸€æ ‘æ candidates[i - 1]ä½¿ç”¨è¿‡used[i - 1] &#x3D;&#x3D; falseï¼Œè¯´æ˜åŒä¸€æ ‘å±‚ candidates[i - 1]ä½¿ç”¨è¿‡è€Œæˆ‘ä»¬è¦å¯¹åŒä¸€æ ‘å±‚ä½¿ç”¨è¿‡çš„å…ƒç´ è¿›è¡Œè·³è¿‡  \n\nclass Solution:    def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]:        cur = []        res = []        used = [False] * len(nums)        nums.sort()        def backtrack():            if len(cur) == len(nums):                res.append(cur[:])                return                         for i in range(len(nums)):                if used[i]:                    continue                if i != 0 and nums[i] == nums[i-1] and used[i-1] == False:                    continue                cur.append(nums[i])                used[i] = True                backtrack()                cur.pop()                used[i] = False        backtrack()        return res","categories":["Leetcode"],"tags":["backtrack"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘å›æº¯5-æ£‹ç›˜é—®é¢˜","url":"/blog/Leetcode/backtrack5/","content":"51. Nçš‡å\nlink\n\næŒ‰ç…§å›½é™…è±¡æ£‹çš„è§„åˆ™ï¼Œçš‡åå¯ä»¥æ”»å‡»ä¸ä¹‹å¤„åœ¨åŒä¸€è¡Œæˆ–åŒä¸€åˆ—æˆ–åŒä¸€æ–œçº¿ä¸Šçš„æ£‹å­ã€‚n çš‡åé—®é¢˜ ç ”ç©¶çš„æ˜¯å¦‚ä½•å°† n ä¸ªçš‡åæ”¾ç½®åœ¨ nÃ—n çš„æ£‹ç›˜ä¸Šï¼Œå¹¶ä¸”ä½¿çš‡åå½¼æ­¤ä¹‹é—´ä¸èƒ½ç›¸äº’æ”»å‡»ã€‚ç»™ä½ ä¸€ä¸ªæ•´æ•° n ï¼Œè¿”å›æ‰€æœ‰ä¸åŒçš„ n çš‡åé—®é¢˜ çš„è§£å†³æ–¹æ¡ˆã€‚æ¯ä¸€ç§è§£æ³•åŒ…å«ä¸€ä¸ªä¸åŒçš„ n çš‡åé—®é¢˜ çš„æ£‹å­æ”¾ç½®æ–¹æ¡ˆï¼Œè¯¥æ–¹æ¡ˆä¸­ â€˜Qâ€™ å’Œ â€˜.â€™ åˆ†åˆ«ä»£è¡¨äº†çš‡åå’Œç©ºä½ã€‚\nç¤ºä¾‹ï¼š\n\nè¾“å…¥ï¼šn &#x3D; 4è¾“å‡ºï¼š[[â€œ.Q..â€,â€â€¦Qâ€,â€Qâ€¦â€,â€..Q.â€],[â€œ..Q.â€,â€Qâ€¦â€,â€â€¦Qâ€,â€.Q..â€]]è§£é‡Šï¼šå¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œ4 çš‡åé—®é¢˜å­˜åœ¨ä¸¤ä¸ªä¸åŒçš„è§£æ³•ã€‚  \n\næ€è·¯æœç´¢çš‡åçš„ä½ç½®å¯ä»¥ç†è§£ä¸ºä¸€æ£µæ ‘ï¼š\n\nä»å›¾ä¸­ï¼Œå¯ä»¥çœ‹å‡ºï¼ŒäºŒç»´çŸ©é˜µä¸­çŸ©é˜µçš„é«˜å°±æ˜¯è¿™æ£µæ ‘çš„é«˜åº¦ï¼ŒçŸ©é˜µçš„å®½å°±æ˜¯æ ‘å½¢ç»“æ„ä¸­æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„å®½åº¦ã€‚é‚£ä¹ˆç”¨çš‡åä»¬çš„çº¦æŸæ¡ä»¶ï¼Œæ¥å›æº¯æœç´¢è¿™æ£µæ ‘ï¼Œåªè¦æœç´¢åˆ°äº†æ ‘çš„å¶å­èŠ‚ç‚¹ï¼Œè¯´æ˜å°±æ‰¾åˆ°äº†çš‡åä»¬çš„åˆç†ä½ç½®äº†ã€‚\né€’å½’ä¸‰éƒ¨æ›²ï¼š\n\nå‚æ•°å’Œè¿”å›å€¼ï¼šåŒæ ·ä½¿ç”¨ res å’Œ cur\nç»ˆæ­¢æ¡ä»¶ï¼šéå†åˆ°æœ€åº•å±‚å°±ç»“æŸï¼Œå¹¶æŠŠ cur åŠ å…¥åˆ° res ä¸­\nå•å±‚é€»è¾‘ï¼šé€’å½’æ·±åº¦å°±æ˜¯ row æ§åˆ¶æ£‹ç›˜çš„è¡Œï¼Œæ¯ä¸€å±‚é‡Œ for å¾ªç¯çš„ col æ§åˆ¶æ£‹ç›˜çš„åˆ—ï¼Œä¸€è¡Œä¸€åˆ—ï¼Œç¡®å®šäº†æ”¾ç½®çš‡åçš„ä½ç½®ã€‚æ¯æ¬¡éƒ½æ˜¯è¦ä»æ–°çš„ä¸€è¡Œçš„èµ·å§‹ä½ç½®å¼€å§‹æœï¼Œæ‰€ä»¥éƒ½æ˜¯ä» 0 å¼€å§‹ã€‚\n\næ­¤å¤–è¿˜éœ€è¦åˆ¤æ–­æ£‹ç›˜æ˜¯å¦åˆæ³•ï¼Œå¯ä»¥è€ƒè™‘å‰ªæï¼Œå³å¯¹äºå½“å‰è€ƒè™‘çš„ä½ç½®ï¼Œåªéœ€è¦è€ƒè™‘å½“å‰åˆ—ã€å·¦ä¸Šè§’å’Œå³ä¸Šè§’æ˜¯å¦å­˜åœ¨çš‡åå³å¯ï¼Œä¸éœ€è¦éå†æ•´ä¸ªæ£‹ç›˜ã€‚ï¼ˆç”±äº for å¾ªç¯ä¸­æ¯æ¬¡åªé€‰æ‹©ä¸€ä¸ªä½ç½®æ”¾çš‡åï¼Œæ‰€ä»¥å½“å‰è¡Œä¸€å®šæ˜¯ç©ºçš„ï¼‰\nclass Solution:    def solveNQueens(self, n: int) -&gt; List[List[str]]:        res = []        cur = [&#x27;.&#x27; * n for _ in range(n)]        def isvad(row, col):            # æ£€æŸ¥åˆ—            for i in range(row):                if cur[i][col] == &#x27;Q&#x27;:                    return False  # å½“å‰åˆ—å·²ç»å­˜åœ¨çš‡åï¼Œä¸åˆæ³•            # æ£€æŸ¥ 45 åº¦è§’æ˜¯å¦æœ‰çš‡å            i, j = row - 1, col - 1            while i &gt;= 0 and j &gt;= 0:                if cur[i][j] == &#x27;Q&#x27;:                    return False  # å·¦ä¸Šæ–¹å‘å·²ç»å­˜åœ¨çš‡åï¼Œä¸åˆæ³•                i -= 1                j -= 1            # æ£€æŸ¥ 135 åº¦è§’æ˜¯å¦æœ‰çš‡å            i, j = row - 1, col + 1            while i &gt;= 0 and j &lt; len(cur):                if cur[i][j] == &#x27;Q&#x27;:                    return False  # å³ä¸Šæ–¹å‘å·²ç»å­˜åœ¨çš‡åï¼Œä¸åˆæ³•                i -= 1                j += 1            return True  # å½“å‰ä½ç½®åˆæ³•        def backtrack(row):            if row &gt;= n:                res.append(cur[:])            for col in range(n):                if isvad(row, col):                    cur[row] = cur[row][:col] + &#x27;Q&#x27; + cur[row][col+1:]                    backtrack(row + 1)                    cur[row] = cur[row][:col] + &#x27;.&#x27; + cur[row][col+1:]        backtrack(0)        return res\n\n37. è§£æ•°ç‹¬\nlinkç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œé€šè¿‡å¡«å……ç©ºæ ¼æ¥è§£å†³æ•°ç‹¬é—®é¢˜ã€‚\n\nä¸€ä¸ªæ•°ç‹¬çš„è§£æ³•éœ€éµå¾ªå¦‚ä¸‹è§„åˆ™ï¼š æ•°å­— 1-9 åœ¨æ¯ä¸€è¡Œåªèƒ½å‡ºç°ä¸€æ¬¡ã€‚ æ•°å­— 1-9 åœ¨æ¯ä¸€åˆ—åªèƒ½å‡ºç°ä¸€æ¬¡ã€‚ æ•°å­— 1-9 åœ¨æ¯ä¸€ä¸ªä»¥ç²—å®çº¿åˆ†éš”çš„ 3x3 å®«å†…åªèƒ½å‡ºç°ä¸€æ¬¡ã€‚ ç©ºç™½æ ¼ç”¨ â€˜.â€™ è¡¨ç¤ºã€‚\næ€è·¯N çš‡åé—®é¢˜æ˜¯æ¯ä¸€è¡Œæ¯ä¸€åˆ—åªæ”¾ä¸€ä¸ªçš‡åï¼Œåªéœ€è¦ä¸€å±‚ for å¾ªç¯éå†ä¸€è¡Œï¼Œé€’å½’æ¥éå†åˆ—ï¼Œç„¶åä¸€è¡Œä¸€åˆ—ç¡®å®šçš‡åçš„å”¯ä¸€ä½ç½®ã€‚æœ¬é¢˜ä¸­æ£‹ç›˜çš„æ¯ä¸€ä¸ªä½ç½®éƒ½è¦æ”¾ä¸€ä¸ªæ•°å­—ï¼ˆè€Œ N çš‡åæ˜¯ä¸€è¡Œåªæ”¾ä¸€ä¸ªçš‡åï¼‰ï¼Œå¹¶æ£€æŸ¥æ•°å­—æ˜¯å¦åˆæ³•ï¼Œè§£æ•°ç‹¬çš„æ ‘å½¢ç»“æ„è¦æ¯” N çš‡åæ›´å®½æ›´æ·±ã€‚\n\né€’å½’ä¸‰éƒ¨æ›²ï¼š\n\nå‚æ•°å’Œè¿”å›å€¼ï¼šè¿”å›å€¼ä¸º boolï¼Œå› ä¸ºè§£æ•°ç‹¬æ‰¾åˆ°ä¸€ä¸ªç¬¦åˆçš„æ¡ä»¶ï¼ˆå°±åœ¨æ ‘çš„å¶å­èŠ‚ç‚¹ä¸Šï¼‰ç«‹åˆ»å°±è¿”å›ï¼Œç›¸å½“äºæ‰¾ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹ä¸€æ¡å”¯ä¸€è·¯å¾„ï¼Œæ‰€ä»¥éœ€è¦ä½¿ç”¨ bool è¿”å›å€¼ã€‚\né€’å½’ç»ˆæ­¢æ¡ä»¶ï¼šä¸ç”¨ç»ˆæ­¢æ¡ä»¶ï¼Œè§£æ•°ç‹¬æ˜¯è¦éå†æ•´ä¸ªæ ‘å½¢ç»“æ„å¯»æ‰¾å¯èƒ½çš„å¶å­èŠ‚ç‚¹å°±ç«‹åˆ»è¿”å›ã€‚\né€’å½’å•å±‚æœç´¢é€»è¾‘ï¼šä¸¤å±‚å¾ªç¯éå†æ‰€æœ‰å¯èƒ½çš„ä½ç½®ã€‚ä¸¤å±‚å¾ªç¯ä¸­ï¼Œä¼šå‡ºç°ä¸¤ç§æƒ…å†µï¼š\nå½“å‰æ ¼é€‰ä¸å‡ºä»»ä½•åˆæ³•çš„æ•°å­—ï¼Œåˆ™è¿”å› False\nå½“å‰ä½ç½®æ”¾ä¸‹æ•°å­—ä¹‹åï¼Œå†æ¬¡é€’å½’è°ƒç”¨ï¼ŒåŒæ ·å‡ºç°ï¼š\né€‰ä¸å‡ºä»»ä½•åˆæ³•æ•°å­—ï¼ˆæˆ–è€…å½“å‰çš„é€’å½’ä¸­æ²¡æœ‰è¿”å› Trueï¼‰ï¼Œè¿”å› Falseï¼Œç„¶åå›æº¯ï¼Œå¤„ç†ä¸‹ä¸€ä¸ªæƒ…å†µ\né‡å¤é€’å½’è°ƒç”¨ï¼Œä¸€ç›´æ²¡æœ‰æŠ¥é”™ï¼Œç›´åˆ°æ•´ä¸ªæ£‹ç›˜è¢«å¡«æ»¡ï¼Œåˆ™è¿”å› Trueã€‚ç„¶åï¼Œå›åˆ°ä¸Šä¸€å±‚é€’å½’ä¸­ï¼ŒåŒæ ·è¿”å› Trueï¼ˆä»£ç ä¸­éƒ¨çš„ returnï¼‰ï¼Œå³æ‰¾åˆ°ä¸€ä¸ªè§£ï¼Œç›´æ¥ç»“æŸé€’å½’ã€‚\n\n\n\n\n\nå…³äºåˆ¤æ–­å†²çªï¼Œéœ€è¦åˆ¤æ–­å½“å‰ä½ç½®æ‰€åœ¨è¡Œã€åˆ—ã€ç½‘æ ¼ä¸­æ˜¯å¦å­˜åœ¨å½“å‰æ•°å­—ã€‚è¡Œå’Œåˆ—æ¯”è¾ƒå¥½ç†è§£ã€‚å¯¹äºç½‘æ ¼ï¼Œé¦–å…ˆéœ€è¦æ‰¾åˆ°å½“å‰ä½ç½®æ‰€åœ¨ç½‘æ ¼çš„å·¦ä¸Šè§’ï¼Œå³ [(row&#x2F;&#x2F;3)*3, (col&#x2F;&#x2F;3)*3]ï¼Œåœ¨æ­¤åŸºç¡€ä¸Š +3 å³ä¸ºéå†çš„ç»“æŸä½ç½®ã€‚\nä¸‹é¢çš„ä»£ç ä¼šæŠ¥è¶…å‡ºæ—¶é—´é™åˆ¶\nclass Solution:    def solveSudoku(self, board: List[List[str]]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify board in-place instead.        &quot;&quot;&quot;        def isvad(row, col, k):            for i in range(9):                if board[row][i] == k:                    return False                if board[i][col] == k:                    return False                        for i in range(3):                for j in range(3):                    if board[(row // 3) * 3 + i][(col // 3) * 3 + j] == k:                        return False            return True                def backtrack():            for i in range(9):                for j in range(9):                    if board[i][j] == &#x27;.&#x27;:                        for k in &#x27;123456789&#x27;:                            if isvad(i, j, k):                                board[i][j] = k                                if backtrack():                                    return True                                board[i][j] = &#x27;.&#x27;                        return False            return True        backtrack()\n\nè¿›ä¸€æ­¥ä¼˜åŒ–ï¼šä½¿ç”¨ set æ¥åˆ¤æ–­æ˜¯å¦é‡å¤ã€‚æå‰æ„å»ºä»¥ä¸‹ä¸‰ä¸ªç»“æ„ï¼š\n\nrows[i]ï¼šç¬¬ i è¡Œä¸­å·²æœ‰æ•°å­—ï¼›\ncols[j]ï¼šç¬¬ j åˆ—ä¸­å·²æœ‰æ•°å­—ï¼›\nboxes[i&#x2F;&#x2F;3][j&#x2F;&#x2F;3]ï¼šç¬¬ i,j æ‰€åœ¨å®«æ ¼å·²æœ‰æ•°å­—ã€‚\n\nè¿™æ · isvad() ä¸éœ€è¦æ¯æ¬¡éå†æ•´è¡Œæ•´åˆ—æ•´å®«æ ¼ï¼Œè€Œæ˜¯ O(1) åˆ¤æ–­ã€‚æ­¤å¤–é€šè¿‡ empty æ¥è®°å½•å½“å‰æ£‹ç›˜ä¸­ç©ºçš„ä½ç½®ï¼Œè¿™æ ·å°±ä¸éœ€è¦ä¸¤é‡éå†äº†ï¼Œè€Œæ˜¯ç›´æ¥éå†å½“å‰çš„ empty æ•°ç»„ã€‚\nå•å±‚çš„é€’å½’é€»è¾‘å’Œä¸Šé¢çš„ä»£ç ç›¸åŒï¼Œå¦‚æœé€’å½’çš„è¿‡ç¨‹ä¸­æ²¡æœ‰è¿”å› Trueï¼Œè€Œæ˜¯ä¸€ç›´åˆ° empty æ•°ç»„çš„æœ«å°¾ï¼Œå¦‚æœå½“å‰çš„ä¸‹æ ‡è¶…è¿‡ empty åˆ™ç›´æ¥è¿”å› Trueã€‚\nclass Solution:    def solveSudoku(self, board: List[List[str]]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify board in-place instead.        &quot;&quot;&quot;        rows = [set() for _ in range(9)]        cols = [set() for _ in range(9)]        # æ³¨æ„åˆå§‹åŒ–å†™æ³•        boxes = [[set() for _ in range(3)] for _ in range(3)]        empty = []        for i in range(9):            for j in range(9):                if board[i][j] == &#x27;.&#x27;:                    empty.append((i, j))                else:                    rows[i].add(board[i][j])                    cols[j].add(board[i][j])                    boxes[i // 3][j // 3].add(board[i][j])        def backtrack(pos):            if pos == len(empty):                return True            i, j = empty[pos]            for ch in &#x27;123456789&#x27;:                if (ch not in rows[i] and                    ch not in cols[j] and                    ch not in boxes[i // 3][j // 3]):                    # æ”¾ç½®                    board[i][j] = ch                    rows[i].add(ch)                    cols[j].add(ch)                    boxes[i // 3][j // 3].add(ch)                    if backtrack(pos + 1):                        return True                    # æ’¤é”€                    board[i][j] = &#x27;.&#x27;                    rows[i].remove(ch)                    cols[j].remove(ch)                    boxes[i // 3][j // 3].remove(ch)            return False                backtrack(0)","categories":["Leetcode"],"tags":["backtrack"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘å›æº¯6","url":"/blog/Leetcode/backtrack6/","content":"491.é€’å¢å­åºåˆ—\nlink\n\nç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œæ‰¾å‡ºå¹¶è¿”å›æ‰€æœ‰è¯¥æ•°ç»„ä¸­ä¸åŒçš„é€’å¢å­åºåˆ—ï¼Œé€’å¢å­åºåˆ—ä¸­ è‡³å°‘æœ‰ä¸¤ä¸ªå…ƒç´  ã€‚ä½ å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ç­”æ¡ˆã€‚æ•°ç»„ä¸­å¯èƒ½å«æœ‰é‡å¤å…ƒç´ ï¼Œå¦‚å‡ºç°ä¸¤ä¸ªæ•´æ•°ç›¸ç­‰ï¼Œä¹Ÿå¯ä»¥è§†ä½œé€’å¢åºåˆ—çš„ä¸€ç§ç‰¹æ®Šæƒ…å†µã€‚\nç¤ºä¾‹ 1ï¼š\n\nè¾“å…¥ï¼šnums &#x3D; [4,6,7,7]è¾“å‡ºï¼š[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]  \n\næ€è·¯æ³¨æ„è¿™é“é¢˜å’Œ ç»„åˆII ç±»ä¼¼ï¼Œä½†æ˜¯ä¸èƒ½å¯¹ç»™å®šçš„æ•°ç»„è¿›è¡Œæ’åºï¼Œä¹Ÿå°±ä¸èƒ½ä½¿ç”¨ used æ•°ç»„æ¥è¿›è¡Œå»é‡ã€‚æ‰€ä»¥ä½¿ç”¨ set æ¥è¿›è¡Œå»é‡ã€‚\n\næ³¨æ„åˆ¤æ–­æ˜¯å¦åŠ å…¥å½“å‰å…ƒç´ çš„æ¡ä»¶æœ‰ä¸¤ä¸ªï¼Œåªè¦æ»¡è¶³å…¶ä¸€å°±è·³è¿‡\n\nå½“å‰å…ƒç´ å°äº cur çš„æœ«å°¾å…ƒç´ ï¼ˆcur ä¸ä¸ºç©ºæ—¶ï¼‰\nå½“å‰å…ƒç´ ä½¿ç”¨è¿‡ï¼ˆåœ¨ set ä¸­ï¼‰\n\nclass Solution:    def findSubsequences(self, nums: List[int]) -&gt; List[List[int]]:        res = []        cur = []                def backtrack(start):            if len(cur) &gt;= 2:                res.append(cur[:])            uset = set()            for i in range(start, len(nums)):                if (cur and nums[i] &lt; cur[-1]) or nums[i] in uset:                    continue                uset.add(nums[i])                cur.append(nums[i])                backtrack(i + 1)                cur.pop()                             backtrack(0)        return res\n\n332.é‡æ–°å®‰æ’è¡Œç¨‹\nlink\n\nç»™å®šä¸€ç»„æœºç¥¨ tickets &#x3D; [[â€œJFKâ€, â€œSFOâ€], [â€œJFKâ€, â€œATLâ€], [â€œSFOâ€, â€œATLâ€], â€¦]ï¼›\næ¯å¼ ç¥¨åªç”¨ä¸€æ¬¡ï¼›è¦æ±‚ä» â€œJFKâ€ å‡ºå‘ï¼Œæ‰¾å‡ºæŒ‰å­—å…¸åºæœ€å°çš„è¡Œç¨‹ï¼›è¾“å‡ºä¸€ä¸ªè¡Œç¨‹åˆ—è¡¨ï¼Œæ¯”å¦‚ [â€œJFKâ€, â€œATLâ€, â€œJFKâ€, â€œSFOâ€, â€œATLâ€, â€œSFOâ€]ã€‚\næ€è·¯é¦–å…ˆéœ€è¦æŠŠæ‰€æœ‰çš„æœºç¥¨å­˜èµ·æ¥ï¼Œä½¿ç”¨ dict æ¥è¿›è¡Œå­˜å‚¨ï¼Œç„¶åå½“å‰çš„ç»“æœ cur ä¸€å®šä»¥ â€œJFKâ€ å¼€å¤´ã€‚é€’å½’ä¸‰éƒ¨æ›²ï¼š\n\né€’å½’å‚æ•°å’Œè¿”å›å€¼ï¼šå¦‚æœæ‰¾åˆ°ä¸€æ¡è·¯å¾„ï¼Œå°±è¿”å› Trueï¼Œç±»ä¼¼äºè§£æ•°ç‹¬\nç»ˆæ­¢æ¡ä»¶ï¼šéå†å®Œæ‰€æœ‰çš„ ticketï¼ŒåŒæ ·ç±»ä¼¼äºè§£æ•°ç‹¬\næ ¸å¿ƒé€»è¾‘ï¼šè·å–å½“å‰ cur çš„æœ«å°¾æœºåœºï¼Œç„¶åéå†ä»¥å½“å‰æœ«å°¾æœºåœºå‡ºå‘çš„ ticketï¼Œå°†å½“å‰ ticket åŠ å…¥ curï¼Œç„¶åé€’å½’è°ƒç”¨ã€‚\n\nfrom collections import defaultdictclass Solution:    def findItinerary(self, tickets: List[List[str]]) -&gt; List[str]:        graph = defaultdict(list)        for frm, to in tickets:            graph[frm].append(to)        # æŒ‰å­—å…¸åºæ’åºæ‰€æœ‰å‡ºå‘æœºåœºçš„ç›®çš„åœ°åˆ—è¡¨        for frm in graph:            graph[frm].sort()        path = [&quot;JFK&quot;]  # åˆå§‹è·¯å¾„ä» JFK å¼€å§‹        ticket_count = len(tickets)        def backtrack():            if len(path) == ticket_count + 1:                return True  # ç”¨å®Œæ‰€æœ‰æœºç¥¨ï¼Œè·¯å¾„åˆæ³•            curr = path[-1]            for i in range(len(graph[curr])):                next_city = graph[curr][i]                if next_city == &quot;#&quot;:                    continue  # &quot;#&quot; è¡¨ç¤ºè¯¥æœºç¥¨å·²ç»ç”¨è¿‡äº†                # æ ‡è®°ä½¿ç”¨                graph[curr][i] = &quot;#&quot;  # ä¸´æ—¶æ›¿æ¢æ‰                path.append(next_city)                if backtrack():                    return True                # å›æº¯æ’¤é”€                path.pop()                graph[curr][i] = next_city  # æ¢å¤æœºç¥¨            return False        backtrack()        return path\n\næ³¨æ„ï¼š\n\næ¯å¼ æœºç¥¨åªèƒ½ç”¨ä¸€æ¬¡ï¼Œæ‰€ä»¥è¦æ ‡è®°ç”¨è¿‡\næŒ‰å­—å…¸åºæ’åºé‚»æ¥è¡¨æ¥ç¡®ä¿æœ€å°è·¯å¾„å…ˆè¢«è¯•å‡ºæ¥\nèµ·ç‚¹å¿…é¡»æ˜¯ â€œJFKâ€\tå›ºå®šå‡ºå‘ç‚¹\nå›æº¯éœ€æ¢å¤ç°åœºï¼Œæ¢å¤ cur å’Œæœºç¥¨ä½¿ç”¨çŠ¶æ€\n\nç›®å‰å›æº¯æ³•ä¼šè¶…æ—¶ï¼Ÿï¼Ÿ\n","categories":["Leetcode"],"tags":["backtrack"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘åŒæŒ‡é’ˆæ³•","url":"/blog/Leetcode/double-pointer/","content":"æ•°ç»„ç§»é™¤å…ƒç´ \nç§»é™¤å…ƒç´ \n\nåœ¨æ•°ç»„ä¸­åŸåœ°ç§»é™¤å…ƒç´ ï¼Œä½¿ç”¨åŒæŒ‡é’ˆï¼Œä¸€ä¸ªæŒ‡å‘éå†çš„ä½ç½®ï¼Œä¸€ä¸ªæŒ‡å‘åˆ é™¤åæ•°ç»„çš„é•¿åº¦\nå­—ç¬¦ä¸²åè½¬å­—ç¬¦ä¸²\nåè½¬å­—ç¬¦ä¸²\n\nä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«ä»å¤´å’Œå°¾å‘ä¸­é—´éå†ï¼Œç›¸äº’äº¤æ¢å­—ç¬¦\næ›¿æ¢æ•°å­—\næ›¿æ¢æ•°å­—\n\nç±»ä¼¼äºç§»é™¤å…ƒç´ ï¼Œä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«ä»£è¡¨æ›¿æ¢åå­—ç¬¦ä¸²çš„çœŸå®ä½ç½®å’Œéå†çš„ä½ç½®ã€‚æ³¨æ„æ˜¯ä»åå¾€å‰å¡«å……ã€‚\nç¿»è½¬å­—ç¬¦ä¸²é‡Œçš„å•è¯\nç¿»è½¬å­—ç¬¦ä¸²é‡Œçš„å•è¯\n\né¦–å…ˆåˆ é™¤å¤šä½™çš„ç©ºæ ¼ï¼ˆåŒæŒ‡é’ˆæ³•ï¼‰ï¼Œç„¶åï¼š\n\nä½¿ç”¨åŒæŒ‡é’ˆæ³•ç¡®å®šæ¯ä¸€ä¸ªå•è¯ï¼Œå¹¶è¿›è¡Œåè½¬ or \nå°†æ•´ä¸ªå­—ç¬¦ä¸²åè½¬ï¼Œç„¶åå†å°†æ¯ä¸ªå•è¯åè½¬å›æ¥\n\né“¾è¡¨åè½¬é“¾è¡¨\nåè½¬é“¾è¡¨\n\nä¸¤ä¸ªæŒ‡é’ˆä¸€å‰ä¸€åï¼Œäº¤æ¢èŠ‚ç‚¹ next çš„æŒ‡å‘ã€‚\nåˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹\nåˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹\n\nå¿«æŒ‡é’ˆå…ˆèµ° N æ­¥ï¼Œç„¶åå’Œæ…¢æŒ‡é’ˆä¸€èµ·èµ°ï¼Œå¿«æŒ‡é’ˆèµ°åˆ°æœ«å°¾ï¼Œæ…¢æŒ‡é’ˆå°±æŒ‡å‘å€’æ•°ç¬¬ N ä¸ªèŠ‚ç‚¹ã€‚\né“¾è¡¨ç›¸äº¤\né“¾è¡¨ç›¸äº¤\n\nåŒæ ·æ˜¯å¿«æ…¢æŒ‡é’ˆï¼Œå…ˆè®©å¿«æŒ‡é’ˆåœ¨é•¿çš„é“¾è¡¨ä¸Šèµ°ä¸¤ä¸ªé“¾è¡¨çš„å·®å€¼ï¼ˆç›®çš„æ˜¯è®©ä¸¤ä¸ªé“¾è¡¨å°¾ç«¯å¯¹é½ï¼‰ï¼Œç„¶åæ…¢æŒ‡é’ˆåœ¨çŸ­é“¾è¡¨ä¸Šå’Œå¿«æŒ‡é’ˆä¸€èµ·èµ°ï¼Œç›´åˆ°æ‰¾åˆ°ç›¸äº¤ç‚¹ã€‚\nç¯å½¢é“¾è¡¨II\nç¯å½¢é“¾è¡¨II\n\nå¿«æŒ‡é’ˆä¸€æ¬¡èµ°ä¸¤æ ¼ï¼Œæ…¢æŒ‡é’ˆä¸€æ¬¡èµ°ä¸€ä¸ªï¼Œåˆ¤æ–­æ˜¯å¦æœ‰ç¯ï¼›å¦‚æœæœ‰ç¯ï¼Œåˆ™è®©ä¸¤ä¸ªæ–°æŒ‡é’ˆåˆ†åˆ«ä»ç›¸é‡ç‚¹å’Œèµ·ç‚¹å‡ºå‘ï¼Œä¸¤ä¸ªæ–°æŒ‡é’ˆç›¸é‡çš„ç‚¹å³ä¸ºç¯çš„èµ·ç‚¹ã€‚\nN æ•°ä¹‹å’Œä¸‰æ•°ä¹‹å’Œ\nä¸‰æ•°ä¹‹å’Œ\n\né¦–å…ˆå°†æ•°ç»„è¿›è¡Œæ’åºï¼Œå¾ªç¯ç¡®å®šç¬¬ä¸€ä¸ªæ•°ï¼Œç„¶åä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«ç¡®å®šåä¸¤ä¸ªæ•°ï¼Œä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«ä¸ºå‰©ä¸‹æ•°ç»„ä¸­æœ€å¤§å’Œæœ€å°çš„æ•°ï¼Œç„¶åä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«é è¿‘å½¼æ­¤ã€‚\nå››æ•°ä¹‹å’Œ\nå››æ•°ä¹‹å’Œ\n\nå’Œä¸‰æ•°ä¹‹å’Œç±»ä¼¼ï¼Œåªä¸è¿‡å¤šåŠ äº†ä¸€å±‚å¾ªç¯ã€‚\næ€»ç»“é™¤äº†é“¾è¡¨ä¸€äº›é¢˜ç›®ä¸€å®šè¦ä½¿ç”¨åŒæŒ‡é’ˆï¼Œå…¶ä»–é¢˜ç›®éƒ½æ˜¯ä½¿ç”¨åŒæŒ‡é’ˆæ¥æé«˜æ•ˆç‡ï¼Œä¸€èˆ¬æ˜¯å°†O(n^2)çš„æ—¶é—´å¤æ‚åº¦ï¼Œé™ä¸º O(n) ã€‚\n","categories":["Leetcode"],"tags":["array","list","hash","string"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘åŠ¨æ€è§„åˆ’1-åŸºç¡€","url":"/blog/Leetcode/dp1/","content":"åŠ¨æ€è§„åˆ’åŠ¨æ€è§„åˆ’ä¸­æ¯ä¸€ä¸ªçŠ¶æ€ä¸€å®šæ˜¯ç”±ä¸Šä¸€ä¸ªçŠ¶æ€æ¨å¯¼å‡ºæ¥çš„ï¼Œè¿™ä¸€ç‚¹å°±åŒºåˆ†äºè´ªå¿ƒï¼Œè´ªå¿ƒæ²¡æœ‰çŠ¶æ€æ¨å¯¼ï¼Œè€Œæ˜¯ä»å±€éƒ¨ç›´æ¥é€‰æœ€ä¼˜çš„ã€‚\nè§£é¢˜æ­¥éª¤ï¼š\n\nç¡®å®š dp æ•°ç»„ï¼ˆdp tableï¼‰ä»¥åŠä¸‹æ ‡çš„å«ä¹‰\nç¡®å®šé€’æ¨å…¬å¼\ndp æ•°ç»„å¦‚ä½•åˆå§‹åŒ–\nç¡®å®šéå†é¡ºåº\nä¸¾ä¾‹æ¨å¯¼ dp æ•°ç»„\n\n509. æ–æ³¢é‚£å¥‘æ•°\nlinkæ–æ³¢é‚£å¥‘æ•°ï¼Œé€šå¸¸ç”¨ F(n) è¡¨ç¤ºï¼Œå½¢æˆçš„åºåˆ—ç§°ä¸º æ–æ³¢é‚£å¥‘æ•°åˆ— ã€‚è¯¥æ•°åˆ—ç”± 0 å’Œ 1 å¼€å§‹ï¼Œåé¢çš„æ¯ä¸€é¡¹æ•°å­—éƒ½æ˜¯å‰é¢ä¸¤é¡¹æ•°å­—çš„å’Œã€‚ä¹Ÿå°±æ˜¯ï¼š F(0) &#x3D; 0ï¼ŒF(1) &#x3D; 1ï¼Œ F(n) &#x3D; F(n - 1) + F(n - 2)ï¼Œå…¶ä¸­ n &gt; 1ã€‚ç»™ä½  n ï¼Œè¯·è®¡ç®— F(n) ã€‚\n\næ€è·¯\nç¡®å®š dp æ•°ç»„ï¼ˆdp tableï¼‰ä»¥åŠä¸‹æ ‡çš„å«ä¹‰ï¼šç¬¬ i ä¸ªæ•°çš„æ–æ³¢é‚£å¥‘æ•°å€¼æ˜¯ dp[i]\nç¡®å®šé€’æ¨å…¬å¼ï¼šé¢˜ç›®ä¸­å·²ç»å‘ŠçŸ¥ dp[i] &#x3D; dp[i - 1] + dp[i - 2]\ndp æ•°ç»„å¦‚ä½•åˆå§‹åŒ–ï¼šé¢˜ç›®ä¸­ä¹Ÿå‘ŠçŸ¥ dp[0] &#x3D; 0, dp[1] &#x3D; 1\nç¡®å®šéå†é¡ºåºï¼šä»é€’å½’å…¬å¼dp[i] &#x3D; dp[i - 1] + dp[i - 2];ä¸­å¯ä»¥çœ‹å‡ºï¼Œdp[i]æ˜¯ä¾èµ– dp[i - 1] å’Œ dp[i - 2]ï¼Œé‚£ä¹ˆéå†çš„é¡ºåºä¸€å®šæ˜¯ä»å‰åˆ°åéå†çš„\nä¸¾ä¾‹æ¨å¯¼ dp æ•°ç»„ï¼š\n\nclass Solution:    def fib(self, n: int) -&gt; int:        res = [0, 1]        for i in range(2, n + 1):            res.append(res[i - 1] + res[i - 2])                return res[n]\n\n70. çˆ¬æ¥¼æ¢¯\nlink\n\nå‡è®¾ä½ æ­£åœ¨çˆ¬æ¥¼æ¢¯ã€‚éœ€è¦ n é˜¶ä½ æ‰èƒ½åˆ°è¾¾æ¥¼é¡¶ã€‚æ¯æ¬¡ä½ å¯ä»¥çˆ¬ 1 æˆ– 2 ä¸ªå°é˜¶ã€‚ä½ æœ‰å¤šå°‘ç§ä¸åŒçš„æ–¹æ³•å¯ä»¥çˆ¬åˆ°æ¥¼é¡¶å‘¢ï¼Ÿ\næ€è·¯\nç¡®å®š dp æ•°ç»„ï¼ˆdp tableï¼‰ä»¥åŠä¸‹æ ‡çš„å«ä¹‰ï¼šåˆ°è¾¾ç¬¬ i é˜¶çš„èµ°æ³•ä¸º dp[i]\nç¡®å®šé€’æ¨å…¬å¼ï¼šå¯ä»¥å®šä¹‰ä¸º dp[i] &#x3D; dp[i - 1] + dp[i - 2]ï¼ˆdp[i - 1] èµ°ä¸€æ­¥ï¼Œdp[i - 2] èµ°ä¸¤æ­¥ï¼‰\ndp æ•°ç»„å¦‚ä½•åˆå§‹åŒ–ï¼šç¬¬ 0 é˜¶ä¸èµ°ï¼Œå¯ä»¥å®šä¹‰ä¸º 0ï¼ˆdp[0] &#x3D; 0ï¼‰,ç¬¬ä¸€é˜¶åªæœ‰ 1 ç§èµ°æ³•ï¼ˆdp[1] &#x3D; 1ï¼‰ï¼Œç¬¬äºŒé˜¶æœ‰ 2 ç§ï¼ˆdp[2] &#x3D; 2ï¼‰\nç¡®å®šéå†é¡ºåºï¼šä»å‰å¾€å\nä¸¾ä¾‹æ¨å¯¼ dp æ•°ç»„ï¼š\n\nclass Solution:    def climbStairs(self, n: int) -&gt; int:        res = [0, 1, 2]        for i in range(3, n + 1):            res.append(res[i - 1] + res[i - 2])                return res[n]\n\n746. ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯\nlinkç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ cost ï¼Œå…¶ä¸­ cost[i] æ˜¯ä»æ¥¼æ¢¯ç¬¬ i ä¸ªå°é˜¶å‘ä¸Šçˆ¬éœ€è¦æ”¯ä»˜çš„è´¹ç”¨ã€‚ä¸€æ—¦ä½ æ”¯ä»˜æ­¤è´¹ç”¨ï¼Œå³å¯é€‰æ‹©å‘ä¸Šçˆ¬ä¸€ä¸ªæˆ–è€…ä¸¤ä¸ªå°é˜¶ã€‚\n\nä½ å¯ä»¥é€‰æ‹©ä»ä¸‹æ ‡ä¸º 0 æˆ–ä¸‹æ ‡ä¸º 1 çš„å°é˜¶å¼€å§‹çˆ¬æ¥¼æ¢¯ã€‚è¯·ä½ è®¡ç®—å¹¶è¿”å›è¾¾åˆ°æ¥¼æ¢¯é¡¶éƒ¨çš„æœ€ä½èŠ±è´¹ã€‚\næ€è·¯\nç¡®å®š dp æ•°ç»„ï¼ˆdp tableï¼‰ä»¥åŠä¸‹æ ‡çš„å«ä¹‰ï¼šåˆ°è¾¾ç¬¬ i é˜¶çš„æœ€å°èŠ±è´¹\nç¡®å®šé€’æ¨å…¬å¼ï¼šå¯ä»¥å®šä¹‰ä¸º dp[i] &#x3D; min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])ï¼ˆdp[i - 1] èµ°ä¸€æ­¥ï¼Œdp[i - 2] èµ°ä¸¤æ­¥ï¼‰\ndp æ•°ç»„å¦‚ä½•åˆå§‹åŒ–ï¼šé¢˜ç›®å·²ç»ç»™å‡ºï¼Œå¯ä»¥ä» 0 æˆ–è€… 1 å¼€å§‹èµ°ï¼Œè¯´æ˜ dp[0] dp[1] éƒ½æ˜¯ 0\nç¡®å®šéå†é¡ºåºï¼šä»å‰å¾€å\nä¸¾ä¾‹æ¨å¯¼ dp æ•°ç»„ï¼š\n\nclass Solution:    def minCostClimbingStairs(self, cost: List[int]) -&gt; int:        res = 0        dp = [0, 0]        for i in range(2, len(cost) + 1):            dp.append(min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]))                return dp[len(cost)]\n\n62.ä¸åŒè·¯å¾„\nlink\n\nä¸€ä¸ªæœºå™¨äººä½äºä¸€ä¸ª m x n ç½‘æ ¼çš„å·¦ä¸Šè§’ ï¼ˆèµ·å§‹ç‚¹åœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸º â€œStartâ€ ï¼‰ã€‚æœºå™¨äººæ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚æœºå™¨äººè¯•å›¾è¾¾åˆ°ç½‘æ ¼çš„å³ä¸‹è§’ï¼ˆåœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸º â€œFinishâ€ ï¼‰ã€‚\né—®æ€»å…±æœ‰å¤šå°‘æ¡ä¸åŒçš„è·¯å¾„ï¼Ÿ\næ€è·¯\nç¡®å®š dp æ•°ç»„ï¼ˆdp tableï¼‰ä»¥åŠä¸‹æ ‡çš„å«ä¹‰ï¼šåˆ°è¾¾ç¬¬ (i, j) ä½ç½®çš„æ–¹æ³•æ•°\nç¡®å®šé€’æ¨å…¬å¼ï¼šå¯ä»¥å®šä¹‰ä¸º dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1]ï¼Œè¦ä¹ˆä»å·¦è¾¹æ¥ï¼Œè¦ä¹ˆä»ä¸Šé¢æ¥ã€‚æ³¨æ„è€ƒè™‘è¾¹ç•Œæƒ…å†µ\ndp æ•°ç»„å¦‚ä½•åˆå§‹åŒ–ï¼šå¯ä»¥å®šä¹‰ä¸º 1ï¼Œè¿™æ · dp[0][1] å’Œ dp[1][0] å°±å¯ä»¥ä½¿ç”¨é€’æ¨å…¬å¼æ¥è®¡ç®—äº†\nç¡®å®šéå†é¡ºåºï¼šä»å‰å¾€å\nä¸¾ä¾‹æ¨å¯¼ dp æ•°ç»„ï¼š\n\nclass Solution:    def uniquePaths(self, m: int, n: int) -&gt; int:        dp = [[0] * n for _ in range(m)]        dp[0][0] = 1        for i in range(m):            for j in range(n):                # ç¬¬ä¸€è¡Œ                if i == 0:                    if j != 0:                        dp[i][j] = dp[i][j - 1]                # ç¬¬ä¸€åˆ—                elif j == 0:                    if i != 0:                        dp[i][j] = dp[i - 1][j]                # å‰©ä½™æƒ…å†µ                else:                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]                return dp[m - 1][n - 1]\n\nå…¶å®ç¬¬ä¸€è¡Œï¼ˆdp[0][:]ï¼‰å’Œç¬¬ä¸€åˆ—ï¼ˆdp[:][0]ï¼‰åªèƒ½ä¸º 1ï¼Œæ‰€ä»¥å¯ä»¥ä» 1 å¼€å§‹éå†\næ•°è®ºæ€è·¯ï¼ˆé«˜ä¸­æ•°å­¦ ğŸ˜‚ï¼‰ä¸€å…±éœ€è¦ m - 1 ä¸ªç«–ç€èµ°å’Œ n - 1 ä¸ªæ¨ªç€èµ°ï¼Œæ€»å…±æ˜¯ m + n - 2 ä¸ªæ­¥éª¤ã€‚ç›¸å½“äºæ˜¯ç»™ m + n - 2 ä¸ªä¸åŒçš„æ•°ï¼Œéšä¾¿å– m - 1 ä¸ªæ•°ï¼Œæœ‰å‡ ç§å–æ³•ã€‚\n63. ä¸åŒè·¯å¾„ II343. æ•´æ•°æ‹†åˆ†96.ä¸åŒçš„äºŒå‰æœç´¢æ ‘","categories":["Leetcode"],"tags":["dynamic programming"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘è´ªå¿ƒç®—æ³•3-è´ªå¿ƒè§£å†³è‚¡ç¥¨é—®é¢˜","url":"/blog/Leetcode/greedy3/","content":"122.ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº II\nlink\n\nç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œå®ƒçš„ç¬¬  i ä¸ªå…ƒç´ æ˜¯ä¸€æ”¯ç»™å®šè‚¡ç¥¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥è®¡ç®—ä½ æ‰€èƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚ä½ å¯ä»¥å°½å¯èƒ½åœ°å®Œæˆæ›´å¤šçš„äº¤æ˜“ï¼ˆå¤šæ¬¡ä¹°å–ä¸€æ”¯è‚¡ç¥¨ï¼‰ã€‚\nç¤ºä¾‹ï¼š\n\nè¾“å…¥: [7,1,5,3,6,4]è¾“å‡º: 7è§£é‡Š: åœ¨ç¬¬ 2 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ &#x3D; 1ï¼‰çš„æ—¶å€™ä¹°å…¥ï¼Œåœ¨ç¬¬ 3 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ &#x3D; 5ï¼‰çš„æ—¶å€™å–å‡º, è¿™ç¬”äº¤æ˜“æ‰€èƒ½è·å¾—åˆ©æ¶¦ &#x3D; 5-1 &#x3D; 4ã€‚éšåï¼Œåœ¨ç¬¬ 4 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ &#x3D; 3ï¼‰çš„æ—¶å€™ä¹°å…¥ï¼Œåœ¨ç¬¬ 5 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ &#x3D; 6ï¼‰çš„æ—¶å€™å–å‡º, è¿™ç¬”äº¤æ˜“æ‰€èƒ½è·å¾—åˆ©æ¶¦ &#x3D; 6-3 &#x3D; 3ã€‚  \n\næ€è·¯è´ªå¿ƒï¼š\n\nå±€éƒ¨ï¼šå¦‚æœåä¸€å¤©çš„ä»·æ ¼æ¯”ä»Šå¤©çš„ä»·æ ¼é«˜ï¼Œåˆ™ä»Šå¤©ä¹°ï¼Œæ˜å¤©å–ï¼ˆå¤šæ¬¡ä¹°å–ï¼Œå¤šèµšé’±ï¼‰\nå…¨å±€ï¼šæ€»çš„èµšçš„é’±æœ€å¤š\n\næ›´åˆç†çš„è§£é‡Šæ˜¯ï¼šæŠŠåˆ©æ¶¦åˆ†å‰²ä¸ºä»¥å¤©ä¸ºå•ä½ï¼Œè®¡ç®—æ¯å¤©çš„åˆ©æ¶¦ï¼Œç„¶ååªåœ¨åˆ©æ¶¦ä¸ºæ­£çš„æ—¶å€™ä¹°å…¥å’Œå–å‡ºã€‚\n\nå±€éƒ¨æœ€ä¼˜ï¼šæ”¶é›†æ¯å¤©çš„æ­£åˆ©æ¶¦\nå…¨å±€æœ€ä¼˜ï¼šæ±‚å¾—æœ€å¤§åˆ©æ¶¦ã€‚\n\nclass Solution:    def maxProfit(self, prices: List[int]) -&gt; int:        val = 0        for i in range(0, len(prices) - 1):            if prices[i + 1] - prices[i] &gt; 0:                val += prices[i + 1] - prices[i]                return val\n\n714. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºå«æ‰‹ç»­è´¹è§åŠ¨æ€è§„åˆ’\n","categories":["Leetcode"],"tags":["greedy"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘è´ªå¿ƒç®—æ³•5-åŒºé—´é—®é¢˜","url":"/blog/Leetcode/greedy5/","content":"55. è·³è·ƒæ¸¸æˆ\nlink\n\nç»™ä½ ä¸€ä¸ªéè´Ÿæ•´æ•°æ•°ç»„ nums ï¼Œä½ æœ€åˆä½äºæ•°ç»„çš„ ç¬¬ä¸€ä¸ªä¸‹æ ‡ ã€‚æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ä»£è¡¨ä½ åœ¨è¯¥ä½ç½®å¯ä»¥è·³è·ƒçš„æœ€å¤§é•¿åº¦ã€‚åˆ¤æ–­ä½ æ˜¯å¦èƒ½å¤Ÿåˆ°è¾¾æœ€åä¸€ä¸ªä½ç½®ã€‚\nç¤ºä¾‹ï¼š\n\nè¾“å…¥: [2,3,1,1,4]è¾“å‡º: trueè§£é‡Š: æˆ‘ä»¬å¯ä»¥å…ˆè·³ 1 æ­¥ï¼Œä»ä½ç½® 0 åˆ°è¾¾ ä½ç½® 1, ç„¶åå†ä»ä½ç½® 1 è·³ 3 æ­¥åˆ°è¾¾æœ€åä¸€ä¸ªä½ç½®ã€‚  \n\næ€è·¯è´ªå¿ƒæ€æƒ³ä¸ºï¼Œæ¯ä¸€æ­¥éƒ½è·³æœ€è¿œï¼Œç„¶åè€ƒè™‘æ¯ä¸ªå…ƒç´ ä½œä¸ºèµ·ç‚¹æ—¶ï¼Œæ˜¯å¦èƒ½è·³åˆ°æœ«å°¾ï¼Œä»£ç å¦‚ä¸‹ï¼š\nclass Solution:    def canJump(self, nums: List[int]) -&gt; bool:        n = len(nums)        for i in range(n):            pos = i            while pos &lt; n:                if nums[pos] == 0 and pos != n - 1:                    break                if pos + nums[pos] &gt;= n - 1:                    return True                pos += nums[pos]  # è´ªå¿ƒè·³åˆ°æœ€è¿œ        return False\n\nä½†æ˜¯æ— æ³•å¤„ç† [3,2,1,0,4] æƒ…å†µï¼Œå› ä¸ºå¤–å±‚çš„ for å¾ªç¯ä¼šè·³è¿‡ 0 è¿™ä¸ªç‚¹ï¼Œç›´æ¥åˆ°æœ€åã€‚\næ­£ç¡®çš„æ€è·¯ä¸ºï¼Œéå†æ¯ä¸€ä¸ªç‚¹ï¼Œè®°å½•èƒ½è·³åˆ°çš„æœ€è¿œè·ç¦» coverã€‚è€Œåªåœ¨ cover è¿™ä¸ªèŒƒå›´ä¸­è¿›è¡Œéå†ï¼ˆcover åŠ¨æ€æ›´æ–°ï¼‰ã€‚å¦‚æœæŸä¸€æ­¥çš„ cover å¤§äºç»ˆç‚¹ï¼Œåˆ™è¿”å› Trueã€‚å¦‚æœå¾ªç¯éå†å®Œäº†ï¼Œè¯´æ˜ cover ä»ç„¶å°äºç»ˆç‚¹ï¼Œåˆ™è¿”å› Falseã€‚\n\nå±€éƒ¨ï¼šæ¯æ¬¡éƒ½è·³æœ€è¿œï¼Œè®°å½•èƒ½è·³çš„æœ€é•¿è·ç¦»\nå…¨å±€ï¼šæœ€åå¾—åˆ°æ•´ä½“æœ€å¤§è¦†ç›–èŒƒå›´ï¼Œçœ‹æ˜¯å¦èƒ½åˆ°ç»ˆç‚¹ã€‚\n\nclass Solution:    def canJump(self, nums: List[int]) -&gt; bool:        n = len(nums)        i = 0        cover = 0        while i &lt;= cover:            if cover &gt;= n - 1:                return True            cover = max(nums[i] + i, cover)            i += 1        return False\n\næœ¬è´¨ä¸Šï¼Œç¬¬äºŒæ®µä»£ç å·²ç»è¦†ç›–äº†ç¬¬ä¸€æ®µä»£ç çš„æµç¨‹ã€‚å› ä¸ºæˆ‘ä»¬æ¯æ¬¡æ˜¯åœ¨ cover é‡Œé¢éå†ï¼Œåœ¨ cover ä¸­æ— è®ºå¦‚ä½•éƒ½èƒ½åˆ°è¾¾ï¼Œæ‰€ä»¥å°±ä¸éœ€è¦éå†èµ·ç‚¹ã€‚\n45.è·³è·ƒæ¸¸æˆ II\nlink\n\nç»™å®šä¸€ä¸ªé•¿åº¦ä¸º n çš„ 0 ç´¢å¼•æ•´æ•°æ•°ç»„ numsã€‚åˆå§‹ä½ç½®ä¸º nums[0]ã€‚æ¯ä¸ªå…ƒç´  nums[i] è¡¨ç¤ºä»ç´¢å¼• i å‘åè·³è½¬çš„æœ€å¤§é•¿åº¦ã€‚è¿”å›åˆ°è¾¾ nums[n - 1] çš„æœ€å°è·³è·ƒæ¬¡æ•°ã€‚ç”Ÿæˆçš„æµ‹è¯•ç”¨ä¾‹å¯ä»¥åˆ°è¾¾ nums[n - 1]ã€‚\næ€è·¯è´ªå¿ƒçš„æ€è·¯ï¼Œå±€éƒ¨æœ€ä¼˜ï¼šå½“å‰å¯ç§»åŠ¨è·ç¦»å°½å¯èƒ½å¤šèµ°ï¼Œå¦‚æœè¿˜æ²¡åˆ°ç»ˆç‚¹ï¼Œæ­¥æ•°å†åŠ ä¸€ã€‚æ•´ä½“æœ€ä¼˜ï¼šä¸€æ­¥å°½å¯èƒ½å¤šèµ°ï¼Œä»è€Œè¾¾åˆ°æœ€å°‘æ­¥æ•°ã€‚\nè§£é¢˜çš„æ—¶å€™ï¼Œè¦ä»è¦†ç›–èŒƒå›´å‡ºå‘ï¼Œä¸ç®¡æ€ä¹ˆè·³ï¼Œè¦†ç›–èŒƒå›´å†…ä¸€å®šæ˜¯å¯ä»¥è·³åˆ°çš„ï¼Œä»¥æœ€å°çš„æ­¥æ•°å¢åŠ è¦†ç›–èŒƒå›´ï¼Œè¦†ç›–èŒƒå›´ä¸€æ—¦è¦†ç›–äº†ç»ˆç‚¹ï¼Œå¾—åˆ°çš„å°±æ˜¯æœ€å°‘æ­¥æ•°ã€‚éœ€è¦ç»Ÿè®¡ä¸¤ä¸ªè¦†ç›–èŒƒå›´ï¼Œå½“å‰è¿™ä¸€æ­¥çš„æœ€å¤§è¦†ç›–å’Œä¸‹ä¸€æ­¥æœ€å¤§è¦†ç›–ã€‚\næ³¨æ„è¿™ä¸€é¢˜æ˜ç¡®äº†ä¸€å®šå¯ä»¥è·³åˆ°ï¼š\n\né¦–å…ˆåœ¨å½“å‰è¿™ä¸€æ­¥çš„è·ç¦» cur ä¸­éå†ï¼Œæ‰¾åˆ°ä¸‹ä¸€æ­¥çš„æœ€å¤§èŒƒå›´ nexï¼ˆcur èŒƒå›´å†…åªéœ€è¦ä¸€ä¸ªæ­¥éª¤å°±èƒ½è·³åˆ°ï¼‰\nå¦‚æœéå†åˆ°äº† cur çš„æœ«å°¾ï¼Œè¯´æ˜å½“å‰æ­¥éª¤è·³ä¸åˆ°ï¼Œåˆ™ res åŠ  1ï¼ˆè¡¨ç¤ºè·³åˆ° nex èŒƒå›´ä¸­ï¼‰ï¼Œå¹¶å°† nex èµ‹å€¼ç»™ cur\nå¦‚æœ cur å·²ç»è¶…è¿‡ç»ˆç‚¹ï¼Œåˆ™ç›´æ¥è¿”å›ã€‚ï¼ˆè´ªå¿ƒçš„ç‚¹åœ¨äºæ¯æ¬¡éƒ½æ˜¯è·³æœ€è¿œçš„ï¼‰ï¼ˆæ³¨æ„è¦åœ¨èµ‹å€¼ä¹‹åæ‰åˆ¤æ–­ï¼‰\n\nclass Solution:    def jump(self, nums: List[int]) -&gt; int:        cur = 0        nex = 0        res = 0        if len(nums) == 1:            return 0        for i in range(len(nums)):            nex = max(nums[i] + i, nex)            if i == cur:                res += 1                cur = nex                if cur &gt;= len(nums) - 1:                    return res\n\n452. ç”¨æœ€å°‘æ•°é‡çš„ç®­å¼•çˆ†æ°”çƒ\nlink\n\nåœ¨äºŒç»´ç©ºé—´ä¸­æœ‰è®¸å¤šçƒå½¢çš„æ°”çƒã€‚å¯¹äºæ¯ä¸ªæ°”çƒï¼Œæä¾›çš„è¾“å…¥æ˜¯æ°´å¹³æ–¹å‘ä¸Šï¼Œæ°”çƒç›´å¾„çš„å¼€å§‹å’Œç»“æŸåæ ‡ã€‚ç”±äºå®ƒæ˜¯æ°´å¹³çš„ï¼Œæ‰€ä»¥çºµåæ ‡å¹¶ä¸é‡è¦ï¼Œå› æ­¤åªè¦çŸ¥é“å¼€å§‹å’Œç»“æŸçš„æ¨ªåæ ‡å°±è¶³å¤Ÿäº†ã€‚å¼€å§‹åæ ‡æ€»æ˜¯å°äºç»“æŸåæ ‡ã€‚\nä¸€æ”¯å¼“ç®­å¯ä»¥æ²¿ç€ x è½´ä»ä¸åŒç‚¹å®Œå…¨å‚ç›´åœ°å°„å‡ºã€‚åœ¨åæ ‡ x å¤„å°„å‡ºä¸€æ”¯ç®­ï¼Œè‹¥æœ‰ä¸€ä¸ªæ°”çƒçš„ç›´å¾„çš„å¼€å§‹å’Œç»“æŸåæ ‡ä¸º xstartï¼Œxendï¼Œ ä¸”æ»¡è¶³  xstart â‰¤ x â‰¤ xendï¼Œåˆ™è¯¥æ°”çƒä¼šè¢«å¼•çˆ†ã€‚å¯ä»¥å°„å‡ºçš„å¼“ç®­çš„æ•°é‡æ²¡æœ‰é™åˆ¶ã€‚ å¼“ç®­ä¸€æ—¦è¢«å°„å‡ºä¹‹åï¼Œå¯ä»¥æ— é™åœ°å‰è¿›ã€‚æˆ‘ä»¬æƒ³æ‰¾åˆ°ä½¿å¾—æ‰€æœ‰æ°”çƒå…¨éƒ¨è¢«å¼•çˆ†ï¼Œæ‰€éœ€çš„å¼“ç®­çš„æœ€å°æ•°é‡ã€‚\nç»™ä½ ä¸€ä¸ªæ•°ç»„ points ï¼Œå…¶ä¸­ points [i] &#x3D; [xstart,xend] ï¼Œè¿”å›å¼•çˆ†æ‰€æœ‰æ°”çƒæ‰€å¿…é¡»å°„å‡ºçš„æœ€å°å¼“ç®­æ•°ã€‚\nç¤ºä¾‹ï¼š\n\nè¾“å…¥ï¼špoints &#x3D; [[10,16],[2,8],[1,6],[7,12]]è¾“å‡ºï¼š2è§£é‡Šï¼šæ°”çƒå¯ä»¥ç”¨2æ”¯ç®­æ¥çˆ†ç ´:åœ¨x &#x3D; 6å¤„å°„å‡ºç®­ï¼Œå‡»ç ´æ°”çƒ[2,8]å’Œ[1,6]ã€‚åœ¨x &#x3D; 11å¤„å‘å°„ç®­ï¼Œå‡»ç ´æ°”çƒ[10,16]å’Œ[7,12]ã€‚  \n\næ€è·¯éœ€è¦å°†æ°”çƒè¿›è¡Œæ’åºï¼Œéœ€è¦ç»´æŠ¤ä¸€ä¸ªå½“å‰ç®­èƒ½è¦†ç›–åˆ°çš„æœ€å³ä½ç½®ï¼ˆå½“å‰é‡å åŒºé—´çš„å³è¾¹ç•Œï¼‰ã€‚\nå¦‚æœå½“å‰æ°”çƒçš„å¼€å§‹ç‚¹å¤§äºæœ€å³è¾¹ç•Œï¼Œè¯´æ˜å½“å‰ç®­å°„ä¸åˆ°è¿™ä¸ªæ°”çƒï¼›å¦‚æœèƒ½æ»¡è¶³ï¼Œåˆ™éœ€è¦æ›´æ”¹æœ€å¤§å³è¾¹ç•Œï¼Œä¸ºäº†è§£å†³ [1, 6] å’Œ [2, 4] è¿™ç§æƒ…å†µã€‚ç±»ä¼¼äºä¸Šé¢çš„ 55. è·³è·ƒæ¸¸æˆï¼Œè™½ç„¶ç¬¬ä¸€æ”¯ç®­æœ€å…ƒèƒ½ä» 6 å°„å‡ºï¼ˆè´ªå¿ƒï¼Œå°„æœ€è¿œçš„ç‚¹ï¼‰ï¼Œç¬¬äºŒä¸ªæ°”çƒçš„èµ·ç‚¹åœ¨å½“å‰æœ€å¤§å°„ç¨‹ä¹‹å†…ï¼Œå³ä¸€å®šæ»¡è¶³ï¼Œéœ€è¦æ›´æ–°æœ€å¤§å°„ç¨‹ä¸º 4.ï¼ˆå³æœ€è¿œèƒ½ä» 6 å°„ï¼Œä½†æ˜¯ä¸ä¸€å®šä» 6 å°„ï¼‰\nclass Solution:    def findMinArrowShots(self, points: List[List[int]]) -&gt; int:        points.sort(key=lambda x: (x[0], x[1]))        res = 1        rightboder = points[0][1]        for i in points:            if i[0] &gt; rightboder:                res += 1                rightboder = i[1]            else:                rightboder = min(i[1], rightboder)        return res\n\n435. æ— é‡å åŒºé—´\nlink\n\nç»™å®šä¸€ä¸ªåŒºé—´çš„é›†åˆ intervals ï¼Œå…¶ä¸­ intervals[i] &#x3D; [starti, endi] ã€‚è¿”å› éœ€è¦ç§»é™¤åŒºé—´çš„æœ€å°æ•°é‡ï¼Œä½¿å‰©ä½™åŒºé—´äº’ä¸é‡å  ã€‚æ³¨æ„ åªåœ¨ä¸€ç‚¹ä¸Šæ¥è§¦çš„åŒºé—´æ˜¯ ä¸é‡å çš„ã€‚ä¾‹å¦‚ [1, 2] å’Œ [2, 3] æ˜¯ä¸é‡å çš„ã€‚\næ€è·¯å°†æœ‰é‡å çš„åŒºé—´è§†ä¸ºä¸€ä¸ªæ•´ä½“ï¼Œæœ¬è´¨ä¸Šæ˜¯åˆ¤æ–­æ‰€æœ‰çš„åŒºé—´å¯ä»¥åˆ†ä¸ºå‡ ä¸ªâ€œæ•´ä½“â€ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ¯ä¸ªæ•´ä½“ä¸­æœ€å¤šåªèƒ½åŒ…å«ä¸€ä¸ªåŒºé—´ï¼Œå¤šä½™çš„åŒºé—´å°±è¦åˆ é™¤æ‰ã€‚æœ¬è´¨ä¸Šå°±ç±»ä¼¼ä¸ä¸Šä¸€é¢˜ 452. ç”¨æœ€å°‘æ•°é‡çš„ç®­å¼•çˆ†æ°”çƒã€‚ç®­çš„æ•°é‡å°±ä»£è¡¨æœ‰å‡ ä¸ªæ•´ä½“ï¼Œæ€»çš„æ•°é‡å‡å»ç®­çš„æ•°é‡å°±ä»£è¡¨è¦åˆ é™¤çš„æ•°é‡ã€‚\næ‰€ä»¥å°±æ˜¯è¦ç»´æŠ¤ä¸€ä¸ªæœ€å³è¾¹ç•Œï¼š\n\nå¦‚æœå½“å‰åŒºé—´çš„å·¦è¾¹ç•Œæ¯”å½“å‰æœ€å³è¾¹ç•Œå°ï¼Œè¯´æ˜é‡å ï¼Œç„¶åæ›´æ–°æœ€å³è¾¹ç•Œã€‚æ³¨æ„ï¼Œä¸ºäº†å°†æ¥æœ‰æ›´å¤šä¸é‡å åŒºé—´è¢«ä¿ç•™ï¼Œéœ€è¦ä¿ç•™å³è¾¹ç•Œæ›´å°çš„åŒºé—´\nå¦‚æœå½“å‰åŒºé—´çš„å·¦è¾¹ç•Œæ¯”å½“å‰æœ€å³è¾¹ç•Œå¤§ï¼Œè¯´æ˜æ²¡æœ‰é‡å ï¼Œâ€œæ•´ä½“â€çš„æ•°é‡åŠ ä¸€\n\nè´ªå¿ƒçš„ç‚¹åœ¨äºï¼šä¼˜å…ˆä¿ç•™ç»“æŸæ—©çš„åŒºé—´ï¼Œä»¥ä¾¿ä¸ºåç»­ç•™å‡ºæ›´å¤šç©ºé—´\nclass Solution:    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:        intervals.sort(key=lambda x: (x[0], x[1]))        count = 1        rightboder = intervals[0][1]        for i in intervals:            if i[0] &gt;= rightboder:                count += 1                rightboder = i[1]            else:                rightboder = min(rightboder, i[1])                return len(intervals) - count\n\n763.åˆ’åˆ†å­—æ¯åŒºé—´\nlink\n\nç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s ã€‚æˆ‘ä»¬è¦æŠŠè¿™ä¸ªå­—ç¬¦ä¸²åˆ’åˆ†ä¸ºå°½å¯èƒ½å¤šçš„ç‰‡æ®µï¼ŒåŒä¸€å­—æ¯æœ€å¤šå‡ºç°åœ¨ä¸€ä¸ªç‰‡æ®µä¸­ã€‚ä¾‹å¦‚ï¼Œå­—ç¬¦ä¸² â€œababccâ€ èƒ½å¤Ÿè¢«åˆ†ä¸º [â€œababâ€, â€œccâ€]ï¼Œä½†ç±»ä¼¼ [â€œabaâ€, â€œbccâ€] æˆ– [â€œabâ€, â€œabâ€, â€œccâ€] çš„åˆ’åˆ†æ˜¯éæ³•çš„ã€‚\næ³¨æ„ï¼Œåˆ’åˆ†ç»“æœéœ€è¦æ»¡è¶³ï¼šå°†æ‰€æœ‰åˆ’åˆ†ç»“æœæŒ‰é¡ºåºè¿æ¥ï¼Œå¾—åˆ°çš„å­—ç¬¦ä¸²ä»ç„¶æ˜¯ s ã€‚è¿”å›ä¸€ä¸ªè¡¨ç¤ºæ¯ä¸ªå­—ç¬¦ä¸²ç‰‡æ®µçš„é•¿åº¦çš„åˆ—è¡¨ã€‚\næ€è·¯ 1é¢˜ç›®è¦æ±‚åŒä¸€å­—æ¯æœ€å¤šå‡ºç°åœ¨ä¸€ä¸ªç‰‡æ®µä¸­ï¼Œåœ¨éå†çš„è¿‡ç¨‹ä¸­ç›¸å½“äºæ˜¯è¦æ‰¾æ¯ä¸€ä¸ªå­—æ¯çš„è¾¹ç•Œï¼Œå¦‚æœæ‰¾åˆ°ä¹‹å‰éå†è¿‡çš„æ‰€æœ‰å­—æ¯çš„æœ€è¿œè¾¹ç•Œï¼Œè¯´æ˜è¿™ä¸ªè¾¹ç•Œå°±æ˜¯åˆ†å‰²ç‚¹äº†ã€‚æ­¤æ—¶å‰é¢å‡ºç°è¿‡æ‰€æœ‰å­—æ¯ï¼Œæœ€è¿œä¹Ÿå°±åˆ°è¿™ä¸ªè¾¹ç•Œäº†ã€‚\nä¸¤ä¸ªæ­¥éª¤ï¼š\n\nç»Ÿè®¡æ¯ä¸€ä¸ªå­—ç¬¦æœ€åå‡ºç°çš„ä½ç½®\nä»å¤´éå†å­—ç¬¦ï¼Œå¹¶æ›´æ–°å­—ç¬¦çš„æœ€è¿œå‡ºç°ä¸‹æ ‡ï¼Œå¦‚æœæ‰¾åˆ°å­—ç¬¦æœ€è¿œå‡ºç°ä½ç½®ä¸‹æ ‡å’Œå½“å‰ä¸‹æ ‡ç›¸ç­‰äº†ï¼Œåˆ™æ‰¾åˆ°äº†åˆ†å‰²ç‚¹\n\n\næ³¨æ„å½“å‰çš„åŒºé—´å¿…é¡»è¦è¦†ç›–åˆ°å½“å‰æ‰€æœ‰å­—ç¬¦çš„æœ€åä¸€æ¬¡å‡ºç°ä½ç½®ï¼Œæ‰€ä»¥ right &#x3D; max(right, m[ch])ã€‚\nclass Solution:    def partitionLabels(self, s: str) -&gt; List[int]:        m = &#123;&#125;        for i, ch in enumerate(s):            m[ch] = i        res = []        right = 0        left = 0        for i, ch in enumerate(s):            right = max(right, m[ch])            if right == i:                res.append(right - left + 1)                left = i + 1        return res\n\næ€è·¯ 2ç±»ä¼¼äºå‰ä¸¤é¢˜ 452.ç”¨æœ€å°‘æ•°é‡çš„ç®­å¼•çˆ†æ°”çƒ å’Œ 435.æ— é‡å åŒºé—´ï¼Œç»Ÿè®¡å­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—ç¬¦çš„èµ·å§‹å’Œç»“æŸä½ç½®ï¼Œè®°å½•è¿™äº›åŒºé—´ï¼ˆå®é™…ä¸Šä¹Ÿå°±æ˜¯ 435.æ— é‡å åŒºé—´ é¢˜ç›®é‡Œçš„è¾“å…¥ï¼‰ï¼Œå°†åŒºé—´æŒ‰å·¦è¾¹ç•Œä»å°åˆ°å¤§æ’åºï¼Œæ‰¾åˆ°è¾¹ç•Œå°†åŒºé—´åˆ’åˆ†æˆç»„ï¼Œäº’ä¸é‡å ã€‚æ‰¾åˆ°çš„è¾¹ç•Œå°±æ˜¯ç­”æ¡ˆã€‚\næœ¬è´¨ä¸Šæ˜¯è¦æŠŠæœ‰é‡å çš„åŒºé—´ï¼ˆè¯´æ˜å¯¹åº”çš„å­—ç¬¦ä¸²è¦æ”¾åœ¨ä¸€èµ·ï¼‰åˆå¹¶ã€‚\nclass Solution:    def countLabels(self, s):        # åˆå§‹åŒ–ä¸€ä¸ªé•¿åº¦ä¸º26çš„åŒºé—´åˆ—è¡¨ï¼Œåˆå§‹å€¼ä¸ºè´Ÿæ— ç©·        hash = [[float(&#x27;-inf&#x27;), float(&#x27;-inf&#x27;)] for _ in range(26)]        hash_filter = []        for i in range(len(s)):            if hash[ord(s[i]) - ord(&#x27;a&#x27;)][0] == float(&#x27;-inf&#x27;):                hash[ord(s[i]) - ord(&#x27;a&#x27;)][0] = i            hash[ord(s[i]) - ord(&#x27;a&#x27;)][1] = i        for i in range(len(hash)):            if hash[i][0] != float(&#x27;-inf&#x27;):                hash_filter.append(hash[i])        return hash_filter    def partitionLabels(self, s):        res = []        hash = self.countLabels(s)        hash.sort(key=lambda x: x[0])  # æŒ‰å·¦è¾¹ç•Œä»å°åˆ°å¤§æ’åº        rightBoard = hash[0][1]  # è®°å½•æœ€å¤§å³è¾¹ç•Œ        leftBoard = 0        for i in range(1, len(hash)):            if hash[i][0] &gt; rightBoard:  # å‡ºç°åˆ†å‰²ç‚¹                res.append(rightBoard - leftBoard + 1)                leftBoard = hash[i][0]            rightBoard = max(rightBoard, hash[i][1])        res.append(rightBoard - leftBoard + 1)  # æœ€å³ç«¯        return res\n\n56. åˆå¹¶åŒºé—´\nlink\n\nä»¥æ•°ç»„ intervals è¡¨ç¤ºè‹¥å¹²ä¸ªåŒºé—´çš„é›†åˆï¼Œå…¶ä¸­å•ä¸ªåŒºé—´ä¸º intervals[i] &#x3D; [starti, endi] ã€‚è¯·ä½ åˆå¹¶æ‰€æœ‰é‡å çš„åŒºé—´ï¼Œå¹¶è¿”å› ä¸€ä¸ªä¸é‡å çš„åŒºé—´æ•°ç»„ï¼Œè¯¥æ•°ç»„éœ€æ°å¥½è¦†ç›–è¾“å…¥ä¸­çš„æ‰€æœ‰åŒºé—´ ã€‚\nç¤ºä¾‹ï¼š\n\nè¾“å…¥ï¼šintervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]è¾“å‡ºï¼š[[1,6],[8,10],[15,18]]è§£é‡Šï¼šåŒºé—´ [1,3] å’Œ [2,6] é‡å , å°†å®ƒä»¬åˆå¹¶ä¸º [1,6]\n\næ€è·¯ç±»ä¼¼äºå‰å‡ é¢˜ï¼Œåªä¸è¿‡åˆ¤æ–­å‡ºé‡å åï¼Œéœ€è¦åˆå¹¶åŒºé—´ã€‚åŒæ ·å…ˆå¯¹åŒºé—´è¿›è¡Œæ’åºã€‚\n\næ³¨æ„è¿™é‡Œå…ˆå°†ç¬¬ä¸€ä¸ªåŒºé—´æ”¾åˆ°ç»“æœé›†åˆ res ä¸­ï¼Œç„¶åæ¯æ¬¡éå†æ—¶éƒ½å–å½“å‰ç»“æœ res çš„æœ€åä¸€ä¸ªåŒºé—´æ¥è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœ last[1] &gt; i[0]ï¼Œè¯´æ˜å½“å‰æœ‰é‡å ï¼ŒæŠŠæœ€åçš„åŒºé—´å–å‡ºæ¥ï¼Œåˆå¹¶ä¹‹åå†æ”¾è¿›å»ã€‚\næ³¨æ„åˆå¹¶åŒºé—´æ—¶ï¼Œå…¶å®åªéœ€è¦æ›´æ”¹ç»“æŸçš„ç‚¹ï¼Œå› ä¸ºæœ€å¼€å§‹å°±è¿›è¡Œäº†æ’åºï¼Œå‰ä¸€ä¸ªåŒºé—´çš„èµ·å§‹ç‚¹ä¸€å®šæ˜¯æœ€å°çš„ã€‚\n\nclass Solution:    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:        intervals.sort(key=lambda x: x[0])        res = [intervals[0]]        start = 0        end = 0        for i in intervals:            last = res[-1]            if last[1] &gt;= i[0]:                res.pop()                # å…¶å®åªéœ€è¦æ”¹åŒºé—´çš„ç»ˆç‚¹                res.append([min(last[0], i[0]), max(last[1], i[1])])            else:                res.append(i)        return res","categories":["Leetcode"],"tags":["greedy"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘è´ªå¿ƒç®—æ³•6","url":"/blog/Leetcode/greedy6/","content":"53. æœ€å¤§å­åºå’Œ\nlink\n\nç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œè¯·ä½ æ‰¾å‡ºä¸€ä¸ªå…·æœ‰æœ€å¤§å’Œçš„è¿ç»­å­æ•°ç»„ï¼ˆå­æ•°ç»„æœ€å°‘åŒ…å«ä¸€ä¸ªå…ƒç´ ï¼‰ï¼Œè¿”å›å…¶æœ€å¤§å’Œã€‚å­æ•°ç»„æ˜¯æ•°ç»„ä¸­çš„ä¸€ä¸ªè¿ç»­éƒ¨åˆ†ã€‚\næ€è·¯å±€éƒ¨æœ€ä¼˜ï¼šå½“å‰ç´¯åŠ å’Œæ˜¯æ­£çš„ï¼Œå°±ç»§ç»­ç´¯åŠ ï¼›å¦åˆ™é‡æ–°å¼€å§‹ã€‚å¦‚æœå½“å‰ç´¯åŠ çš„å­æ•°ç»„å’Œ cur_sum å°äº 0ï¼Œé‚£å®ƒå¯¹åé¢çš„ç»“æœæ¯«æ— è´¡çŒ®ï¼Œç›´æ¥èˆå¼ƒï¼Œä»ä¸‹ä¸€ä¸ªå…ƒç´ é‡æ–°å¼€å§‹ã€‚\nå…¨å±€æœ€ä¼˜ï¼šè¿‡ç¨‹ä¸­ä¸æ–­ç»´æŠ¤æœ€å¤§å€¼ã€‚\nåŒæ—¶è®°å¾—æ¯æ·»åŠ ä¸€æ¬¡éƒ½éœ€è¦æ›´æ–°å½“å‰çš„æœ€å¤§å€¼\nclass Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        cur = 0        maxi = float(&#x27;-inf&#x27;)        for i in nums:            cur += i            maxi = max(cur, maxi)            if cur &lt; 0:                cur = 0        return maxi\n134. åŠ æ²¹ç«™\nlink\n\nåœ¨ä¸€æ¡ç¯è·¯ä¸Šæœ‰ n ä¸ªåŠ æ²¹ç«™ï¼Œå…¶ä¸­ç¬¬ i ä¸ªåŠ æ²¹ç«™æœ‰æ±½æ²¹ gas[i] å‡ã€‚ä½ æœ‰ä¸€è¾†æ²¹ç®±å®¹é‡æ— é™çš„çš„æ±½è½¦ï¼Œä»ç¬¬ i ä¸ªåŠ æ²¹ç«™å¼€å¾€ç¬¬ i+1 ä¸ªåŠ æ²¹ç«™éœ€è¦æ¶ˆè€—æ±½æ²¹ cost[i] å‡ã€‚ä½ ä»å…¶ä¸­çš„ä¸€ä¸ªåŠ æ²¹ç«™å‡ºå‘ï¼Œå¼€å§‹æ—¶æ²¹ç®±ä¸ºç©ºã€‚\nç»™å®šä¸¤ä¸ªæ•´æ•°æ•°ç»„ gas å’Œ cost ï¼Œå¦‚æœä½ å¯ä»¥æŒ‰é¡ºåºç»•ç¯è·¯è¡Œé©¶ä¸€å‘¨ï¼Œåˆ™è¿”å›å‡ºå‘æ—¶åŠ æ²¹ç«™çš„ç¼–å·ï¼Œå¦åˆ™è¿”å› -1 ã€‚å¦‚æœå­˜åœ¨è§£ï¼Œåˆ™ä¿è¯å®ƒæ˜¯å”¯ä¸€çš„ã€‚\næš´åŠ›ä¸¤å±‚å¾ªç¯ï¼Œåˆ†åˆ«éå†èµ·ç‚¹å’Œè·‘ä¸€åœˆï¼Œå¦‚æœèƒ½é‡æ–°åˆ°è¾¾èµ·ç‚¹ï¼Œåˆ™è¯´æ˜å½“å‰èµ·ç‚¹æ»¡è¶³æ¡ä»¶ã€‚\nè´ªå¿ƒå¦‚æœæ€»æ²¹é‡å°äºæ€»æ¶ˆè€—é‡ï¼Œåˆ™è¯´æ˜æ— è®ºå¦‚ä½•éƒ½ä¸èƒ½æ»¡è¶³æ¡ä»¶ã€‚ç„¶åä» 0 å¼€å§‹éå†ï¼Œè®°å½•ä»å¤´å¼€å§‹çš„æ²¹ç®±å‰©ä½™é‡ï¼ˆrest +&#x3D; gas[i] - cost[i]ï¼‰ã€‚å¦‚æœæŸä¸ªæ­¥éª¤ i åˆ¤æ–­ rest å°äº 0ï¼Œåˆ™è¯´æ˜ä»å½“å‰èµ·ç‚¹ start å¼€å§‹ï¼Œæœ€è¿œåªèƒ½è·‘åˆ° iã€‚æ­¤æ—¶æŠŠèµ·ç‚¹è®¾ç½®ä¸º i+1ï¼Œé‡æ–°å¼€å§‹éå†ã€‚ï¼ˆåªç”¨éå†åˆ°æœ«å°¾å³å¯ï¼Œå› ä¸ºä¸Šä¸€æ­¥æ˜¯ä» 0 å¼€å§‹ï¼Œï¼ˆç­‰ä»·äºæœ«å°¾ï¼‰ï¼Œæœ€è¿œåˆ° iï¼Œè€Œç¬¬äºŒæ­¥æ˜¯ä» i+1 å¼€å§‹éå†åˆ°æœ«å°¾ï¼Œï¼ˆç­‰ä»·æ˜¯ 0ï¼‰ï¼Œç›¸å½“äºè·‘äº†ä¸€åœˆï¼‰\n\nå¦‚æœ tank &lt; 0ï¼Œè¯´æ˜ä»èµ·ç‚¹èµ°åˆ°å½“å‰ i å¤±è´¥äº†ï¼šå½“å‰è¿™ä¸€æ®µä¸èƒ½ä½œä¸ºèµ·ç‚¹ã€‚\næ‰€ä»¥æˆ‘ä»¬è·³è¿‡å®ƒï¼Œä» i+1 å¼€å§‹é‡æ–°å°è¯•ï¼ŒæŠŠ tank é‡ç½®ä¸º 0ã€‚\n\nè™½ç„¶æŸäº›èµ·ç‚¹ä¸è¡Œï¼Œä½†æˆ‘ä»¬åªè¦è·³è¿‡è¿™äº›äºæŸæ®µï¼ˆtank&lt;0 çš„æ®µï¼‰ï¼Œå¹¶ä¸”ï¼š\n\næ€»çš„ä¾›æ²¹æ˜¯ â‰¥ æ€»è€—æ²¹çš„\né‚£ä¹ˆåœ¨æŸä¸ªä½ç½®ä¹‹åï¼Œç›ˆä½™å°±èƒ½æŠŠä¹‹å‰çš„äºç©ºè¡¥å›æ¥\nä¹Ÿå°±æ˜¯è¯´ï¼Œä¹‹å‰äºäº†å¤šå°‘ï¼Œåé¢å°±èƒ½â€œè¡¥å›æ¥â€ï¼Œæœ€ç»ˆä¸€å®šå¯ä»¥ç»•ä¸€åœˆã€‚\n\nclass Solution:    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -&gt; int:        if sum(gas) &lt; sum(cost):            return -1        cur = 0        start = 0        for i in range(len(gas)):            cur += gas[i] - cost[i]            if cur &lt; 0:                start = i + 1                cur = 0        return start\n\n\n968. ç›‘æ§äºŒå‰æ ‘\nlink\n\nç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæˆ‘ä»¬åœ¨æ ‘çš„èŠ‚ç‚¹ä¸Šå®‰è£…æ‘„åƒå¤´ã€‚èŠ‚ç‚¹ä¸Šçš„æ¯ä¸ªæ‘„å½±å¤´éƒ½å¯ä»¥ç›‘è§†å…¶çˆ¶å¯¹è±¡ã€è‡ªèº«åŠå…¶ç›´æ¥å­å¯¹è±¡ã€‚è®¡ç®—ç›‘æ§æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹æ‰€éœ€çš„æœ€å°æ‘„åƒå¤´æ•°é‡ã€‚\n\næ€è·¯æ ¸å¿ƒï¼šæ‘„åƒå¤´ä¸èƒ½æ”¾åœ¨å¶å­èŠ‚ç‚¹ä¸Šã€‚æ‘„åƒå¤´å¯ä»¥è¦†ç›–ä¸Šä¸­ä¸‹ä¸‰å±‚ï¼Œå¦‚æœæŠŠæ‘„åƒå¤´æ”¾åœ¨å¶å­èŠ‚ç‚¹ä¸Šï¼Œå°±æµªè´¹çš„ä¸€å±‚çš„è¦†ç›–ã€‚æ‰€ä»¥æŠŠæ‘„åƒå¤´æ”¾åœ¨å¶å­èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ä½ç½®ï¼Œæ‰èƒ½å……åˆ†åˆ©ç”¨æ‘„åƒå¤´çš„è¦†ç›–é¢ç§¯ã€‚\nå±€éƒ¨æœ€ä¼˜ï¼šè®©å¶å­èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹å®‰æ‘„åƒå¤´ï¼Œæ‰€ç”¨æ‘„åƒå¤´æœ€å°‘ï¼Œæ•´ä½“æœ€ä¼˜ï¼šå…¨éƒ¨æ‘„åƒå¤´æ•°é‡æ‰€ç”¨æœ€å°‘\néœ€è¦ä»ä¸‹å‘ä¸Šéå†ï¼Œåªæœ‰ä½¿ç”¨ååºéå†ã€‚åœ¨éå†çš„è¿‡ç¨‹ä¸­éœ€è¦è¿›è¡ŒçŠ¶æ€è½¬ç§»ã€‚å®šä¹‰ä¸‰ç§çŠ¶æ€ï¼šæœ‰å¦‚ä¸‹ä¸‰ç§ï¼š\n\nè¯¥èŠ‚ç‚¹æ— è¦†ç›–\næœ¬èŠ‚ç‚¹æœ‰æ‘„åƒå¤´\næœ¬èŠ‚ç‚¹æœ‰è¦†ç›–\n\nåˆ†åˆ«æœ‰ä¸‰ä¸ªæ•°å­—æ¥è¡¨ç¤ºï¼š\n\n0ï¼šè¯¥èŠ‚ç‚¹æ— è¦†ç›–\n1ï¼šæœ¬èŠ‚ç‚¹æœ‰æ‘„åƒå¤´\n2ï¼šæœ¬èŠ‚ç‚¹æœ‰è¦†ç›–\n\né€’å½’ä¸‰éƒ¨æ›²ï¼š\n\nå‚æ•°å’Œè¿”å›å€¼ï¼šéœ€è¦è¿”å›å½“å‰èŠ‚ç‚¹çš„çŠ¶æ€\nç»ˆæ­¢æ¡ä»¶ï¼šé‡åˆ°ç©ºå°±è¿”å›ï¼Œæ³¨æ„ç©ºèŠ‚ç‚¹åº”è¯¥å®šä¹‰ä¸ºæœ‰è¦†ç›–ï¼ˆ2ï¼‰ï¼ˆå¦åˆ™è¯¥å¶å­èŠ‚ç‚¹å°±éœ€è¦æ”¾æ‘„åƒå¤´äº†ï¼‰\næ ¸å¿ƒé€»è¾‘ï¼š\nå·¦å³éƒ½æœ‰è¦†ç›–ï¼ˆä¸¤ä¸ª 2ï¼‰ï¼Œå½“å‰èŠ‚ç‚¹å°±ä¸ºæ— è¦†ç›–ï¼ˆ0ï¼‰\nè‡³å°‘ä¸€ä¸ªå­©å­æ²¡æœ‰è¦†ç›–ï¼ˆè‡³å°‘ä¸€ä¸ª 0ï¼‰ï¼Œé‚£å°±è¦æ”¾æ‘„åƒå¤´ï¼ˆ1ï¼‰\nè‡³å°‘ä¸€ä¸ªå­©å­æ”¾äº†æ‘„åƒå¤´ï¼ˆè‡³å°‘ä¸€ä¸ª 1ï¼‰ï¼Œå½“å‰èŠ‚ç‚¹å°±æœ‰è¦†ç›–ï¼ˆ2ï¼‰\n\n\n\næ³¨æ„ä¸Šè¿°é¡ºåºä¸èƒ½æ‰“ä¹±ï¼Œä¸‹é¢çš„æƒ…å†µåº”è¯¥æ˜¯ 1ï¼Œè€Œä¸æ˜¯ 2ã€‚\n\næ­¤å¤–ï¼Œå¦‚æœæ ¹èŠ‚ç‚¹æ²¡æœ‰è¦†ç›–ï¼Œä¹Ÿéœ€è¦æ”¾æ‘„åƒå¤´ã€‚\nclass Solution:    def minCameraCover(self, root: Optional[TreeNode]) -&gt; int:        res = [0]        def treverse(node):            if node == None:                return 2                        left = treverse(node.left)            right = treverse(node.right)            if left == 2 and right == 2:                return 0            if left == 0 or right == 0:                res[0] += 1                return 1                        if left == 1 or right == 1:                return 2                if treverse(root) == 0:            res[0] += 1        return res[0]","categories":["Leetcode"],"tags":["greedy"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘è´ªå¿ƒç®—æ³•1","url":"/blog/Leetcode/greedy1/","content":"ç†è®ºåŸºç¡€è´ªå¿ƒçš„æœ¬è´¨æ˜¯é€‰æ‹©æ¯ä¸€é˜¶æ®µçš„å±€éƒ¨æœ€ä¼˜ï¼Œä»è€Œè¾¾åˆ°å…¨å±€æœ€ä¼˜ã€‚\nåˆ·é¢˜æˆ–è€…é¢è¯•çš„æ—¶å€™ï¼Œæ‰‹åŠ¨æ¨¡æ‹Ÿä¸€ä¸‹æ„Ÿè§‰å¯ä»¥å±€éƒ¨æœ€ä¼˜æ¨å‡ºæ•´ä½“æœ€ä¼˜ï¼Œè€Œä¸”æƒ³ä¸åˆ°åä¾‹ï¼Œé‚£ä¹ˆå°±è¯•ä¸€è¯•è´ªå¿ƒã€‚\n455. åˆ†å‘é¥¼å¹²\nlink\n\nå‡è®¾ä½ æ˜¯ä¸€ä½å¾ˆæ£’çš„å®¶é•¿ï¼Œæƒ³è¦ç»™ä½ çš„å­©å­ä»¬ä¸€äº›å°é¥¼å¹²ã€‚ä½†æ˜¯ï¼Œæ¯ä¸ªå­©å­æœ€å¤šåªèƒ½ç»™ä¸€å—é¥¼å¹²ã€‚\nå¯¹æ¯ä¸ªå­©å­ iï¼Œéƒ½æœ‰ä¸€ä¸ªèƒƒå£å€¼  g[i]ï¼Œè¿™æ˜¯èƒ½è®©å­©å­ä»¬æ»¡è¶³èƒƒå£çš„é¥¼å¹²çš„æœ€å°å°ºå¯¸ï¼›å¹¶ä¸”æ¯å—é¥¼å¹² jï¼Œéƒ½æœ‰ä¸€ä¸ªå°ºå¯¸ s[j] ã€‚å¦‚æœ s[j] &gt;&#x3D; g[i]ï¼Œæˆ‘ä»¬å¯ä»¥å°†è¿™ä¸ªé¥¼å¹² j åˆ†é…ç»™å­©å­ i ï¼Œè¿™ä¸ªå­©å­ä¼šå¾—åˆ°æ»¡è¶³ã€‚ä½ çš„ç›®æ ‡æ˜¯å°½å¯èƒ½æ»¡è¶³è¶Šå¤šæ•°é‡çš„å­©å­ï¼Œå¹¶è¾“å‡ºè¿™ä¸ªæœ€å¤§æ•°å€¼ã€‚\nç¤ºä¾‹ï¼š\n\nè¾“å…¥: g &#x3D; [1,2,3], s &#x3D; [1,1]è¾“å‡º: 1 è§£é‡Š:ä½ æœ‰ä¸‰ä¸ªå­©å­å’Œä¸¤å—å°é¥¼å¹²ï¼Œ3 ä¸ªå­©å­çš„èƒƒå£å€¼åˆ†åˆ«æ˜¯ï¼š1,2,3ã€‚è™½ç„¶ä½ æœ‰ä¸¤å—å°é¥¼å¹²ï¼Œç”±äºä»–ä»¬çš„å°ºå¯¸éƒ½æ˜¯ 1ï¼Œä½ åªèƒ½è®©èƒƒå£å€¼æ˜¯ 1 çš„å­©å­æ»¡è¶³ã€‚æ‰€ä»¥ä½ åº”è¯¥è¾“å‡º 1ã€‚  \n\næ€è·¯è´ªå¿ƒä½“ç°ä¸ºï¼šä¼˜å…ˆè®©å¤§å°ºå¯¸çš„é¥¼å¹²æ»¡è¶³å¤§èƒƒå£çš„å­©å­\nè¿™é‡Œçš„å±€éƒ¨æœ€ä¼˜å°±æ˜¯å¤§é¥¼å¹²å–‚ç»™èƒƒå£å¤§çš„ï¼Œå……åˆ†åˆ©ç”¨é¥¼å¹²å°ºå¯¸å–‚é¥±ä¸€ä¸ªï¼Œå…¨å±€æœ€ä¼˜å°±æ˜¯å–‚é¥±å°½å¯èƒ½å¤šçš„å°å­©ã€‚\nåªéœ€è¦å°†ä¸¤ä¸ªæ•°ç»„æ’åºï¼Œç„¶åä»å¤§åˆ°å°éå†å³å¯ã€‚\nclass Solution:    def findContentChildren(self, g: List[int], s: List[int]) -&gt; int:        g.sort()        s.sort()        num = 0        sp = len(s) - 1        gp = len(g) - 1        while sp &gt;= 0 and gp &gt;= 0:            if s[sp] &gt;= g[gp]:                num += 1                sp -= 1                gp -= 1            else:                gp -= 1        return num\n\n1005.Kæ¬¡å–ååæœ€å¤§åŒ–çš„æ•°ç»„å’Œ\nlink\n\nç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•° k ï¼Œé€‰æ‹©æŸä¸ªä¸‹æ ‡ i å¹¶å°† nums[i] æ›¿æ¢ä¸º -nums[i] ã€‚é‡å¤è¿™ä¸ªè¿‡ç¨‹æ°å¥½ k æ¬¡ã€‚å¯ä»¥å¤šæ¬¡é€‰æ‹©åŒä¸€ä¸ªä¸‹æ ‡ i ã€‚ä»¥è¿™ç§æ–¹å¼ä¿®æ”¹æ•°ç»„åï¼Œè¿”å›æ•°ç»„ å¯èƒ½çš„æœ€å¤§å’Œã€‚\nç¤ºä¾‹ï¼š\n\nè¾“å…¥ï¼šnums &#x3D; [4,2,3], k &#x3D; 1è¾“å‡ºï¼š5è§£é‡Šï¼šé€‰æ‹©ä¸‹æ ‡ 1 ï¼Œnums å˜ä¸º [4,-2,3] ã€‚\n\næ€è·¯è´ªå¿ƒæ€è·¯ï¼šæ¯æ¬¡éƒ½é€‰æœ€å°çš„å€¼æ¥åè½¬ï¼ˆæ³¨æ„æ˜¯åœ¨ä¿®æ”¹åçš„æ•°ç»„ä¸­æ‰¾æœ€å°çš„ï¼‰ï¼Œæ³¨æ„å¦‚æœæœ€å°å€¼ä¸º 0ï¼Œåˆ™åº”è¯¥å¤šæ¬¡é€‰ 0ã€‚æ€è·¯å¦‚ä¸‹ï¼š\n\nå°†æ•°ç»„æŒ‰ç…§ç»å¯¹å€¼å¤§å°ä»å¤§åˆ°å°æ’åºï¼Œæ³¨æ„è¦æŒ‰ç…§ç»å¯¹å€¼çš„å¤§å°\nä»å‰å‘åéå†ï¼Œé‡åˆ°è´Ÿæ•°å°†å…¶å˜ä¸ºæ­£æ•°ï¼ŒåŒæ—¶Kâ€“\nå¦‚æœKè¿˜å¤§äº0ï¼Œé‚£ä¹ˆåå¤è½¬å˜æ•°å€¼æœ€å°çš„å…ƒç´ ï¼Œå°†Kç”¨å®Œ\næ±‚å’Œ\n\nclass Solution:    def largestSumAfterKNegations(self, nums: List[int], k: int) -&gt; int:        nums.sort(key=lambda x: abs(x), reverse=True)        for i in range(len(nums)):  # ç¬¬äºŒæ­¥ï¼šæ‰§è¡ŒKæ¬¡å–åæ“ä½œ            if nums[i] &lt; 0 and k &gt; 0:                nums[i] *= -1                k -= 1        if k % 2 == 1:  # ç¬¬ä¸‰æ­¥ï¼šå¦‚æœKè¿˜æœ‰å‰©ä½™æ¬¡æ•°ï¼Œå°†ç»å¯¹å€¼æœ€å°çš„å…ƒç´ å–å            nums[-1] *= -1        result = sum(nums)  # ç¬¬å››æ­¥ï¼šè®¡ç®—æ•°ç»„Açš„å…ƒç´ å’Œ        return result\n\næ³¨æ„ python æ’åºçš„å†™æ³•ã€‚\n\nsort æ–¹æ³•çš„ key å‚æ•°è¡¨ç¤ºæ’åºæ—¶ï¼Œä¸ç›´æ¥ç”¨åˆ—è¡¨å…ƒç´ æœ¬èº«æ¥æ¯”è¾ƒï¼Œè€Œæ˜¯å…ˆå¯¹æ¯ä¸ªå…ƒç´ åº”ç”¨ä¸€æ¬¡ key å‡½æ•°ï¼Œç„¶åç”¨è¿”å›å€¼æ¥æ’åºã€‚\nlambda x: abs(x) ä¸ºä¸€ä¸ªåŒ¿åå‡½æ•°ï¼Œè¡¨ç¤ºæ¥æ”¶ä¸€ä¸ªå‚æ•° xï¼Œè¿”å› x çš„ç»å¯¹å€¼ï¼ˆabs(x)ï¼‰ã€‚ç­‰ä»·äºï¼š\n\ndef f(x):    return abs(x)\n\næ‰€ä»¥ä¹Ÿå¯ä»¥å†™æˆ nums.sort(key&#x3D;f)\n860.æŸ æª¬æ°´æ‰¾é›¶\nlink\n\nåœ¨æŸ æª¬æ°´æ‘Šä¸Šï¼Œæ¯ä¸€æ¯æŸ æª¬æ°´çš„å”®ä»·ä¸º 5 ç¾å…ƒã€‚é¡¾å®¢æ’é˜Ÿè´­ä¹°ä½ çš„äº§å“ï¼Œï¼ˆæŒ‰è´¦å• bills æ”¯ä»˜çš„é¡ºåºï¼‰ä¸€æ¬¡è´­ä¹°ä¸€æ¯ã€‚æ¯ä½é¡¾å®¢åªä¹°ä¸€æ¯æŸ æª¬æ°´ï¼Œç„¶åå‘ä½ ä»˜ 5 ç¾å…ƒã€10 ç¾å…ƒæˆ– 20 ç¾å…ƒã€‚ä½ å¿…é¡»ç»™æ¯ä¸ªé¡¾å®¢æ­£ç¡®æ‰¾é›¶ï¼Œä¹Ÿå°±æ˜¯è¯´å‡€äº¤æ˜“æ˜¯æ¯ä½é¡¾å®¢å‘ä½ æ”¯ä»˜ 5 ç¾å…ƒã€‚æ³¨æ„ï¼Œä¸€å¼€å§‹ä½ æ‰‹å¤´æ²¡æœ‰ä»»ä½•é›¶é’±ã€‚å¦‚æœä½ èƒ½ç»™æ¯ä½é¡¾å®¢æ­£ç¡®æ‰¾é›¶ï¼Œè¿”å› true ï¼Œå¦åˆ™è¿”å› false ã€‚\nç¤ºä¾‹ï¼š\n\nè¾“å…¥ï¼šbills &#x3D; [5,5,5,10,20]è¾“å‡ºï¼štrueè§£é‡Šï¼šå‰ 3 ä½é¡¾å®¢é‚£é‡Œï¼Œæˆ‘ä»¬æŒ‰é¡ºåºæ”¶å– 3 å¼  5 ç¾å…ƒçš„é’ç¥¨ã€‚ç¬¬ 4 ä½é¡¾å®¢é‚£é‡Œï¼Œæˆ‘ä»¬æ”¶å–ä¸€å¼  10 ç¾å…ƒçš„é’ç¥¨ï¼Œå¹¶è¿”è¿˜ 5 ç¾å…ƒã€‚ç¬¬ 5 ä½é¡¾å®¢é‚£é‡Œï¼Œæˆ‘ä»¬æ‰¾è¿˜ä¸€å¼  10 ç¾å…ƒçš„é’ç¥¨å’Œä¸€å¼  5 ç¾å…ƒçš„é’ç¥¨ã€‚ç”±äºæ‰€æœ‰å®¢æˆ·éƒ½å¾—åˆ°äº†æ­£ç¡®çš„æ‰¾é›¶ï¼Œæ‰€ä»¥æˆ‘ä»¬è¾“å‡º trueã€‚  \n\næ€è·¯æ¯æ¬¡æ‰¾é’±çš„æ—¶å€™éƒ½è®¡ç®—å½“å‰çš„é’±æ˜¯å¦æ»¡è¶³ï¼Œæ„Ÿè§‰è¿™æ®µä»£ç æœ‰ç‚¹æš´åŠ›çš„æ€æƒ³ï¼Ÿå¦‚æœé’±çš„ç»„åˆæ›´å¤æ‚æ€ä¹ˆåŠï¼Ÿ\nclass Solution:    def lemonadeChange(self, bills: List[int]) -&gt; bool:        money = Counter()                for i in bills:            if i == 5:                money[5] += 1            elif i == 10:                if money[5] &gt;= 1:                    money[10] += 1                    money[5] -= 1                else:                    return False            else:                if money[10] &gt;= 1 and money[5] &gt;= 1:                    money[10] -= 1                    money[5] -= 1                elif money[5] &gt;= 3:                    money[5] -= 3                else:                    return False        return True\næ­£ç¡®ç†è§£ï¼šå…±æœ‰ä¸‰ç§æƒ…å†µï¼š\n\næƒ…å†µä¸€ï¼šè´¦å•æ˜¯ 5ï¼Œç›´æ¥æ”¶ä¸‹ã€‚\næƒ…å†µäºŒï¼šè´¦å•æ˜¯ 10ï¼Œæ¶ˆè€—ä¸€ä¸ª 5ï¼Œå¢åŠ ä¸€ä¸ª 10\næƒ…å†µä¸‰ï¼šè´¦å•æ˜¯ 20ï¼Œä¼˜å…ˆæ¶ˆè€—ä¸€ä¸ª 10 å’Œä¸€ä¸ª 5ï¼Œå¦‚æœä¸å¤Ÿï¼Œå†æ¶ˆè€—ä¸‰ä¸ª 5\n\næƒ…å†µä¸‰å­˜åœ¨è´ªå¿ƒæ€æƒ³ï¼Œå› ä¸ºç¾å…ƒ 10 åªèƒ½ç»™è´¦å• 20 æ‰¾é›¶ï¼Œè€Œç¾å…ƒ 5 å¯ä»¥ç»™è´¦å• 10 å’Œè´¦å• 20 æ‰¾é›¶ï¼Œç¾å…ƒ 5 æ›´ä¸‡èƒ½ã€‚æ‰€ä»¥å±€éƒ¨æœ€ä¼˜ï¼šé‡åˆ°è´¦å• 20ï¼Œä¼˜å…ˆæ¶ˆè€—ç¾å…ƒ 10ï¼Œå®Œæˆæœ¬æ¬¡æ‰¾é›¶ã€‚å…¨å±€æœ€ä¼˜ï¼šå®Œæˆå…¨éƒ¨è´¦å•çš„æ‰¾é›¶ã€‚\n","categories":["Leetcode"],"tags":["greedy"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘è´ªå¿ƒç®—æ³•2-åºåˆ—é—®é¢˜","url":"/blog/Leetcode/greedy2/","content":"376. æ‘†åŠ¨åºåˆ—\nlink\n\nå¦‚æœè¿ç»­æ•°å­—ä¹‹é—´çš„å·®ä¸¥æ ¼åœ°åœ¨æ­£æ•°å’Œè´Ÿæ•°ä¹‹é—´äº¤æ›¿ï¼Œåˆ™æ•°å­—åºåˆ—ç§°ä¸º æ‘†åŠ¨åºåˆ— ã€‚ç¬¬ä¸€ä¸ªå·®ï¼ˆå¦‚æœå­˜åœ¨çš„è¯ï¼‰å¯èƒ½æ˜¯æ­£æ•°æˆ–è´Ÿæ•°ã€‚ä»…æœ‰ä¸€ä¸ªå…ƒç´ æˆ–è€…å«ä¸¤ä¸ªä¸ç­‰å…ƒç´ çš„åºåˆ—ä¹Ÿè§†ä½œæ‘†åŠ¨åºåˆ—ã€‚\n\nä¾‹å¦‚ï¼Œ [1, 7, 4, 9, 2, 5] æ˜¯ä¸€ä¸ª æ‘†åŠ¨åºåˆ— ï¼Œå› ä¸ºå·®å€¼ (6, -3, 5, -7, 3) æ˜¯æ­£è´Ÿäº¤æ›¿å‡ºç°çš„ã€‚\nç›¸åï¼Œ[1, 4, 7, 2, 5] å’Œ [1, 7, 4, 5, 5] ä¸æ˜¯æ‘†åŠ¨åºåˆ—ï¼Œç¬¬ä¸€ä¸ªåºåˆ—æ˜¯å› ä¸ºå®ƒçš„å‰ä¸¤ä¸ªå·®å€¼éƒ½æ˜¯æ­£æ•°ï¼Œç¬¬äºŒä¸ªåºåˆ—æ˜¯å› ä¸ºå®ƒçš„æœ€åä¸€ä¸ªå·®å€¼ä¸ºé›¶ã€‚å­åºåˆ— å¯ä»¥é€šè¿‡ä»åŸå§‹åºåˆ—ä¸­åˆ é™¤ä¸€äº›ï¼ˆä¹Ÿå¯ä»¥ä¸åˆ é™¤ï¼‰å…ƒç´ æ¥è·å¾—ï¼Œå‰©ä¸‹çš„å…ƒç´ ä¿æŒå…¶åŸå§‹é¡ºåºã€‚\n\nç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œè¿”å› nums ä¸­ä½œä¸º æ‘†åŠ¨åºåˆ— çš„ æœ€é•¿å­åºåˆ—çš„é•¿åº¦ ã€‚\næ€è·¯ 1ï¼šè´ªå¿ƒå±€éƒ¨æœ€ä¼˜ï¼šåˆ é™¤å•è°ƒå¡åº¦ä¸Šçš„èŠ‚ç‚¹ï¼ˆä¸åŒ…æ‹¬å•è°ƒå¡åº¦ä¸¤ç«¯çš„èŠ‚ç‚¹ï¼‰ï¼Œé‚£ä¹ˆè¿™ä¸ªå¡åº¦å°±å¯ä»¥æœ‰ä¸¤ä¸ªå±€éƒ¨å³°å€¼ã€‚\næ•´ä½“æœ€ä¼˜ï¼šæ•´ä¸ªåºåˆ—æœ‰æœ€å¤šçš„å±€éƒ¨å³°å€¼ï¼Œä»è€Œè¾¾åˆ°æœ€é•¿æ‘†åŠ¨åºåˆ—ã€‚\n\nå®é™…æ“ä½œä¸Šï¼Œå…¶å®è¿åˆ é™¤çš„æ“ä½œéƒ½ä¸ç”¨åšï¼Œå› ä¸ºé¢˜ç›®è¦æ±‚çš„æ˜¯æœ€é•¿æ‘†åŠ¨å­åºåˆ—çš„é•¿åº¦ï¼Œæ‰€ä»¥åªéœ€è¦ç»Ÿè®¡æ•°ç»„çš„å³°å€¼æ•°é‡å°±å¯ä»¥äº†ï¼ˆç›¸å½“äºæ˜¯åˆ é™¤å•ä¸€å¡åº¦ä¸Šçš„èŠ‚ç‚¹ï¼Œç„¶åç»Ÿè®¡é•¿åº¦ï¼‰ã€‚æ¯ä¸€æ­¥éƒ½åªå…³æ³¨å½“å‰æ˜¯å¦èƒ½æ„æˆâ€œæ‹ç‚¹â€ï¼ˆå³æ„æˆä¸€ä¸ªæœ‰æ•ˆçš„â€œæ‘†åŠ¨â€ï¼‰ï¼Œè€Œä¸æ˜¯æšä¸¾æ‰€æœ‰å­åºåˆ—è¿›è¡ŒåŠ¨æ€è§„åˆ’é€‰æ‹©ã€‚\nåœ¨è®¡ç®—æ˜¯å¦æœ‰å³°å€¼çš„æ—¶å€™ï¼Œé€šè¿‡éå†ä¸‹æ ‡ i ï¼Œè®¡ç®— prediff(nums[i] - nums[i-1]) å’Œ curdiff(nums[i+1] - nums[i])ï¼Œå¦‚æœ prediff &lt; 0 &amp;&amp; curdiff &gt; 0 æˆ–è€… prediff &gt; 0 &amp;&amp; curdiff &lt; 0 æ­¤æ—¶å°±æœ‰æ³¢åŠ¨å°±éœ€è¦ç»Ÿè®¡ã€‚\néœ€è¦æ³¨æ„ä»¥ä¸‹ä¸¤ç‚¹ï¼š\n\nåˆå§‹åŒ–ï¼š\nåºåˆ—é•¿åº¦å°äº 2 æ—¶ï¼Œæ— æ³•è®¡ç®—å…ƒç´ å·®ï¼Œæ‰€ä»¥ç›´æ¥è¿”å›åºåˆ—é•¿åº¦\ncount çš„åˆå§‹å€¼é—®é¢˜ï¼Œå¦‚æœå‰ä¸¤ä¸ªå…ƒç´ çš„å·®ä¸º 0ï¼Œåˆ™ count ä¸º 1ï¼ˆå½“å‰æ‘†åŠ¨åºåˆ—åªç®—ä¸€ä¸ªæ•°å­—ï¼‰ï¼›å¦åˆ™ä¸º 2ï¼ˆå‰ä¸¤ä¸ªæ•°å­—å…¨éƒ¨ç®—å…¥æ‘†åŠ¨åºåˆ—ä¸­ï¼‰\n\n\næ¡ä»¶åˆ¤æ–­ï¼š\npre &#x3D;&#x3D; 0 çš„æƒ…å†µï¼Œç›¸å½“äºå‰ä¸€å¯¹æ²¡æœ‰è¿›è¡Œå˜åŒ–ï¼Œå¦‚æœæ­¤æ—¶çš„ cur !&#x3D; 0ï¼Œåˆ™è¯´æ˜é‡åˆ°äº†ç¬¬ä¸€ä¸ªæ³¢åŠ¨ï¼Œéœ€è¦è®°å½•\n\n\n\nè¯¦ç»†çš„æ¡ˆä¾‹åˆ†æè§ä»£ç éšæƒ³å½•\nclass Solution:    def wiggleMaxLength(self, nums: List[int]) -&gt; int:        if len(nums) &lt; 2:            return len(nums)                pre = nums[1] - nums[0]        if pre != 0:            count = 2        else:            count = 1        for i in range(1, len(nums) - 1):            cur = nums[i + 1] - nums[i]            if (cur &gt; 0 and pre &lt;= 0) or (cur &lt; 0 and pre &gt;= 0):                count += 1                pre = cur        return count \n\n738.å•è°ƒé€’å¢çš„æ•°å­—\nlink\n\nå½“ä¸”ä»…å½“æ¯ä¸ªç›¸é‚»ä½æ•°ä¸Šçš„æ•°å­— x å’Œ y æ»¡è¶³ x &lt;&#x3D; y æ—¶ï¼Œæˆ‘ä»¬ç§°è¿™ä¸ªæ•´æ•°æ˜¯å•è°ƒé€’å¢çš„ã€‚ç»™å®šä¸€ä¸ªæ•´æ•° n ï¼Œè¿”å› å°äºæˆ–ç­‰äº n çš„æœ€å¤§æ•°å­—ï¼Œä¸”æ•°å­—å‘ˆ å•è°ƒé€’å¢ ã€‚\nç¤ºä¾‹ 1:\n\nè¾“å…¥: n &#x3D; 10è¾“å‡º: 9  \n\nç¤ºä¾‹ 2:\n\nè¾“å…¥: n &#x3D; 1234è¾“å‡º: 1234  \n\nç¤ºä¾‹ 3:\n\nè¾“å…¥: n &#x3D; 332è¾“å‡º: 299  \n\næ€è·¯ä¾‹å¦‚ï¼š98ï¼Œä¸€æ—¦å‡ºç° strNum[i - 1] &gt; strNum[i] çš„æƒ…å†µï¼ˆéå•è°ƒé€’å¢ï¼‰ï¼Œé¦–å…ˆæƒ³è®© strNum[i - 1]â€“ï¼Œç„¶å strNum[i] ç»™ä¸º9ï¼Œè¿™æ ·è¿™ä¸ªæ•´æ•°å°±æ˜¯ 89ï¼Œå³å°äº 98 çš„æœ€å¤§çš„å•è°ƒé€’å¢æ•´æ•°ã€‚\nè¿™æ ·å°±åªèƒ½ä»åå¾€å‰éå†äº†ã€‚å› ä¸ºéœ€è¦å…ˆç¡®å®šå¤§çš„æ•°å­—ã€‚æ•´ä½“æµç¨‹ä¸ºï¼šåå‘éå†ï¼Œå¦‚æœå½“å‰æ•°å­—å°äºå‰ä¸€ä¸ªï¼Œåˆ™å‰ä¸€ä½â€œå€Ÿ 1â€ï¼Œå½“å‰ä½ç½®ä¹‹åçš„æ‰€æœ‰æ•°å­—éƒ½è®¾ç½®ä¸º 9\nclass Solution:    def monotoneIncreasingDigits(self, n: int) -&gt; int:        num = list(str(n))        for i in range(len(num) - 1, 0, -1):            if num[i] &lt; num[i - 1]:                num[i - 1] = str(int(num[i - 1]) - 1)                for j in range(i, len(num)):                    num[j] = &#x27;9&#x27;        return int(&#x27;&#x27;.join(num))\n\n","categories":["Leetcode"],"tags":["greedy"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘è´ªå¿ƒç®—æ³•4-ä¸¤ä¸ªç»´åº¦æƒè¡¡é—®é¢˜","url":"/blog/Leetcode/greedy4/","content":"135. åˆ†å‘ç³–æœ\nlink\n\nn ä¸ªå­©å­ç«™æˆä¸€æ’ã€‚ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ ratings è¡¨ç¤ºæ¯ä¸ªå­©å­çš„è¯„åˆ†ã€‚\nä½ éœ€è¦æŒ‰ç…§ä»¥ä¸‹è¦æ±‚ï¼Œç»™è¿™äº›å­©å­åˆ†å‘ç³–æœï¼šæ¯ä¸ªå­©å­è‡³å°‘åˆ†é…åˆ° 1 ä¸ªç³–æœã€‚ç›¸é‚»ä¸¤ä¸ªå­©å­è¯„åˆ†æ›´é«˜çš„å­©å­ä¼šè·å¾—æ›´å¤šçš„ç³–æœã€‚è¯·ä½ ç»™æ¯ä¸ªå­©å­åˆ†å‘ç³–æœï¼Œè®¡ç®—å¹¶è¿”å›éœ€è¦å‡†å¤‡çš„ æœ€å°‘ç³–æœæ•°ç›® ã€‚\næ€è·¯ä¸€ä¸ªå­©å­çš„ç³–æœæ•°é‡è¦æ”¶åˆ°å·¦å³ä¸¤è¾¹çš„é™åˆ¶ï¼Œæ‰€ä»¥éœ€è¦éå†ä¸¤æ¬¡ã€‚ç¡®å®šä¸€è¾¹ä¹‹åï¼Œå†ç¡®å®šå¦ä¸€è¾¹ï¼Œä¾‹å¦‚æ¯”è¾ƒæ¯ä¸€ä¸ªå­©å­çš„å·¦è¾¹ï¼Œç„¶åå†æ¯”è¾ƒå³è¾¹ï¼Œå¦‚æœä¸¤è¾¹ä¸€èµ·è€ƒè™‘ä¸€å®šä¼šé¡¾æ­¤å¤±å½¼ã€‚\n\nå•å‘è´ªå¿ƒåªèƒ½è€ƒè™‘å•ä¾§çš„çº¦æŸï¼ˆå³â€œå½“å‰å­©å­æ¯”å·¦è¾¹&#x2F;å³è¾¹å¤§â€ï¼‰ã€‚\nä½†å­©å­å¯èƒ½åŒæ—¶æ¯”å·¦è¾¹å’Œå³è¾¹å¤§ï¼Œå› æ­¤å¿…é¡»åŒå‘åˆ†åˆ«å¤„ç†æ¯ä¸ªæ–¹å‘çš„å…³ç³»ã€‚\nä¸¤æ¬¡éå†åï¼Œæ¯ä¸ªå­©å­çš„ç³–æœæ•°å°±æ˜¯ï¼šæ»¡è¶³æ‰€æœ‰çº¦æŸæ¡ä»¶çš„æœ€å°å€¼ã€‚\n\nå±€éƒ¨æœ€ä¼˜ï¼šåªè¦å³è¾¹è¯„åˆ†æ¯”å·¦è¾¹å¤§ï¼Œå³è¾¹çš„å­©å­å°±å¤šä¸€ä¸ªç³–æœï¼Œå…¨å±€æœ€ä¼˜ï¼šç›¸é‚»çš„å­©å­ä¸­ï¼Œè¯„åˆ†é«˜çš„å³å­©å­è·å¾—æ¯”å·¦è¾¹å­©å­æ›´å¤šçš„ç³–æœï¼ˆåå‘åŒç†ï¼‰ã€‚æ³¨æ„åå‘éå†æ—¶çš„èµ‹å€¼é—®é¢˜ã€‚\nclass Solution:    def candy(self, ratings: List[int]) -&gt; int:        res = [1] * len(ratings)        for i in range(1, len(ratings)):            if ratings[i] &gt; ratings[i - 1]:                res[i] = res[i - 1] + 1                    for i in range(len(ratings) - 2, -1, -1):            if ratings[i] &gt; ratings[i + 1]:                res[i] = max(res[i], res[i + 1] + 1)                    return sum(res)\n406.æ ¹æ®èº«é«˜é‡å»ºé˜Ÿåˆ—\nlink\n\nå‡è®¾æœ‰æ‰“ä¹±é¡ºåºçš„ä¸€ç¾¤äººç«™æˆä¸€ä¸ªé˜Ÿåˆ—ï¼Œæ•°ç»„ people è¡¨ç¤ºé˜Ÿåˆ—ä¸­ä¸€äº›äººçš„å±æ€§ï¼ˆä¸ä¸€å®šæŒ‰é¡ºåºï¼‰ã€‚æ¯ä¸ª people[i] &#x3D; [hi, ki] è¡¨ç¤ºç¬¬ i ä¸ªäººçš„èº«é«˜ä¸º hi ï¼Œå‰é¢ æ­£å¥½ æœ‰ ki ä¸ªèº«é«˜å¤§äºæˆ–ç­‰äº hi çš„äººã€‚\nè¯·ä½ é‡æ–°æ„é€ å¹¶è¿”å›è¾“å…¥æ•°ç»„ people æ‰€è¡¨ç¤ºçš„é˜Ÿåˆ—ã€‚è¿”å›çš„é˜Ÿåˆ—åº”è¯¥æ ¼å¼åŒ–ä¸ºæ•°ç»„ queue ï¼Œå…¶ä¸­ queue[j] &#x3D; [hj, kj] æ˜¯é˜Ÿåˆ—ä¸­ç¬¬ j ä¸ªäººçš„å±æ€§ï¼ˆqueue[0] æ˜¯æ’åœ¨é˜Ÿåˆ—å‰é¢çš„äººï¼‰ã€‚\nç¤ºä¾‹ï¼š\n\nè¾“å…¥ï¼špeople &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]è¾“å‡ºï¼š[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]è§£é‡Šï¼šç¼–å·ä¸º 0 çš„äººèº«é«˜ä¸º 5 ï¼Œæ²¡æœ‰èº«é«˜æ›´é«˜æˆ–è€…ç›¸åŒçš„äººæ’åœ¨ä»–å‰é¢ã€‚ç¼–å·ä¸º 1 çš„äººèº«é«˜ä¸º 7 ï¼Œæ²¡æœ‰èº«é«˜æ›´é«˜æˆ–è€…ç›¸åŒçš„äººæ’åœ¨ä»–å‰é¢ã€‚ç¼–å·ä¸º 2 çš„äººèº«é«˜ä¸º 5 ï¼Œæœ‰ 2 ä¸ªèº«é«˜æ›´é«˜æˆ–è€…ç›¸åŒçš„äººæ’åœ¨ä»–å‰é¢ï¼Œå³ç¼–å·ä¸º 0 å’Œ 1 çš„äººã€‚ç¼–å·ä¸º 3 çš„äººèº«é«˜ä¸º 6 ï¼Œæœ‰ 1 ä¸ªèº«é«˜æ›´é«˜æˆ–è€…ç›¸åŒçš„äººæ’åœ¨ä»–å‰é¢ï¼Œå³ç¼–å·ä¸º 1 çš„äººã€‚ç¼–å·ä¸º 4 çš„äººèº«é«˜ä¸º 4 ï¼Œæœ‰ 4 ä¸ªèº«é«˜æ›´é«˜æˆ–è€…ç›¸åŒçš„äººæ’åœ¨ä»–å‰é¢ï¼Œå³ç¼–å·ä¸º 0ã€1ã€2ã€3 çš„äººã€‚ç¼–å·ä¸º 5 çš„äººèº«é«˜ä¸º 7 ï¼Œæœ‰ 1 ä¸ªèº«é«˜æ›´é«˜æˆ–è€…ç›¸åŒçš„äººæ’åœ¨ä»–å‰é¢ï¼Œå³ç¼–å·ä¸º 1 çš„äººã€‚å› æ­¤ [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] æ˜¯é‡æ–°æ„é€ åçš„é˜Ÿåˆ—ã€‚\n\næ€è·¯æœ‰ä¸¤ä¸ªç»´åº¦ï¼Œh å’Œ kï¼Œçœ‹åˆ°è¿™ç§é¢˜ç›®ä¸€å®šè¦æƒ³å¦‚ä½•ç¡®å®šä¸€ä¸ªç»´åº¦ï¼Œç„¶åå†æŒ‰ç…§å¦ä¸€ä¸ªç»´åº¦é‡æ–°æ’åˆ—ã€‚\né¦–å…ˆæŒ‰ç…§ h æ’åºï¼Œèº«é«˜ä¸€å®šæ˜¯ä»å¤§åˆ°å°æ’ï¼ˆèº«é«˜ç›¸åŒçš„è¯åˆ™ k å°çš„ç«™å‰é¢ï¼‰ï¼Œè®©é«˜ä¸ªå­åœ¨å‰é¢ã€‚å‰é¢çš„èŠ‚ç‚¹ä¸€å®šéƒ½æ¯”å½“å‰èŠ‚ç‚¹é«˜ã€‚\næŒ‰ç…§èº«é«˜æ’åºä¹‹åï¼Œä¼˜å…ˆæŒ‰èº«é«˜é«˜çš„ people çš„ k æ¥æ’å…¥ï¼Œååºæ’å…¥èŠ‚ç‚¹ä¹Ÿä¸ä¼šå½±å“å‰é¢å·²ç»æ’å…¥çš„èŠ‚ç‚¹ï¼Œæœ€ç»ˆæŒ‰ç…§ k çš„è§„åˆ™å®Œæˆäº†é˜Ÿåˆ—ã€‚\n\n\nå±€éƒ¨æœ€ä¼˜ï¼šä¼˜å…ˆæŒ‰èº«é«˜é«˜çš„peopleçš„kæ¥æ’å…¥ã€‚æ’å…¥æ“ä½œè¿‡åçš„peopleæ»¡è¶³é˜Ÿåˆ—å±æ€§\nå…¨å±€æœ€ä¼˜ï¼šæœ€åéƒ½åšå®Œæ’å…¥æ“ä½œï¼Œæ•´ä¸ªé˜Ÿåˆ—æ»¡è¶³é¢˜ç›®é˜Ÿåˆ—å±æ€§\n\nclass Solution:    def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]:        people.sort(key=lambda x: (-x[0], x[1]))        res = []        for p in people:            res.insert(p[1], p)        return res\n\nsortkey æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºä»æ¯ä¸ªå…ƒç´ ä¸­æå–å‡ºç”¨äºæ’åºçš„å…³é”®å­—ã€‚\nä¾‹å­ 1nums = [3, 12, -4, 6]nums.sort(key=abs)print(nums)  # è¾“å‡ºï¼š[-4, 3, 6, 12]\n\nabs æ˜¯ Python çš„å†…ç½®å‡½æ•°ï¼Œè¿”å›ç»å¯¹å€¼\næ’åºæ—¶æ¯”è¾ƒçš„æ˜¯æ¯ä¸ªå…ƒç´ çš„ abs(x) å€¼ï¼Œè€Œä¸æ˜¯åŸå§‹å€¼æœ¬èº«\n\nä¾‹å­ 2æŒ‰å­—ç¬¦ä¸²é•¿åº¦æ’åº\nwords = [&quot;apple&quot;, &quot;a&quot;, &quot;banana&quot;, &quot;pear&quot;]words.sort(key=len)print(words)  # è¾“å‡ºï¼š[&#x27;a&#x27;, &#x27;pear&#x27;, &#x27;apple&#x27;, &#x27;banana&#x27;]\n\nä¾‹å­ 3æ’åºäºŒç»´æ•°ç»„\narr = [[7, 0], [4, 4], [7, 1], [5, 0]]arr.sort(key=lambda x: (x[0], x[1]))print(arr)  # è¾“å‡ºï¼š[[4, 4], [5, 0], [7, 0], [7, 1]]\n\nkey&#x3D;lambda x: (x[0], x[1]) è¡¨ç¤ºå…ˆæŒ‰ç¬¬ä¸€ä¸ªå…ƒç´ æ’ï¼Œå†æŒ‰ç¬¬äºŒä¸ªå…ƒç´ æ’\nlambda å°†åˆ—è¡¨çš„æ¯ä¸€ä¸ªå…ƒç´ éƒ½æ„é€ ä¸ºä¸€ä¸ªå…ƒç»„ã€‚å³ä½¿ç”¨å…ƒç»„æ’åºçš„è§„åˆ™ï¼šå…ˆæ¯”ç¬¬ä¸€ä¸ªï¼Œä¸åŒå°±ç¡®å®šï¼›ç›¸åŒå°±æ¯”ç¬¬äºŒä¸ª\n\nä¾‹å­ 4people = [[7,0],[4,4],[7,1],[5,0]]people.sort(key=lambda x: (-x[0], x[1]))\n\n-x[0]ï¼šè¡¨ç¤ºèº«é«˜ä»é«˜åˆ°ä½æ’åº\nx[1]ï¼šå½“èº«é«˜ç›¸åŒæ—¶ï¼ŒæŒ‰ k å€¼ä»å°åˆ°å¤§æ’åº\n\nä¾‹å­ 5å¯¹æ¯” people.sort(key&#x3D;lambda x: (x[0], x[1]), reverse&#x3D;True) å’Œ people.sort(key&#x3D;lambda x: (-x[0], x[1]))ã€‚\n\npeople.sort(key&#x3D;lambda x: (-x[0], x[1]))ï¼š\nç¬¬ä¸€å…³é”®å­—ï¼š-x[0] â†’ æŒ‰èº«é«˜ä»å¤§åˆ°å°\nç¬¬äºŒå…³é”®å­—ï¼šx[1] â†’ åŒèº«é«˜æ—¶ï¼Œk å€¼ä»å°åˆ°å¤§\n\n\npeople.sort(key&#x3D;lambda x: (x[0], x[1]), reverse&#x3D;True)\nå…ˆæŒ‰ x[0] å‡åºã€å†æŒ‰ x[1] å‡åºï¼Œç„¶åæ•´ä½“ç»“æœç¿»è½¬æˆé™åºã€‚\nç»“æœæ˜¯èº«é«˜å’Œ k éƒ½æ˜¯é™åºã€‚\n\n\n\n","categories":["Leetcode"],"tags":["greedy"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘å“ˆå¸Œè¡¨1","url":"/blog/Leetcode/hash1/","content":"Python å“ˆå¸Œè¡¨ç›¸å…³æ“ä½œå“ˆå¸Œè¡¨éƒ½æ˜¯ç”¨æ¥å¿«é€Ÿåˆ¤æ–­ä¸€ä¸ªå…ƒç´ æ˜¯å¦å‡ºç°é›†åˆé‡Œã€‚ä¾‹å¦‚è¦æŸ¥è¯¢ä¸€ä¸ªåå­—æ˜¯å¦åœ¨è¿™æ‰€å­¦æ ¡é‡Œã€‚è¦æšä¸¾çš„è¯æ—¶é—´å¤æ‚åº¦æ˜¯O(n)ï¼Œä½†å¦‚æœä½¿ç”¨å“ˆå¸Œè¡¨çš„è¯ï¼Œ åªéœ€è¦O(1)å°±å¯ä»¥åšåˆ°ã€‚\nlistdictdefaultdict å’Œ Counterè¿™ä¸¤ä¸ªç±»éƒ½æ˜¯ dict çš„å­ç±»ï¼Œåœ¨ key ä¸å­˜åœ¨æ—¶ï¼Œdict ä¼šæŠ¥é”™ã€‚ä½†æ˜¯è¿™ä¸¤ä¸ªç±»å®šä¹‰äº† __missing__() æ–¹æ³•ï¼Œåœ¨ key ä¸å­˜åœ¨æ—¶ï¼Œä¼šè°ƒç”¨è¯¥æ–¹æ³•å¹¶è¿”å›å…¶å€¼ã€‚ä¾‹å¦‚ï¼ŒCounter ç±»çš„å®šä¹‰å¦‚ä¸‹ï¼Œå³ key ä¸å­˜åœ¨çš„è¯å°±è¿”å› 0ï¼Œæ»¡è¶³è®¡æ•°å™¨çš„è¦æ±‚ã€‚\nclass Counter(dict):    def __missing__(self, key):        return 0\n\ndefaultdict åˆ™ä¼šè¿”å›åˆå§‹åŒ–æ—¶ç»™å®šçš„ç±»å‹ã€‚ä¾‹å¦‚ï¼š\nd = defaultdict(int)d = defaultdict(list)\n\nä½¿ç”¨ dict ä¹Ÿå¯ä»¥å®ç° Counter ç±»ä¼¼çš„æ•ˆæœï¼š\nd = dict()d[key] = d.get(key, 0) + 1\n\n\nseté›†åˆä¸­çš„å…ƒç´ ä¸å¯é‡å¤ï¼Œå¯ä»¥éå†ï¼Œä½†ä¸èƒ½ä½¿ç”¨ç´¢å¼•æ¥è®¿é—®ã€‚\næ·»åŠ å…ƒç´ ï¼šadd()\nåˆ é™¤å…ƒç´ ï¼šremove()\n242. æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯\né¢˜ç›®é“¾æ¥ link\n\nç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸² s å’Œ t ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥åˆ¤æ–­ t æ˜¯å¦æ˜¯ s çš„ å­—æ¯å¼‚ä½è¯ã€‚\nç¤ºä¾‹ 1:\n\nè¾“å…¥: s &#x3D; â€œanagramâ€, t &#x3D; â€œnagaramâ€è¾“å‡º: true  \n\nç¤ºä¾‹ 2:\n\nè¾“å…¥: s &#x3D; â€œratâ€, t &#x3D; â€œcarâ€è¾“å‡º: false  \n\næ€è·¯åˆ†åˆ«è®°å½•ä¸¤ä¸ªå­—ç¬¦ä¸²ä¸­å„ä¸ªå­—ç¬¦çš„æ•°é‡ï¼Œç„¶ååˆ¤æ–­æ˜¯å¦ç›¸ç­‰ã€‚\næ•°ç»„å†™æ³•ä½¿ç”¨ç›¸å¯¹çš„ ASCII æ¥ä½œä¸ºç´¢å¼•ã€‚è¿™é‡Œä½¿ç”¨äº† ord æ–¹æ³•ï¼Œç”¨äºå°†å­—ç¬¦è½¬æ¢ä¸ºæ•°å­—ã€‚\nclass Solution:    def isAnagram(self, s: str, t: str) -&gt; bool:        s_list = [0 for _ in range(26)]        for i in s:            index = ord(i) - ord(&#x27;a&#x27;)            s_list[index] += 1                for i in t:            index = ord(i) - ord(&#x27;a&#x27;)            s_list[index] -= 1                for i in s_list:            if i != 0:                return False                return True\n\nå­—å…¸å†™æ³•æ³¨æ„éœ€è¦ä½¿ç”¨ get(i, 0) æ–¹æ³•ï¼Œå¦‚æœæ²¡æœ‰å¯¹åº”çš„é”®å€¼ï¼Œåˆ™è¿”å› 0ã€‚\nclass Solution:    def isAnagram(self, s: str, t: str) -&gt; bool:        record = &#123;&#125;        for i in s:            record[i] = record.get(i, 0) + 1                for i in t:            record[i] = record.get(i, 0) - 1                for i in record:            if record[i] != 0:                return False                return True\n\nCounter å†™æ³•å¯ä»¥ç›´æ¥æ¯”è¾ƒä¸¤ä¸ª Counterï¼ˆè®¡æ•°å™¨ dictï¼‰\nclass Solution:    def isAnagram(self, s: str, t: str) -&gt; bool:        record_s = Counter()        record_t = Counter()        for i in s:            record_s[i] += 1                for i in t:            record_t[i] += 1                if record_s == record_t:            return True        else:            return False\n\n49. å­—æ¯å¼‚ä½è¯åˆ†ç»„\né¢˜ç›®é“¾æ¥ link\n\nç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ï¼Œè¯·ä½ å°† å­—æ¯å¼‚ä½è¯ ç»„åˆåœ¨ä¸€èµ·ã€‚å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç»“æœåˆ—è¡¨ã€‚\nç¤ºä¾‹ 1:\n\nè¾“å…¥: strs &#x3D; [â€œeatâ€, â€œteaâ€, â€œtanâ€, â€œateâ€, â€œnatâ€, â€œbatâ€]è¾“å‡º: [[â€œbatâ€],[â€œnatâ€,â€tanâ€],[â€œateâ€,â€eatâ€,â€teaâ€]]è§£é‡Šï¼šåœ¨ strs ä¸­æ²¡æœ‰å­—ç¬¦ä¸²å¯ä»¥é€šè¿‡é‡æ–°æ’åˆ—æ¥å½¢æˆ â€œbatâ€ã€‚å­—ç¬¦ä¸² â€œnatâ€ å’Œ â€œtanâ€ æ˜¯å­—æ¯å¼‚ä½è¯ï¼Œå› ä¸ºå®ƒä»¬å¯ä»¥é‡æ–°æ’åˆ—ä»¥å½¢æˆå½¼æ­¤ã€‚å­—ç¬¦ä¸² â€œateâ€ ï¼Œâ€eatâ€ å’Œ â€œteaâ€ æ˜¯å­—æ¯å¼‚ä½è¯ï¼Œå› ä¸ºå®ƒä»¬å¯ä»¥é‡æ–°æ’åˆ—ä»¥å½¢æˆå½¼æ­¤ã€‚  \n\næ€è·¯ 1éå†æ‰€æœ‰çš„å­—ç¬¦ä¸²ï¼Œåˆ¤æ–­è¯¥å­—ç¬¦ä¸²æ˜¯å¦å’Œå·²ç»åˆ†å¥½ç»„çš„å­—ç¬¦ä¸²ä¸ºå­—æ¯å¼‚ä½è¯ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™æ·»åŠ åˆ°æ»¡è¶³çš„é‚£ä¸ªç»„ï¼Œå¦‚æœä¸æ˜¯åˆ™å•ç‹¬æ·»åŠ ä¸ºä¸€ä¸ªç»„ã€‚ä½†æ˜¯è¿™æ®µä»£ç ä¼šè¶…å‡ºæ—¶é—´é™åˆ¶ã€‚\nclass Solution:    def judge(self, s, t):        record_s = Counter()        record_t = Counter()        for i in s:            record_s[i] += 1                for i in t:            record_t[i] += 1                if record_s == record_t:            return True        else:            return False    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        res = []        for s in strs:            if len(res) == 0:                res.append([s])            else:                flag = False                for index in range(len(res)):                    if self.judge(s, res[index][0]):                        res[index].append(s)                        flag = True                        break                if flag == False:                    res.append([s])                return res\n\næ€è·¯ 2æ€è·¯ 1 çš„æ—¶é—´å¤æ‚åº¦ä¸º O(n*n*n)ï¼Œä¼˜åŒ–çš„ç‚¹åœ¨äºåˆ¤æ–­æ˜¯å¦ä¸ºå­—æ¯å¼‚ä½è¯æ—¶ï¼Œå¯ä»¥å°†å­—ç¬¦ä¸²è¿›è¡Œæ’åºï¼Œå°†æ’åºåçš„å­—ç¬¦ä¸²ä½œä¸º keyï¼Œå°†å¯¹åº”çš„å­—ç¬¦ä¸²å­˜åœ¨ä¸€ä¸ª list ä¸­ ä½œä¸º valueã€‚è¿™é‡Œéœ€è¦ç”¨åˆ° defaultdictã€‚å½“è®¿é—®ä¸€ä¸ªä¸å­˜åœ¨çš„é”®æ—¶ï¼Œdefaultdict ä¼šè‡ªåŠ¨è°ƒç”¨ default_factory ç”Ÿæˆä¸€ä¸ªé»˜è®¤å€¼å¹¶æ’å…¥å­—å…¸ï¼Œç„¶åè¿”å›è¿™ä¸ªå€¼ã€‚\nè¿™é‡Œä½¿ç”¨äº† sorted æ–¹æ³•ï¼Œå¯ä»¥å°†ä»»æ„å¯è¿­ä»£çš„å¯¹è±¡è¿›è¡Œæ’åºï¼Œè¿”å›ä¸€ä¸ª listã€‚\nclass Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        d = defaultdict(list)        for s in strs:            key = &quot;&quot;.join(sorted(s))            d[key].append(s)                return list(d.values())\n\n438. æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—æ¯å¼‚ä½è¯\nlink\n\nç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸² s å’Œ pï¼Œæ‰¾åˆ° s ä¸­æ‰€æœ‰ p çš„ å¼‚ä½è¯ çš„å­ä¸²ï¼Œè¿”å›è¿™äº›å­ä¸²çš„èµ·å§‹ç´¢å¼•ã€‚ä¸è€ƒè™‘ç­”æ¡ˆè¾“å‡ºçš„é¡ºåºã€‚\nç¤ºä¾‹ 1:\n\nè¾“å…¥: s &#x3D; â€œcbaebabacdâ€, p &#x3D; â€œabcâ€è¾“å‡º: [0,6]è§£é‡Š:èµ·å§‹ç´¢å¼•ç­‰äº 0 çš„å­ä¸²æ˜¯ â€œcbaâ€, å®ƒæ˜¯ â€œabcâ€ çš„å¼‚ä½è¯ã€‚èµ·å§‹ç´¢å¼•ç­‰äº 6 çš„å­ä¸²æ˜¯ â€œbacâ€, å®ƒæ˜¯ â€œabcâ€ çš„å¼‚ä½è¯ã€‚  \n\næ€è·¯æ»‘åŠ¨çª—å£ï¼Œå¯¹äºæ¯ä¸€ä¸ªå­—ä¸²éƒ½è¿›è¡Œåˆ¤æ–­ã€‚æœ‰å¦‚ä¸‹ä¼˜åŒ–ï¼š\n\nå¦‚æœå½“å‰å­—ä¸²æ˜¯å­—æ¯å¼‚ä½è¯ï¼Œåˆ™åªéœ€è¦æ¯”è¾ƒå½“å‰çª—å£å‡ºå»çš„å­—ç¬¦å’Œè¿›æ¥çš„å­—ç¬¦æ˜¯å¦ç›¸ç­‰ï¼Œå¦‚æœç›¸ç­‰åˆ™ä¸‹ä¸€ä¸ªå­—ä¸²ä¹Ÿä¸ºå­—æ¯å¼‚ä½è¯ã€‚\nåˆ¤æ–­å­—æ¯å¼‚ä½è¯ç›´æ¥ä½¿ç”¨æ’åºï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(klogk)ï¼Œå¦åˆ™ä¸º\n\nclass Solution:    def judge(self, s, t):        ss = &quot;&quot;.join(sorted(s))        tt = &quot;&quot;.join(sorted(t))        if ss == tt:            return True        else:            return False          def findAnagrams(self, s: str, p: str) -&gt; List[int]:        res = []        pre = None        for start in range(len(s) - len(p) + 1):            end = start + len(p)            if pre == None:                if self.judge(s[start:end], p):                    res.append(start)                    pre = s[start]            else:                if pre == s[end - 1]:                    res.append(start)                    pre = s[start]                else:                    pre = None        return res\n\næ€è·¯ 2å¯¹äºæ¯ä¸ªå­—ä¸²ï¼Œä¸ç”¨æ¯æ¬¡éƒ½è¿›è¡Œåˆ¤æ–­ï¼Œåªéœ€è¦è®°å½•æ¯ä¸ªå­—ç¬¦çš„æ•°é‡ä»¥åŠå…¶å˜åŒ–æƒ…å†µå³å¯ã€‚\n","categories":["Leetcode"],"tags":["hash"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘å“ˆå¸Œè¡¨2","url":"/blog/Leetcode/hash2/","content":"349. ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†\né¢˜ç›®é“¾æ¥ link\n\nç»™å®šä¸¤ä¸ªæ•°ç»„ nums1 å’Œ nums2 ï¼Œè¿”å› å®ƒä»¬çš„ äº¤é›† ã€‚è¾“å‡ºç»“æœä¸­çš„æ¯ä¸ªå…ƒç´ ä¸€å®šæ˜¯ å”¯ä¸€ çš„ã€‚æˆ‘ä»¬å¯ä»¥ ä¸è€ƒè™‘è¾“å‡ºç»“æœçš„é¡ºåº ã€‚\næ€è·¯ 1å°†ä¸¤ä¸ª list è½¬æ¢ä¸º setï¼ˆç¡®ä¿ä¸€ä¸ªæ•°å­—åœ¨ä¸€ä¸ª list ä¸­åªå­˜åœ¨ä¸€æ¬¡ï¼‰ï¼Œç„¶ååˆ†åˆ«è¿›è¡Œéå†ï¼Œç»Ÿè®¡æ‰€æœ‰æ•°å­—å‡ºç°çš„æ¬¡æ•°ï¼Œå‡ºç°æ¬¡æ•°ä¸º 2 çš„å³ä¸ºäº¤é›†ã€‚æœ¬è´¨ä¸Šæ˜¯ç”¨ dict ä½œä¸ºå“ˆå¸Œè¡¨ã€‚\nclass Solution:    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:        c = Counter()        res = []        for i in set(nums1):            c[i] += 1                for i in set(nums2):            c[i] += 1                for key in c:            if c[key] &gt; 1:                res.append(key)        return res\n\næ€è·¯ 2ä¸€æ­¥åˆ°ä½ï¼Œç›´æ¥ä½¿ç”¨ set çš„ &amp; æ“ä½œç¬¦æ¥è®¡ç®—äº¤é›†ã€‚\nclass Solution:    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:        return list(set(nums1) &amp; set(nums2))\n\n350. ä¸¤ä¸ªæ•°ç»„çš„äº¤é›† II\né¢˜ç›®é“¾æ¥ link\n\nç»™ä½ ä¸¤ä¸ªæ•´æ•°æ•°ç»„ nums1 å’Œ nums2 ï¼Œè¯·ä½ ä»¥æ•°ç»„å½¢å¼è¿”å›ä¸¤æ•°ç»„çš„äº¤é›†ã€‚è¿”å›ç»“æœä¸­æ¯ä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•°ï¼Œåº”ä¸å…ƒç´ åœ¨ä¸¤ä¸ªæ•°ç»„ä¸­éƒ½å‡ºç°çš„æ¬¡æ•°ä¸€è‡´ï¼ˆå¦‚æœå‡ºç°æ¬¡æ•°ä¸ä¸€è‡´ï¼Œåˆ™è€ƒè™‘å–è¾ƒå°å€¼ï¼‰ã€‚å¯ä»¥ä¸è€ƒè™‘è¾“å‡ºç»“æœçš„é¡ºåºã€‚\nç¤ºä¾‹ 1ï¼š\n\nè¾“å…¥ï¼šnums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]è¾“å‡ºï¼š[2,2]  \n\nç¤ºä¾‹ 2:\n\nè¾“å…¥ï¼šnums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]è¾“å‡ºï¼š[4,9]\n\næ€è·¯ç”¨ dict æ¥è®°å½•ä¸¤ä¸ª list ä¸­æ•°å­—çš„æ•°é‡ï¼Œç„¶ååˆ¤æ–­é‡å éƒ¨åˆ†çš„æ•°é‡ã€‚\nclass Solution:    def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:        c1 = Counter()        c2 = Counter()        for i in nums1:            c1[i] += 1                for i in nums2:            c2[i] += 1        res = []        for key in c1:            if c1[key] &gt; 0 and c2[key] &gt; 0:                for i in range(min(c1[key], c2[key])):                    res.append(key)        return res        &#x27;\n\n202. å¿«ä¹æ•°\nlink\n\nç¼–å†™ä¸€ä¸ªç®—æ³•æ¥åˆ¤æ–­ä¸€ä¸ªæ•° n æ˜¯ä¸æ˜¯å¿«ä¹æ•°ã€‚\nã€Œå¿«ä¹æ•°ã€ å®šä¹‰ä¸ºï¼š\nå¯¹äºä¸€ä¸ªæ­£æ•´æ•°ï¼Œæ¯ä¸€æ¬¡å°†è¯¥æ•°æ›¿æ¢ä¸ºå®ƒæ¯ä¸ªä½ç½®ä¸Šçš„æ•°å­—çš„å¹³æ–¹å’Œã€‚ç„¶åé‡å¤è¿™ä¸ªè¿‡ç¨‹ç›´åˆ°è¿™ä¸ªæ•°å˜ä¸º 1ï¼Œä¹Ÿå¯èƒ½æ˜¯ æ— é™å¾ªç¯ ä½†å§‹ç»ˆå˜ä¸åˆ° 1ã€‚å¦‚æœè¿™ä¸ªè¿‡ç¨‹ ç»“æœä¸º 1ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°å°±æ˜¯å¿«ä¹æ•°ã€‚\næ€è·¯ç”¨ä¸€ä¸ª set è®°å½•å‡ºç°è¿‡çš„ç»“æœï¼Œå¦‚æœå‡ºç°è¿‡äº†è¯¥ç»“æœï¼Œåˆ™è¯´æ˜ä¸æ˜¯å¿«ä¹æ•°\nclass Solution:    def isHappy(self, n: int) -&gt; bool:        s = 0        l = set()        while s != 1:            s = 0            while n != 0:                temp = n % 10                s += temp * temp                n = n // 10                        if s in l:                return False            else:                if s == 1:                    return True                l.add(s)                n = s\n\næ³¨æ„ï¼Œè™½ç„¶ set å’Œ list éƒ½æ˜¯ç”¨ in æ¥åˆ¤æ–­æ˜¯å¦å­˜åœ¨ï¼Œä½†æ˜¯å…¶å¤æ‚åº¦å·®å¾ˆå¤šï¼š\n1. ä¸¤æ•°ä¹‹å’Œ\nlink\n\nç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å€¼ targetï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡º å’Œä¸ºç›®æ ‡å€¼ target  çš„é‚£ ä¸¤ä¸ª æ•´æ•°ï¼Œå¹¶è¿”å›å®ƒä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚\nä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆï¼Œå¹¶ä¸”ä½ ä¸èƒ½ä½¿ç”¨ä¸¤æ¬¡ç›¸åŒçš„å…ƒç´ ã€‚\nä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆã€‚\nç¤ºä¾‹ 1ï¼š\n\nè¾“å…¥ï¼šnums &#x3D; [2,7,11,15], target &#x3D; 9è¾“å‡ºï¼š[0,1]è§£é‡Šï¼šå› ä¸º nums[0] + nums[1] &#x3D;&#x3D; 9 ï¼Œè¿”å› [0, 1] ã€‚  \n\næ€è·¯æœ¬è´¨ä¸Šæ˜¯æŸ¥æ‰¾ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨ set è¿›è¡ŒæŸ¥æ‰¾ï¼Œä½†æ˜¯åˆéœ€è¦è¿”å›ä¸‹æ ‡ï¼Œæ‰€ä»¥ä½¿ç”¨ dict ä½œä¸ºå“ˆå¸Œè¡¨ã€‚ä½¿ç”¨ nums ä¸­çš„å€¼ä½œä¸º keyï¼Œä½¿ç”¨ä¸‹æ ‡ä½œä¸º valueã€‚å¯ä»¥å†™å‡ºä»¥ä¸‹ä»£ç ï¼š\nclass Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        d = dict()        for i in range(len(nums)):            d[nums[i]] = i        for i in range(len(nums)):            if target - nums[i] in d:                return [i, d[target - nums[i]]]\n\nä¹ä¸€çœ‹æ²¡é—®é¢˜ï¼Œä½†æ˜¯ï¼Œé¢˜ç›®è¦æ±‚ä¸èƒ½ä½¿ç”¨ä¸¤ä¸ªç›¸åŒçš„æ•°ï¼Œä¾‹å¦‚è¾“å…¥ nums&#x3D;[3, 2, 4]ï¼Œtarget&#x3D;6 æ—¶ï¼Œä¸Šè¿°ä»£ç ä¼šè¿”å› [0, 0]ã€‚é—®é¢˜åœ¨äºæˆ‘ä»¬å…ˆæŠŠæ‰€æœ‰çš„æ•°éƒ½å­˜å…¥å“ˆå¸Œè¡¨äº†ï¼Œè¿™æ ·æŸ¥è¯¢ 3 çš„æ—¶å€™å°±ä¼šç›´æ¥è¿”å›ï¼Œè€Œä¸ä¼šå†å»æŸ¥è¯¢ 2ã€‚äº‹å®ä¸Šä¸éœ€è¦å°†æ‰€æœ‰çš„æ•°éƒ½é¢„å…ˆå­˜åˆ°å“ˆå¸Œè¡¨ä¸­ï¼Œè¿™æ˜¯å› ä¸ºå³ä½¿éå†åˆ° 2ï¼Œæ­¤æ—¶ 4 è¿˜æ²¡æœ‰åŠ å…¥å“ˆå¸Œè¡¨ï¼Œä½†æ˜¯éå†åˆ° 4 æ—¶ï¼Œ2 å·²ç»åŠ å…¥äº†ï¼Œæ‰€ä»¥ä¸€å®šä¼šæ‰¾åˆ°ç­”æ¡ˆã€‚ï¼ˆé¢˜ç›®ä¸­ä¹Ÿæš—ç¤ºå¯ä»¥æŒ‰ç…§ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆï¼‰\nclass Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        d = dict()        for i in range(len(nums)):            if target - nums[i] in d:                return [i, d[target - nums[i]]]            d[nums[i]] = i\n\nå¯¹æ¯”ï¼š\n\nlist çš„å¤§å°æ˜¯å—é™åˆ¶çš„ï¼Œè€Œä¸”å¦‚æœå…ƒç´ å¾ˆå°‘ï¼Œè€Œå“ˆå¸Œå€¼å¤ªå¤§ä¼šé€ æˆå†…å­˜ç©ºé—´çš„æµªè´¹ã€‚\nset æ˜¯ä¸€ä¸ªé›†åˆï¼Œé‡Œé¢æ”¾çš„å…ƒç´ åªèƒ½æ˜¯ä¸€ä¸ªkeyï¼Œè€Œä¸¤æ•°ä¹‹å’Œè¿™é“é¢˜ç›®ï¼Œä¸ä»…è¦åˆ¤æ–­yæ˜¯å¦å­˜åœ¨è€Œä¸”è¿˜è¦è®°å½•yçš„ä¸‹æ ‡ä½ç½®ï¼Œå› ä¸ºè¦è¿”å›x å’Œ yçš„ä¸‹æ ‡ã€‚æ‰€ä»¥set ä¹Ÿä¸èƒ½ç”¨\n\n454. å››æ•°ç›¸åŠ  II\nlink\n\nç»™ä½ å››ä¸ªæ•´æ•°æ•°ç»„ nums1ã€nums2ã€nums3 å’Œ nums4 ï¼Œæ•°ç»„é•¿åº¦éƒ½æ˜¯ n ï¼Œè¯·ä½ è®¡ç®—æœ‰å¤šå°‘ä¸ªå…ƒç»„ (i, j, k, l) èƒ½æ»¡è¶³ï¼š\n0 &lt;&#x3D; i, j, k, l &lt; nnums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0\nç¤ºä¾‹ 1ï¼š\n\nè¾“å…¥ï¼šnums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]è¾“å‡ºï¼š2è§£é‡Šï¼šä¸¤ä¸ªå…ƒç»„å¦‚ä¸‹ï¼š (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0 (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0  \n\næ€è·¯æ•°ç»„ä¸¤ä¸¤é…å¯¹ç›¸åŠ ï¼Œåˆ†åˆ«è®¡ç®—å‡ºå¯èƒ½çš„å’Œï¼Œç„¶åå°±é€€åŒ–æˆä¸¤æ•°ä¹‹å’Œã€‚æ³¨æ„ä¸¤ä¸ªæ•°ç»„çš„å’Œå¯èƒ½åˆå¤šç§å¯èƒ½ï¼Œæ‰€ä»¥éœ€è¦ä½¿ç”¨ä½¿ç”¨ Counter ä½œä¸ºå“ˆå¸Œè¡¨ã€‚\nclass Solution:    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -&gt; int:        sum1 = Counter()        sum2 = Counter()        for i in nums1:            for j in nums2:                sum1[i + j] += 1                for i in nums3:            for j in nums4:                sum2[i + j] += 1        res = 0        for i in sum1:            if 0 - i in sum2:                res += sum2[0 - i]                return res","categories":["Leetcode"],"tags":["hash"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘å“ˆå¸Œè¡¨2","url":"/blog/Leetcode/hash3/","content":"383. èµé‡‘ä¿¡\nlink\n\nç»™ä½ ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼šransomNote å’Œ magazine ï¼Œåˆ¤æ–­ ransomNote èƒ½ä¸èƒ½ç”± magazine é‡Œé¢çš„å­—ç¬¦æ„æˆã€‚\nå¦‚æœå¯ä»¥ï¼Œè¿”å› true ï¼›å¦åˆ™è¿”å› false ã€‚\nmagazine ä¸­çš„æ¯ä¸ªå­—ç¬¦åªèƒ½åœ¨ ransomNote ä¸­ä½¿ç”¨ä¸€æ¬¡ã€‚\næ€è·¯ç»Ÿè®¡ magazine å’Œ ransomNote ä¸­çš„å­—ç¬¦æ•°é‡ï¼Œç„¶åå†åˆ¤æ–­å¤§å°ï¼ˆç›´æ¥æ¯”è¾ƒ Counterï¼‰ã€‚\nclass Solution:    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:        cm = Counter()        cr = Counter()        for i in magazine:            cm[i] += 1        for i in ransomNote:            cr[i] += 1                if cm &gt;= cr:            return True        else:            return False\n\n15. ä¸‰æ•°ä¹‹å’Œ\nlink\n\nç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œåˆ¤æ–­æ˜¯å¦å­˜åœ¨ä¸‰å…ƒç»„ [nums[i], nums[j], nums[k]] æ»¡è¶³ i !&#x3D; jã€i !&#x3D; k ä¸” j !&#x3D; k ï¼ŒåŒæ—¶è¿˜æ»¡è¶³ nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 ã€‚è¯·ä½ è¿”å›æ‰€æœ‰å’Œä¸º 0 ä¸”ä¸é‡å¤çš„ä¸‰å…ƒç»„ã€‚\næ³¨æ„ï¼šç­”æ¡ˆä¸­ä¸å¯ä»¥åŒ…å«é‡å¤çš„ä¸‰å…ƒç»„ã€‚\nç¤ºä¾‹ 1ï¼š\n\nè¾“å…¥ï¼šnums &#x3D; [-1,0,1,2,-1,-4]è¾“å‡ºï¼š[[-1,-1,2],[-1,0,1]]è§£é‡Šï¼šnums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 ã€‚nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 ã€‚nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 ã€‚ä¸åŒçš„ä¸‰å…ƒç»„æ˜¯ [-1,0,1] å’Œ [-1,-1,2] ã€‚æ³¨æ„ï¼Œè¾“å‡ºçš„é¡ºåºå’Œä¸‰å…ƒç»„çš„é¡ºåºå¹¶ä¸é‡è¦ã€‚\n\næ€è·¯æœ¬é¢˜æ— æ³•ä½¿ç”¨ä¸‰é‡å¾ªç¯ã€‚å› ä¸ºå¦‚æœæ‰€æœ‰çš„æ•°éƒ½ä¸º 0ï¼Œåˆ™éœ€è¦éœ€è¦å¤§é‡å»é‡ã€‚\nã€Œä¸é‡å¤ã€çš„æœ¬è´¨æ˜¯ä»€ä¹ˆï¼Ÿæˆ‘ä»¬ä¿æŒä¸‰é‡å¾ªç¯çš„å¤§æ¡†æ¶ä¸å˜ï¼Œåªéœ€è¦ä¿è¯ï¼š\n\nç¬¬äºŒé‡å¾ªç¯æšä¸¾åˆ°çš„å…ƒç´ ä¸å°äºå½“å‰ç¬¬ä¸€é‡å¾ªç¯æšä¸¾åˆ°çš„å…ƒç´ ï¼› \nç¬¬ä¸‰é‡å¾ªç¯æšä¸¾åˆ°çš„å…ƒç´ ä¸å°äºå½“å‰ç¬¬äºŒé‡å¾ªç¯æšä¸¾åˆ°çš„å…ƒç´ ã€‚\n\nä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬æšä¸¾çš„ä¸‰å…ƒç»„ (a,b,c) æ»¡è¶³ aâ‰¤bâ‰¤cï¼Œä¿è¯äº†åªæœ‰ (a,b,c) è¿™ä¸ªé¡ºåºä¼šè¢«æšä¸¾åˆ°ï¼Œè€Œ (b,a,c)ã€(c,b,a) ç­‰ç­‰è¿™äº›ä¸ä¼šï¼Œè¿™æ ·å°±å‡å°‘äº†é‡å¤ã€‚åŒæ—¶ï¼Œå¯¹äºæ¯ä¸€é‡å¾ªç¯è€Œè¨€ï¼Œç›¸é‚»ä¸¤æ¬¡æšä¸¾çš„å…ƒç´ ä¸èƒ½ç›¸åŒï¼Œå¦åˆ™ä¹Ÿä¼šé€ æˆé‡å¤ã€‚\nä½†æ˜¯ä¸Šè¿°æ–¹æ³•ä»ä¸ºä¸‰é‡å¾ªç¯ã€‚å¦‚æœæˆ‘ä»¬å›ºå®šäº†å‰ä¸¤é‡å¾ªç¯æšä¸¾åˆ°çš„å…ƒç´  a å’Œ bï¼Œé‚£ä¹ˆåªæœ‰å”¯ä¸€çš„ c æ»¡è¶³ a+b+c&#x3D;0ã€‚å½“ç¬¬äºŒé‡å¾ªç¯å¾€åæšä¸¾ä¸€ä¸ªå…ƒç´  bâ€™ æ—¶ï¼Œç”±äº bâ€™&gt;bï¼Œé‚£ä¹ˆæ»¡è¶³ a+bâ€™+câ€™&#x3D;0 çš„ câ€™ ä¸€å®šæœ‰ câ€™&lt;cï¼Œå³åœ¨æ•°ç»„ä¸­ä¸€å®šå‡ºç°åœ¨ c çš„å·¦ä¾§ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å¯ä»¥ä»å°åˆ°å¤§æšä¸¾ bï¼ŒåŒæ—¶ä»å¤§åˆ°å°æšä¸¾ cï¼Œå³ç¬¬äºŒé‡å¾ªç¯å’Œç¬¬ä¸‰é‡å¾ªç¯å®é™…ä¸Šæ˜¯å¹¶åˆ—çš„å…³ç³»ã€‚æ•…æšä¸¾ b ä¸ºå·¦æŒ‡é’ˆï¼Œæšä¸¾ c ä¸ºå³æŒ‡é’ˆã€‚\nfrom typing import Listclass Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        nums.sort()        res = []        for i in range(len(nums)):            if i &gt; 0 and nums[i] == nums[i - 1]:  # è·³è¿‡é‡å¤a                continue            left, right = i + 1, len(nums) - 1            while left &lt; right:                total = nums[i] + nums[left] + nums[right]                if total == 0:                    res.append([nums[i], nums[left], nums[right]])                    left += 1                    right -= 1                    # è·³è¿‡é‡å¤b                    while left &lt; right and nums[left] == nums[left - 1]:                        left += 1                    # è·³è¿‡é‡å¤c                    while left &lt; right and nums[right] == nums[right + 1]:                        right -= 1                elif total &lt; 0:                    left += 1                else:                    right -= 1        return res\n\næ€è€ƒä¸¤æ•°ä¹‹å’Œ èƒ½ä¸èƒ½ç”¨åŒæŒ‡é’ˆæ³•å‘¢ï¼Ÿ\n\nä¸¤æ•°ä¹‹å’Œä¸èƒ½ä½¿ç”¨åŒæŒ‡é’ˆæ³•ï¼Œå› ä¸º1.ä¸¤æ•°ä¹‹å’Œ (opens new window)è¦æ±‚è¿”å›çš„æ˜¯ç´¢å¼•ä¸‹æ ‡ï¼Œ è€ŒåŒæŒ‡é’ˆæ³•ä¸€å®šè¦æ’åºï¼Œä¸€æ—¦æ’åºä¹‹ååŸæ•°ç»„çš„ç´¢å¼•å°±è¢«æ”¹å˜äº†ã€‚\nå¦‚æœ1.ä¸¤æ•°ä¹‹å’Œ (opens new window)è¦æ±‚è¿”å›çš„æ˜¯æ•°å€¼çš„è¯ï¼Œå°±å¯ä»¥ä½¿ç”¨åŒæŒ‡é’ˆæ³•äº†\n18. å››æ•°ä¹‹å’Œ\nlink\n\nç»™ä½ ä¸€ä¸ªç”± n ä¸ªæ•´æ•°ç»„æˆçš„æ•°ç»„ nums ï¼Œå’Œä¸€ä¸ªç›®æ ‡å€¼ target ã€‚è¯·ä½ æ‰¾å‡ºå¹¶è¿”å›æ»¡è¶³ä¸‹è¿°å…¨éƒ¨æ¡ä»¶ä¸”ä¸é‡å¤çš„å››å…ƒç»„ [nums[a], nums[b], nums[c], nums[d]] ï¼ˆè‹¥ä¸¤ä¸ªå››å…ƒç»„å…ƒç´ ä¸€ä¸€å¯¹åº”ï¼Œåˆ™è®¤ä¸ºä¸¤ä¸ªå››å…ƒç»„é‡å¤ï¼‰ï¼š\n0 &lt;&#x3D; a, b, c, d &lt; naã€bã€c å’Œ d äº’ä¸ç›¸åŒnums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; targetä½ å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ç­”æ¡ˆ ã€‚\næ€è·¯ç±»ä¼¼äºä¸‰æ•°ä¹‹å’Œï¼ŒåŒæ ·æ˜¯ä½¿ç”¨åŒæŒ‡é’ˆæ³•å‡å°‘ä¸€å±‚å¾ªç¯ã€‚\nclass Solution:    def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]:        nums.sort()        res = []        for i in range(len(nums)):            if i &gt; 0 and nums[i] == nums[i-1]:                continue            for j in range(i + 1, len(nums)):                if j &gt; i + 1 and nums[j] == nums[j - 1]:                    continue                                left, right = j + 1, len(nums) - 1                while left &lt; right:                    total = nums[i] + nums[j] + nums[left] + nums[right]                    if total == target:                        res.append([nums[i], nums[j], nums[left], nums[right]])                        left += 1                        right -= 1                        while left &lt; right and nums[left] == nums[left - 1]:                            left += 1                                                while left &lt; right and nums[right] == nums[right + 1]:                            right -= 1                                        elif total &lt; target:                        left += 1                    else:                        right -= 1        return res","categories":["Leetcode"],"tags":["hash"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘å•è°ƒæ ˆ","url":"/blog/Leetcode/monotonic-stack/","content":"739. æ¯æ—¥æ¸©åº¦\nlink\n\nè¯·æ ¹æ®æ¯æ—¥ æ°”æ¸© åˆ—è¡¨ï¼Œé‡æ–°ç”Ÿæˆä¸€ä¸ªåˆ—è¡¨ã€‚å¯¹åº”ä½ç½®çš„è¾“å‡ºä¸ºï¼šè¦æƒ³è§‚æµ‹åˆ°æ›´é«˜çš„æ°”æ¸©ï¼Œè‡³å°‘éœ€è¦ç­‰å¾…çš„å¤©æ•°ã€‚å¦‚æœæ°”æ¸©åœ¨è¿™ä¹‹åéƒ½ä¸ä¼šå‡é«˜ï¼Œè¯·åœ¨è¯¥ä½ç½®ç”¨ 0 æ¥ä»£æ›¿ã€‚\nä¾‹å¦‚ï¼Œç»™å®šä¸€ä¸ªåˆ—è¡¨ temperatures &#x3D; [73, 74, 75, 71, 69, 72, 76, 73]ï¼Œä½ çš„è¾“å‡ºåº”è¯¥æ˜¯ [1, 1, 4, 2, 1, 1, 0, 0]ã€‚\næ€è·¯ä½¿ç”¨å•è°ƒæ ˆçš„æ—¶æœºï¼šé€šå¸¸æ˜¯ä¸€ç»´æ•°ç»„ï¼Œè¦å¯»æ‰¾ä»»ä¸€ä¸ªå…ƒç´ çš„å³è¾¹æˆ–è€…å·¦è¾¹ç¬¬ä¸€ä¸ªæ¯”è‡ªå·±å¤§æˆ–è€…å°çš„å…ƒç´ çš„ä½ç½®ï¼Œæ­¤æ—¶æˆ‘ä»¬å°±è¦æƒ³åˆ°å¯ä»¥ç”¨å•è°ƒæ ˆäº†ã€‚æ—¶é—´å¤æ‚åº¦ä¸º O(n)ã€‚\n\nå•è°ƒæ ˆçš„æœ¬è´¨æ˜¯ç©ºé—´æ¢æ—¶é—´ï¼Œå› ä¸ºåœ¨éå†çš„è¿‡ç¨‹ä¸­éœ€è¦ç”¨ä¸€ä¸ªæ ˆæ¥è®°å½•å³è¾¹ç¬¬ä¸€ä¸ªæ¯”å½“å‰å…ƒç´ é«˜çš„å…ƒç´ ï¼Œä¼˜ç‚¹æ˜¯æ•´ä¸ªæ•°ç»„åªéœ€è¦éå†ä¸€æ¬¡ã€‚\næ›´ç›´ç™½æ¥è¯´ï¼Œå°±æ˜¯ç”¨ä¸€ä¸ªæ ˆæ¥è®°å½•æˆ‘ä»¬éå†è¿‡çš„å…ƒç´ ï¼Œå› ä¸ºæˆ‘ä»¬éå†æ•°ç»„çš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¸çŸ¥é“ä¹‹å‰éƒ½éå†äº†å“ªäº›å…ƒç´ ï¼Œä»¥è‡³äºéå†ä¸€ä¸ªå…ƒç´ æ‰¾ä¸åˆ°æ˜¯ä¸æ˜¯ä¹‹å‰éå†è¿‡ä¸€ä¸ªæ›´å°çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ç”¨ä¸€ä¸ªå®¹å™¨ï¼ˆè¿™é‡Œç”¨å•è°ƒæ ˆï¼‰æ¥è®°å½•æˆ‘ä»¬éå†è¿‡çš„å…ƒç´ ã€‚\n\næ ¸å¿ƒç‚¹ï¼š\n\nå•è°ƒæ ˆé‡Œå­˜æ”¾çš„å…ƒç´ æ˜¯ä»€ä¹ˆï¼Ÿå•è°ƒæ ˆé‡Œåªéœ€è¦å­˜æ”¾å…ƒç´ çš„ä¸‹æ ‡ i å°±å¯ä»¥äº†ï¼Œå¦‚æœéœ€è¦ä½¿ç”¨å¯¹åº”çš„å…ƒç´ ï¼Œç›´æ¥ T[i] å°±å¯ä»¥è·å–ã€‚\nå•è°ƒæ ˆé‡Œå…ƒç´ æ˜¯é€’å¢å‘¢ï¼Ÿ è¿˜æ˜¯é€’å‡å‘¢ï¼Ÿé¡ºåºçš„æè¿°ä¸ºä»æ ˆå¤´åˆ°æ ˆåº•çš„é¡ºåºï¼Œè¿™é‡Œè¦ä½¿ç”¨é€’å¢å¾ªåºï¼Œå› ä¸ºåªæœ‰é€’å¢çš„æ—¶å€™ï¼Œæ ˆé‡Œè¦åŠ å…¥ä¸€ä¸ªå…ƒç´  i çš„æ—¶å€™ï¼Œæ‰çŸ¥é“æ ˆé¡¶å…ƒç´ åœ¨æ•°ç»„ä¸­å³é¢ç¬¬ä¸€ä¸ªæ¯”æ ˆé¡¶å…ƒç´ å¤§çš„å…ƒç´ æ˜¯ iã€‚\n\nå•è°ƒæ ˆæ»¡è¶³ï¼š\n\næ ˆä¸­å­˜çš„æ˜¯â€œè¿˜æ²¡æ‰¾åˆ°æ›´é«˜æ¸©åº¦çš„é‚£äº›å¤©â€ï¼Œå³ï¼šè¿™äº›å¤©è¿˜åœ¨ç­‰æ›´æš–çš„ä¸€å¤©ã€‚å½“å‘ç°æŸå¤©æ¯”ä»–ä»¬â€œæš–â€ï¼Œå°±å°†ä»–ä»¬ç§»å‡ºæ ˆï¼Œå¹¶æ›´æ–°å®ƒä»¬çš„ç­‰å¾…æ—¶é—´ã€‚\næ ˆä¿æŒçš„æ˜¯â€œæ¸©åº¦å•è°ƒé€’å‡â€ï¼Œå› ä¸ºåªæœ‰æ¸©åº¦é€’å‡æ‰ä¼šå‡ºç°â€œç­‰å¾…æ›´æš–çš„å¤©â€ã€‚\n\nclass Solution:    def dailyTemperatures(self, temperatures: List[int]) -&gt; List[int]:        stack = []        res = [0] * len(temperatures)        for i in range(0, len(temperatures)):            while len(stack) &gt; 0:                if temperatures[stack[-1]] &lt; temperatures[i]:                    res[stack[-1]] = i - stack[-1]                    stack.pop()                else:                    break                        stack.append(i)        return res\nä»¥ä¸Šä»£ç ä¸ºç²¾ç®€ç‰ˆï¼Œå³å¦‚æœæ ˆä¸ä¸ºç©ºï¼Œå°±ä¸€ç›´æ¯”è¾ƒï¼š\n\nå¦‚æœå½“å‰å…ƒç´ æ¯”æ ˆåº•å…ƒç´ å¤§ï¼Œè¯´æ˜æ‰¾åˆ°äº†ç¬¬ä¸€ä¸ªå¤§äºå½“å‰å…ƒç´ çš„å…ƒç´ ï¼Œå°±å¯ä»¥æ›´æ–°ç»“æœã€‚ä¸ºäº†ä¿è¯æ ˆçš„é€’å¢æ€§ï¼Œå°±è¦æŠŠå½“å‰å…ƒç´ ç§»å‡ºï¼Œç„¶åå†å¾ªç¯åˆ¤æ–­\nå¦‚æœå½“å‰å…ƒç´ æ¯”æ ˆåº•å…ƒç´ å°ï¼Œè¯´æ˜å½“å‰å…ƒç´ ä¸æ»¡è¶³è¦æ±‚ï¼Œè·³å‡ºå¾ªç¯\næœ€ååœ¨ while å¾ªç¯å¤–å°†å½“å‰å…ƒç´ æ·»åŠ åˆ°æ ˆä¸­ï¼ˆæ— è®ºå¦‚ä½•éƒ½éœ€è¦æ·»åŠ ï¼‰\n\n496.ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  I\nlink\n\nç»™ä½ ä¸¤ä¸ª æ²¡æœ‰é‡å¤å…ƒç´  çš„æ•°ç»„ nums1 å’Œ nums2 ï¼Œå…¶ä¸­nums1 æ˜¯ nums2 çš„å­é›†ã€‚è¯·ä½ æ‰¾å‡º nums1 ä¸­æ¯ä¸ªå…ƒç´ åœ¨ nums2 ä¸­çš„ä¸‹ä¸€ä¸ªæ¯”å…¶å¤§çš„å€¼ã€‚nums1 ä¸­æ•°å­— x çš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ æ˜¯æŒ‡ x åœ¨ nums2 ä¸­å¯¹åº”ä½ç½®çš„å³è¾¹çš„ç¬¬ä¸€ä¸ªæ¯” x å¤§çš„å…ƒç´ ã€‚å¦‚æœä¸å­˜åœ¨ï¼Œå¯¹åº”ä½ç½®è¾“å‡º -1 ã€‚\næ€è·¯ç±»ä¼¼äºä¸Šä¸€é¢˜ï¼Œé¦–å…ˆé’ˆå¯¹ nums2 ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ ï¼Œåœ¨å…¶å³è¾¹æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºå½“å‰å…ƒç´ çš„å…ƒç´  å­˜æ”¾åœ¨ res ä¸­ï¼Œå¦‚æœæ‰¾ä¸åˆ°å°±å­˜ -1ï¼ˆé»˜è®¤å€¼ä¸º -1ï¼‰ã€‚ç„¶åå¯¹äº nums1 ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ ï¼Œå…ˆåœ¨ nums2 ä¸­æ‰¾åˆ°ä¸‹æ ‡ï¼Œç„¶åå°† res ä¸­å¯¹åº”ä¸‹æ ‡çš„å€¼å­˜åˆ°æ–°çš„ res ä¸­ã€‚\nclass Solution:    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:        res = [-1] * len(nums2)        stack = []        for i in range(len(nums2)):            while len(stack) &gt; 0:                if nums2[stack[-1]] &lt; nums2[i]:                    res[stack[-1]] = nums2[i]                    stack.pop()                else:                    break                            stack.append(i)                new_res = []        # ä¹Ÿå¯ä»¥ä½¿ç”¨å“ˆå¸Œè¡¨æ¥å­˜å‚¨        for i in nums1:            cur = res[nums2.index(i)]            new_res.append(cur)        return new_res\n\n503. ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  II\nlink\n\nç»™å®šä¸€ä¸ªå¾ªç¯æ•°ç»„ï¼ˆæœ€åä¸€ä¸ªå…ƒç´ çš„ä¸‹ä¸€ä¸ªå…ƒç´ æ˜¯æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼‰ï¼Œè¾“å‡ºæ¯ä¸ªå…ƒç´ çš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ ã€‚æ•°å­— x çš„ä¸‹ä¸€ä¸ªæ›´å¤§çš„å…ƒç´ æ˜¯æŒ‰æ•°ç»„éå†é¡ºåºï¼Œè¿™ä¸ªæ•°å­—ä¹‹åçš„ç¬¬ä¸€ä¸ªæ¯”å®ƒæ›´å¤§çš„æ•°ï¼Œè¿™æ„å‘³ç€ä½ åº”è¯¥å¾ªç¯åœ°æœç´¢å®ƒçš„ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ•°ã€‚å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™è¾“å‡º -1ã€‚\næ€è·¯è¦å¤„ç†å¾ªç¯æ•°ç»„ï¼Œå¯ä»¥éå†å½“å‰æ•°ç»„ä¸¤æ¬¡æ¥æ¨¡æ‹Ÿï¼ˆç›¸å½“äºæ˜¯æŠŠä¸¤ä¸ªç›¸åŒçš„æ•°ç»„æ‹¼åœ¨ä¸€èµ·ï¼‰ã€‚æ¯æ¬¡å¤„ç†ä¸‹æ ‡æ˜¯ï¼Œéƒ½éœ€è¦å–ä½™æ“ä½œã€‚\nclass Solution:    def nextGreaterElements(self, nums: List[int]) -&gt; List[int]:        stack = []        n = len(nums)        res = [-1] * n        for i in range(n * 2):            while len(stack) &gt; 0:                cur = stack[-1]                if nums[cur % n] &lt; nums[i % n]:                    res[cur % n] = nums[i % n]                    stack.pop()                else:                    break                        stack.append(i)                return res\n\n42. æ¥é›¨æ°´\nlink\n\nç»™å®š n ä¸ªéè´Ÿæ•´æ•°è¡¨ç¤ºæ¯ä¸ªå®½åº¦ä¸º 1 çš„æŸ±å­çš„é«˜åº¦å›¾ï¼Œè®¡ç®—æŒ‰æ­¤æ’åˆ—çš„æŸ±å­ï¼Œä¸‹é›¨ä¹‹åèƒ½æ¥å¤šå°‘é›¨æ°´ã€‚\nç¤ºä¾‹ï¼š\n\n\nè¾“å…¥ï¼šheight &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]è¾“å‡ºï¼š6è§£é‡Šï¼šä¸Šé¢æ˜¯ç”±æ•°ç»„ [0,1,0,2,1,0,1,3,2,1,2,1] è¡¨ç¤ºçš„é«˜åº¦å›¾ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥æ¥ 6 ä¸ªå•ä½çš„é›¨æ°´ï¼ˆè“è‰²éƒ¨åˆ†è¡¨ç¤ºé›¨æ°´ï¼‰ã€‚   \n\næ€è·¯ 1æ ¸å¿ƒç‚¹ï¼šæ¯ä¸€æ ¹æŸ±å­ä¸Šæ–¹èƒ½æ¥å¤šå°‘æ°´ï¼Œå–å†³äºï¼šå®ƒå·¦è¾¹æœ€é«˜çš„æŸ±å­ å’Œ å³è¾¹æœ€é«˜çš„æŸ±å­ çš„è¾ƒå°å€¼ï¼Œå‡å»è‡ªå·±çš„é«˜åº¦ï¼Œå³ water[i] &#x3D; min(max_left[i], max_right[i]) - height[i]\næ‰€ä»¥å…ˆæ­£å‘å’Œåå‘éƒ½éå†ä¸€éï¼Œæ‰¾åˆ°å½“å‰æŸ±å­å·¦å³ä¸¤è¾¹çš„æœ€å¤§å€¼ï¼Œç„¶åé€šè¿‡ä¸Šè¿°å…¬å¼è®¡ç®—å³å¯ã€‚\nclass Solution:    def trap(self, height: List[int]) -&gt; int:        n = len(height)        if n == 0:            return 0                max_left = [0] * n        max_right = [0] * n        # ä»å·¦å‘å³é¢„å¤„ç†å·¦ä¾§æœ€å¤§é«˜åº¦        max_left[0] = height[0]        for i in range(1, n):            max_left[i] = max(max_left[i - 1], height[i])        # ä»å³å‘å·¦é¢„å¤„ç†å³ä¾§æœ€å¤§é«˜åº¦        max_right[n - 1] = height[n - 1]        for i in range(n - 2, -1, -1):            max_right[i] = max(max_right[i + 1], height[i])        # è®¡ç®—æ¯ä¸ªæŸ±å­ä¸Šæ–¹å¯æ¥é›¨æ°´é‡        total_water = 0        for i in range(n):            water = min(max_left[i], max_right[i]) - height[i]            if water &gt; 0:                total_water += water        return total_water\n\nè¿™ç§æ–¹æ³•æ˜¯æŒ‰åˆ—æ¥è¿›è¡Œè®¡ç®—çš„ã€‚\n\næ€è·¯ 2ä½¿ç”¨ä¸€ä¸ªå•è°ƒé€’å‡æ ˆï¼ˆå­˜çš„æ˜¯ä¸‹æ ‡ï¼‰æ¥æ‰¾å‡ºï¼š\n\nå½“å‰æŸ±å­æ˜¯å¦å¯ä»¥æ„æˆä¸€ä¸ªâ€œæ¥æ°´å‡¹æ§½â€\nå¦‚æœå¯ä»¥ï¼Œæˆ‘ä»¬å°±è®¡ç®—å‡¹æ§½ä¸­é—´é‚£ä¸€æ®µçš„æ¥æ°´é‡\n\næ¯æ¬¡é‡åˆ°æ›´é«˜çš„æŸ±å­ï¼Œå°±å›å¤´æ‰¾å·¦è¾¹æœ‰æ²¡æœ‰æŸ±å­èƒ½å½¢æˆä¸€å¯¹â€œå¢™â€ã€‚\nå‡è®¾å½“å‰éå†åˆ°ä¸‹æ ‡ iï¼Œé«˜åº¦ä¸º height[i]ï¼š\n\nå¦‚æœ æ ˆä¸ºç©º æˆ– å½“å‰é«˜åº¦ &lt;&#x3D; æ ˆé¡¶é«˜åº¦ï¼š\nå…¥æ ˆï¼ˆè¡¨ç¤ºè¿˜æ²¡å½¢æˆæ¥æ°´å‡¹æ§½ï¼‰ã€‚\n\n\nå¦‚æœ å½“å‰é«˜åº¦ &gt; æ ˆé¡¶é«˜åº¦ï¼š\nè¯´æ˜å¯èƒ½å½¢æˆâ€œæ¥æ°´å‡¹æ§½â€ï¼Œå¼€å§‹å‡ºæ ˆå¹¶è®¡ç®—ã€‚\n\n\næ¯æ¬¡å‡ºæ ˆåï¼š\næ ˆé¡¶æ˜¯ å‡¹æ§½çš„å·¦å¢™\nå½“å‰æ˜¯ å³å¢™\nè¢«å‡ºæ ˆçš„é‚£ä¸ªæŸ±å­æ˜¯ åº•éƒ¨\n\n\næ°´çš„è®¡ç®—æ–¹å¼ï¼š\né«˜åº¦ &#x3D; min(å·¦å¢™é«˜åº¦, å³å¢™é«˜åº¦) - åº•éƒ¨é«˜åº¦\nå®½åº¦ &#x3D; å³å¢™ç´¢å¼• - å·¦å¢™ç´¢å¼• - 1\næ°´é‡ &#x3D; é«˜åº¦ Ã— å®½åº¦\n\n\n\nclass Solution:    def trap(self, height: List[int]) -&gt; int:        stack = []        water = 0        for i in range(len(height)):                        while stack:                if height[stack[-1]] &lt; height[i]:                    last = stack.pop()                    # æ³¨æ„åº•éƒ¨å‡ºæ ˆåï¼Œå¯èƒ½æ²¡æœ‰å·¦å¢™ï¼Œåˆ™éœ€è¦è·³å‡ºå½“å‰å¾ªç¯                    if not stack:                        break                                        w = i - stack[-1] - 1                    # last æ˜¯åº•éƒ¨ï¼Œi æ˜¯å³å¢™ï¼Œstack[-1] æ˜¯å·¦å¢™                    h = min(height[stack[-1]], height[i]) - height[last]                    water += h * w                else:                    break            stack.append(i)                return water\n\nè¿™ç§æ–¹æ³•æ˜¯æŒ‰è¡Œæ¥è®¡ç®—çš„ï¼š\n\n84.æŸ±çŠ¶å›¾ä¸­æœ€å¤§çš„çŸ©å½¢\nlink\n\nç»™å®š n ä¸ªéè´Ÿæ•´æ•°ï¼Œç”¨æ¥è¡¨ç¤ºæŸ±çŠ¶å›¾ä¸­å„ä¸ªæŸ±å­çš„é«˜åº¦ã€‚æ¯ä¸ªæŸ±å­å½¼æ­¤ç›¸é‚»ï¼Œä¸”å®½åº¦ä¸º 1 ã€‚æ±‚åœ¨è¯¥æŸ±çŠ¶å›¾ä¸­ï¼Œèƒ½å¤Ÿå‹¾å‹’å‡ºæ¥çš„çŸ©å½¢çš„æœ€å¤§é¢ç§¯ã€‚\nç¤ºä¾‹ 1ï¼š\n\n\nè¾“å…¥ï¼šheights &#x3D; [2,1,5,6,2,3]è¾“å‡ºï¼š10è§£é‡Šï¼šæœ€å¤§çš„çŸ©å½¢ä¸ºå›¾ä¸­çº¢è‰²åŒºåŸŸï¼Œé¢ç§¯ä¸º 10  \n\nç¤ºä¾‹ 2ï¼š\n\n\nè¾“å…¥ï¼š heights &#x3D; [2,4]è¾“å‡ºï¼š 4  \n\næ€è·¯ 1ç›®æ ‡ï¼š æ‰¾å‡ºæ¯ä¸ªæŸ±å­å‘å·¦å’Œå‘å³èƒ½å»¶ä¼¸çš„æœ€å¤§èŒƒå›´ï¼Œå³ä¸ºå½“å‰æŸ±å­èƒ½æ„æˆçš„æœ€å¤§çŸ©å½¢ã€‚ä½¿ç”¨å•è°ƒæ ˆï¼Œåªä¸è¿‡ä»æ ˆå¤´åˆ°æ ˆå°¾æ˜¯é€’å¢çš„ã€‚\n\nå½“å‰æŸ±å­é«˜åº¦ æ¯”æ ˆé¡¶é«˜ â†’ ç»§ç»­å…¥æ ˆï¼ˆæ ˆä¿æŒé€’å¢ï¼‰\nå½“å‰æŸ±å­é«˜åº¦ æ¯”æ ˆé¡¶ä½ â†’ å‡ºæ ˆï¼Œå¹¶è®¡ç®—ä»¥è¯¥æŸ±å­ï¼ˆå‡ºæ ˆçš„é‚£ä¸ªæŸ±å­ï¼‰ä¸ºé«˜çš„æœ€å¤§çŸ©å½¢\nçŸ©å½¢çš„é«˜ï¼šå½“å‰å‡ºæ ˆçš„æŸ±å­\nçŸ©å½¢å®½çš„èµ·ç‚¹ï¼šå‡ºæ ˆä¹‹åçš„æ ˆé¡¶\nçŸ©å½¢å®½çš„ç»ˆç‚¹ï¼šå½“å‰ i\næ³¨æ„ï¼Œå¦‚æœå‡ºæ ˆçš„æŸ±å­ä¸‹æ ‡å’Œå½“å‰ i ä¸ç›¸é‚»ï¼Œåˆ™è¯´æ˜ä¹‹å‰ä¸€å®šæœ‰ä¸€ä¸ªï¼ˆæˆ–å¤šä¸ªï¼‰æ›´é«˜çš„æŸ±å­å‡ºæ ˆè¿‡ï¼Œæ­¤æ—¶å°±æ˜¯è·¨æŸ±å­æ¡†é€‰çŸ©å½¢çš„æƒ…å†µäº†ã€‚\n\n\n\nclass Solution:    def largestRectangleArea(self, heights: List[int]) -&gt; int:        size = 0        heights = [0] + heights + [0]        stack = []        for i in range(len(heights)):            while stack:                if heights[stack[-1]] &gt; heights[i]:                    last = stack.pop()                    w = i - stack[-1] - 1                    h = heights[last]                    cur = h * w                    size = max(cur, size)                else:                    break                        stack.append(i)        return size\n\næ³¨æ„ï¼Œè¿™é‡Œéœ€è¦åœ¨ heights çš„å·¦å³å„æ·»åŠ ä¸€ä¸ªå“¨å…µ 0ï¼Œç”¨äºå¤„ç†è¾¹ç•Œçš„æƒ…å†µã€‚å¯¹æ¯” æ¥é›¨æ°´ å’Œæœ¬é¢˜ï¼š\n\n\næŸ±çŠ¶å›¾æœ€å¤§çŸ©å½¢ éœ€è¦å“¨å…µï¼š\n\næœ¬è´¨ï¼šæ¯æ ¹æŸ±å­éƒ½å¯èƒ½æ˜¯æœ€å¤§çŸ©å½¢çš„â€œæœ€çŸ®å¢™â€\næ‰€ä»¥æ¯æ ¹æŸ±å­éƒ½è¦å‚ä¸å¤„ç†\nä½†å•è°ƒæ ˆä¸ä¼šä¸»åŠ¨å¤„ç†æ ˆä¸­å‰©ä¸‹çš„å…ƒç´ ï¼Œå¿…é¡»æ‰‹åŠ¨â€œæ¸…æ ˆâ€\nåŠ ä¸ªå°¾éƒ¨å“¨å…µ 0 ä¼šè‡ªåŠ¨è§¦å‘æ¸…æ ˆé€»è¾‘ï¼Œä¸éœ€è¦é¢å¤–ä»£ç \n\n\næ¥é›¨æ°´ ä¸éœ€è¦å“¨å…µï¼š\n\næœ¬è´¨ï¼šåªåœ¨ å½“å‰æŸ±å­æ¯”æ ˆé¡¶é«˜ æ—¶æ‰å¤„ç†æ¥æ°´é€»è¾‘\nä¸æ»¡è¶³æ¡ä»¶ï¼ˆå³å¢™ä¸é«˜ï¼‰å°±è·³è¿‡\nåˆ°æœ€åä¸€æ ¹æŸ±å­åï¼Œä¹Ÿä¸éœ€è¦å¼ºåˆ¶å¤„ç†æ ˆé‡Œå‰©ä¸‹çš„æŸ±å­\nå› ä¸ºæ²¡æœ‰å³å¢™å°±ä¸ä¼šè£…æ°´\n\n\n\næ€è·¯ 2åŒæ ·ï¼Œæœ¬é¢˜ä¹Ÿå¯ä»¥ç±»ä¼¼äº æ¥é›¨æ°´ï¼Œå¯¹æ¯ä¸ªæŸ±å­ï¼Œæ‰¾åˆ°å·¦å³ä¸¤è¾¹ç¬¬ä¸€ä¸ªå°äºå½“å‰æŸ±å­çš„æŸ±å­ã€‚ç„¶åæ„å»ºçš„çŸ©å½¢çš„é«˜ä¸ºå½“å‰æŸ±å­ï¼Œï¼Œå®½åº¦æ˜¯èƒ½å»¶ä¼¸åˆ°å·¦å³ä¸¤è¾¹ç¬¬ä¸€ä¸ªæ¯”å®ƒå°çš„æŸ±å­ä¹‹é—´çš„èŒƒå›´ã€‚\nclass Solution:    def largestRectangleArea(self, heights: List[int]) -&gt; int:        n = len(heights)        left = [-1] * n      # å·¦è¾¹ç¬¬ä¸€ä¸ªæ¯”å®ƒå°çš„ä½ç½®        right = [n] * n      # å³è¾¹ç¬¬ä¸€ä¸ªæ¯”å®ƒå°çš„ä½ç½®        stack = []        # è®¡ç®— left[]        for i in range(n):            while stack and heights[stack[-1]] &gt;= heights[i]:                stack.pop()            left[i] = stack[-1] if stack else -1            stack.append(i)        stack.clear()        # è®¡ç®— right[]        for i in reversed(range(n)):            while stack and heights[stack[-1]] &gt;= heights[i]:                stack.pop()            right[i] = stack[-1] if stack else n            stack.append(i)        # æšä¸¾æ¯ä¸ªæŸ±å­ä½œä¸ºçŸ©å½¢çš„â€œæœ€çŸ®è¾¹â€        max_area = 0        for i in range(n):            width = right[i] - left[i] - 1            area = heights[i] * width            max_area = max(max_area, area)        return max_area\n","categories":["Leetcode"],"tags":["stack"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘é“¾è¡¨2","url":"/blog/Leetcode/list2/","content":"206.åè½¬é“¾è¡¨\né¢˜ç›®é“¾æ¥ link\n\nç»™ä½ å•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ head ï¼Œè¯·ä½ åè½¬é“¾è¡¨ï¼Œå¹¶è¿”å›åè½¬åçš„é“¾è¡¨ã€‚\nåŒæŒ‡é’ˆï¼ˆè¿­ä»£ï¼‰åªéœ€è¦æ”¹å˜é“¾è¡¨çš„nextæŒ‡é’ˆçš„æŒ‡å‘ï¼Œç›´æ¥å°†é“¾è¡¨åè½¬ï¼Œè€Œä¸ç”¨é‡æ–°å®šä¹‰ä¸€ä¸ªæ–°çš„é“¾è¡¨ã€‚\nclass Solution:    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        if head == None or head.next == None:            return head        pre = head        cur = head.next        head.next = None        while cur != None:            temp = cur.next            cur.next = pre            pre = cur            cur = temp                return pre\nä»¥ä¸Šä»£ç å•ç‹¬è€ƒè™‘äº†ç‰¹æ®Šæƒ…å†µï¼Œå®é™…ä¸Šå¯ä»¥å†™åœ¨ä¸€èµ·ï¼Œç›´æ¥å°† pre è®¾ç½®ä¸º Noneï¼Œcur è®¾ç½®ä¸º head å³å¯ã€‚\né€’å½’æ³•æœ¬è´¨ä¸Šæ˜¯å¤šæ¬¡å®Œæˆä»¥ä¸‹ä»»åŠ¡ï¼šå°†å½“å‰ cur.next èµ‹å€¼ä¸º preï¼Œç„¶åç§»åŠ¨ cur å’Œ preã€‚å¯ä»¥ä½¿ç”¨é€’å½’çš„æ–¹æ³•ï¼Œå†™ä¸€ä¸ªå‡½æ•°æ¥å¤šæ¬¡å®Œæˆä¸Šè¿°è¿‡ç¨‹ã€‚\nclass Solution:    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        pre = None        cur = head        return self.reserve(pre, cur)    def reserve(self, pre, cur):        if cur == None:            return pre                temp = cur.next        cur.next = pre        pre = cur        cur = temp        return self.reserve(pre, cur)\n\n24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹\né¢˜ç›®é“¾æ¥ link\n\nç»™ä½ ä¸€ä¸ªé“¾è¡¨ï¼Œä¸¤ä¸¤äº¤æ¢å…¶ä¸­ç›¸é‚»çš„èŠ‚ç‚¹ï¼Œå¹¶è¿”å›äº¤æ¢åé“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚ä½ å¿…é¡»åœ¨ä¸ä¿®æ”¹èŠ‚ç‚¹å†…éƒ¨çš„å€¼çš„æƒ…å†µä¸‹å®Œæˆæœ¬é¢˜ï¼ˆå³ï¼Œåªèƒ½è¿›è¡ŒèŠ‚ç‚¹äº¤æ¢ï¼‰ã€‚\nè¿­ä»£æ³•è®¾ç½®ä¸€ä¸ªè™šæ‹Ÿå¤´èŠ‚ç‚¹ï¼Œç„¶åè¿›è¡Œä¸¤ä¸¤äº¤æ¢ã€‚\nclass Solution:    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        if head == None or head.next == None:            return head                dummy_head = ListNode(0, head)        pre = dummy_head        cur1 = head        cur2 = head.next        while True:            lat = cur2.next            cur2.next = cur1            cur1.next = lat            pre.next = cur2            if lat != None and lat.next != None:                pre = cur1                cur1 = lat                cur2 = lat.next                            else:                return dummy_head.next\n\n19.åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹\né¢˜ç›®é“¾æ¥ link\n\nç»™ä½ ä¸€ä¸ªé“¾è¡¨ï¼Œåˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ n ä¸ªç»“ç‚¹ï¼Œå¹¶ä¸”è¿”å›é“¾è¡¨çš„å¤´ç»“ç‚¹ã€‚\næ€è·¯ 1ç›´è§‚æ–¹æ³•ï¼Œå…ˆéå†ä¸€éï¼Œè·å–é“¾è¡¨çš„é•¿åº¦ï¼Œç„¶åå†éå†åˆ é™¤ã€‚\nclass Solution:    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:        dummy_head = ListNode(0, head)        length = 0        cur = dummy_head.next        while cur != None:            length += 1            cur = cur.next        i = 0        cur = dummy_head.next        pre = dummy_head        while i &lt; length - n:            cur = cur.next            pre = pre.next            i += 1                pre.next = cur.next        return dummy_head.next\n\næ€è·¯ 2è¦æ±‚åªéå†ä¸€éé“¾è¡¨ï¼šåŒæŒ‡é’ˆçš„å…¸å‹åº”ç”¨ï¼Œå¦‚æœè¦åˆ é™¤å€’æ•°ç¬¬nä¸ªèŠ‚ç‚¹ï¼Œè®©fastç§»åŠ¨næ­¥ï¼Œç„¶åè®©fastå’ŒslowåŒæ—¶ç§»åŠ¨ï¼Œç›´åˆ°fastæŒ‡å‘é“¾è¡¨æœ«å°¾ã€‚åˆ æ‰slowæ‰€æŒ‡å‘çš„èŠ‚ç‚¹å°±å¯ä»¥äº†ã€‚ï¼ˆå‡è®¾é“¾è¡¨é•¿åº¦ä¸º lï¼Œfast ç§»åŠ¨äº† lï¼Œslow ç§»åŠ¨äº† l - n,ï¼‰\nclass Solution:    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:        dummy_head = ListNode(0, head)        fast = dummy_head.next        slow = dummy_head.next        pre = dummy_head        i = 0        while fast != None:            if i &lt; n:                i += 1            else:                slow = slow.next                pre = pre.next            fast = fast.next                pre.next = slow.next        return dummy_head.next\n\né¢è¯•é¢˜ 02.07. é“¾è¡¨ç›¸äº¤\né¢˜ç›®é“¾æ¥ link\n\nç»™ä½ ä¸¤ä¸ªå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ headA å’Œ headB ï¼Œè¯·ä½ æ‰¾å‡ºå¹¶è¿”å›ä¸¤ä¸ªå•é“¾è¡¨ç›¸äº¤çš„èµ·å§‹èŠ‚ç‚¹ã€‚å¦‚æœä¸¤ä¸ªé“¾è¡¨æ²¡æœ‰äº¤ç‚¹ï¼Œè¿”å› null ã€‚\nç¤ºä¾‹ï¼š\nè¾“å…¥ä¸¤ä¸ª listï¼Œè¿”å›ä¸¤ä¸ª list ç›¸äº¤çš„èŠ‚ç‚¹ã€‚\næ€è·¯å¦‚æœä¸¤ä¸ª list æœ‰ç›¸äº¤çš„éƒ¨åˆ†ï¼Œé‚£ä¹ˆä¸€å®šåœ¨ list çš„ååŠéƒ¨åˆ†ï¼ˆå°¾éƒ¨å¯¹é½ï¼‰ã€‚é‚£ä¹ˆå¯ä»¥ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œé¦–å…ˆéå†ä¸¤ä¸ª list çš„é•¿åº¦ï¼Œæ‰¾åˆ°å…¶é•¿åº¦å·® difï¼Œè®© fast æŒ‡é’ˆåœ¨é•¿çš„ list ä¸Šå…ˆç§»åŠ¨ difï¼Œç„¶åä¸¤ä¸ªæŒ‡é’ˆå†ä¸€èµ·ç§»åŠ¨ã€‚\nclass Solution:    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:        cur1 = headA        cur2 = headB        len1 = 0        len2 = 0        while cur1 != None:            len1 += 1            cur1 = cur1.next        while cur2 != None:            len2 += 1            cur2 = cur2.next                dif = abs(len2 -len1)        if len2 &gt; len1:            fast = headB            slow = headA        else:            fast = headA            slow = headB        for i in range(dif):            fast = fast.next                while fast != None:            if fast == slow:                return fast                        fast = fast.next            slow = slow.next                return None","categories":["Leetcode"],"tags":["list"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘æ ˆå’Œé˜Ÿåˆ—1-åŸºç¡€ç†è®º","url":"/blog/Leetcode/stack-queue1/","content":"åŸºç¡€çŸ¥è¯†é˜Ÿåˆ—æ˜¯å…ˆè¿›å…ˆå‡ºï¼Œæ ˆæ˜¯å…ˆè¿›åå‡º\n\næ ˆæä¾› push å’Œ pop ç­‰æ¥å£ï¼Œæ‰€æœ‰å…ƒç´ å¿…é¡»ç¬¦åˆå…ˆè¿›åå‡ºè§„åˆ™ï¼Œæ‰€ä»¥æ ˆä¸æä¾›èµ°è®¿åŠŸèƒ½ï¼Œä¹Ÿä¸æä¾›è¿­ä»£å™¨(iterator)ã€‚ ä¸åƒæ˜¯ set æˆ–è€… map æä¾›è¿­ä»£å™¨ iterator æ¥éå†æ‰€æœ‰å…ƒç´ ã€‚\næ ˆæ˜¯ä»¥åº•å±‚å®¹å™¨å®Œæˆå…¶æ‰€æœ‰çš„å·¥ä½œï¼Œå¯¹å¤–æä¾›ç»Ÿä¸€çš„æ¥å£ï¼Œåº•å±‚å®¹å™¨æ˜¯å¯æ’æ‹”çš„ï¼ˆä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¯ä»¥æ§åˆ¶ä½¿ç”¨å“ªç§å®¹å™¨æ¥å®ç°æ ˆçš„åŠŸèƒ½ï¼‰ã€‚\n\n232.ç”¨æ ˆå®ç°é˜Ÿåˆ—\nlink\n\nä½¿ç”¨ä¸¤ä¸ªæ ˆå®ç°å…ˆå…¥å…ˆå‡ºé˜Ÿåˆ—ã€‚é˜Ÿåˆ—åº”å½“æ”¯æŒä¸€èˆ¬é˜Ÿåˆ—æ”¯æŒçš„æ‰€æœ‰æ“ä½œï¼ˆpushã€popã€peekã€emptyï¼‰ï¼š\nå®ç° MyQueue ç±»ï¼š\n\nvoid push(int x) å°†å…ƒç´  x æ¨åˆ°é˜Ÿåˆ—çš„æœ«å°¾int pop() ä»é˜Ÿåˆ—çš„å¼€å¤´ç§»é™¤å¹¶è¿”å›å…ƒç´ int peek() è¿”å›é˜Ÿåˆ—å¼€å¤´çš„å…ƒç´ boolean empty() å¦‚æœé˜Ÿåˆ—ä¸ºç©ºï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false\n\nè¯´æ˜ï¼š\nåªèƒ½ä½¿ç”¨æ ‡å‡†çš„æ ˆæ“ä½œ â€”â€” ä¹Ÿå°±æ˜¯åªæœ‰ push to top, peek&#x2F;pop from top, size, å’Œ is empty æ“ä½œæ˜¯åˆæ³•çš„ã€‚ä½ æ‰€ä½¿ç”¨çš„è¯­è¨€ä¹Ÿè®¸ä¸æ”¯æŒæ ˆã€‚ä½ å¯ä»¥ä½¿ç”¨ list æˆ–è€… dequeï¼ˆåŒç«¯é˜Ÿåˆ—ï¼‰æ¥æ¨¡æ‹Ÿä¸€ä¸ªæ ˆï¼Œåªè¦æ˜¯æ ‡å‡†çš„æ ˆæ“ä½œå³å¯ã€‚\næ€è·¯ä½¿ç”¨æ ˆæ¥æ¨¡æ‹Ÿé˜Ÿåˆ—çš„è¡Œä¸ºï¼Œå¦‚æœä»…ä»…ç”¨ä¸€ä¸ªæ ˆï¼Œæ˜¯ä¸€å®šä¸è¡Œçš„ï¼Œæ‰€ä»¥éœ€è¦ä¸¤ä¸ªæ ˆä¸€ä¸ªè¾“å…¥æ ˆï¼Œä¸€ä¸ªè¾“å‡ºæ ˆï¼Œè¿™é‡Œè¦æ³¨æ„è¾“å…¥æ ˆå’Œè¾“å‡ºæ ˆçš„å…³ç³»ã€‚\nclass MyQueue:    def __init__(self):        self.in_stack = []        self.out_stack = []    def push(self, x: int) -&gt; None:        self.in_stack.append(x)    def pop(self) -&gt; int:        if len(self.out_stack) == 0:            for i in range(len(self.in_stack)-1, -1, -1):                self.out_stack.append(self.in_stack[i])                self.in_stack.pop(i)        return self.out_stack.pop()                def peek(self) -&gt; int:        if len(self.out_stack) == 0:            for i in range(len(self.in_stack)-1, -1, -1):                self.out_stack.append(self.in_stack[i])                self.in_stack.pop(i)        return self.out_stack[-1]            def empty(self) -&gt; bool:        if len(self.in_stack) == 0 and len(self.out_stack) == 0:            return True        else:            return False        # Your MyQueue object will be instantiated and called as such:# obj = MyQueue()# obj.push(x)# param_2 = obj.pop()# param_3 = obj.peek()# param_4 = obj.empty()\n\næ³¨æ„ list çš„ pop æ–¹æ³•ï¼Œé»˜è®¤æ˜¯è¿”å›å¹¶ç§»é™¤æœ€åçš„å…ƒç´ ï¼Œå¦‚æœç»™ä¸€ä¸ªå‚æ•°åˆ™è¿”å›å¹¶åˆ é™¤æŒ‡å®š index ä½ç½®çš„å…ƒç´ ã€‚è€Œ list çš„ remove æ–¹æ³•æ˜¯åˆ é™¤ç¬¬ä¸€æ¬¡é‡åˆ°çš„æŒ‡å®šå…ƒç´ ã€‚\n225. ç”¨é˜Ÿåˆ—å®ç°æ ˆ\nlink\n\nä½¿ç”¨ä¸¤ä¸ªé˜Ÿåˆ—å®ç°ä¸€ä¸ªåå…¥å…ˆå‡ºï¼ˆLIFOï¼‰çš„æ ˆï¼Œå¹¶æ”¯æŒæ™®é€šæ ˆçš„å…¨éƒ¨å››ç§æ“ä½œï¼ˆpushã€topã€pop å’Œ emptyï¼‰ã€‚\nå®ç° MyStack ç±»ï¼š\nvoid push(int x) å°†å…ƒç´  x å‹å…¥æ ˆé¡¶ã€‚int pop() ç§»é™¤å¹¶è¿”å›æ ˆé¡¶å…ƒç´ ã€‚int top() è¿”å›æ ˆé¡¶å…ƒç´ ã€‚boolean empty() å¦‚æœæ ˆæ˜¯ç©ºçš„ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚\næ³¨æ„ï¼š\nä½ åªèƒ½ä½¿ç”¨é˜Ÿåˆ—çš„æ ‡å‡†æ“ä½œ â€”â€” ä¹Ÿå°±æ˜¯ push to backã€peek&#x2F;pop from frontã€size å’Œ is empty è¿™äº›æ“ä½œã€‚ä½ æ‰€ä½¿ç”¨çš„è¯­è¨€ä¹Ÿè®¸ä¸æ”¯æŒé˜Ÿåˆ—ã€‚ ä½ å¯ä»¥ä½¿ç”¨ list ï¼ˆåˆ—è¡¨ï¼‰æˆ–è€… dequeï¼ˆåŒç«¯é˜Ÿåˆ—ï¼‰æ¥æ¨¡æ‹Ÿä¸€ä¸ªé˜Ÿåˆ— , åªè¦æ˜¯æ ‡å‡†çš„é˜Ÿåˆ—æ“ä½œå³å¯ã€‚\næ€è·¯ä½¿ç”¨ä¸€ä¸ªé˜Ÿåˆ—ã€‚åœ¨æ¨¡æ‹Ÿæ ˆå¼¹å‡ºå…ƒç´ çš„æ—¶å€™åªè¦å°†é˜Ÿåˆ—å¤´éƒ¨çš„å…ƒç´ ï¼ˆé™¤äº†æœ€åä¸€ä¸ªå…ƒç´ å¤–ï¼‰ é‡æ–°æ·»åŠ åˆ°é˜Ÿåˆ—å°¾éƒ¨ï¼Œæ­¤æ—¶å†å»å¼¹å‡ºå…ƒç´ å°±æ˜¯æ ˆçš„é¡ºåºäº†ã€‚\nPython ä¸­çš„åŒç«¯é˜Ÿåˆ—ä¸º from collections import dequeï¼Œå¸¸ç”¨æ–¹æ³•å¦‚ä¸‹ï¼š\n\næŠŠåŒç«¯é˜Ÿåˆ—å½“æˆæ™®é€šé˜Ÿåˆ—æ¥ä½¿ç”¨ï¼Œåªéœ€è¦ç”¨ append(x) å’Œ  popleft() å³å¯ã€‚\nclass MyStack:    def __init__(self):        self.queue = deque()    def push(self, x: int) -&gt; None:        self.queue.append(x)    def pop(self) -&gt; int:        for _ in range(len(self.queue)-1):            temp = self.queue.popleft()            self.queue.append(temp)                return self.queue.popleft()            def top(self) -&gt; int:        for _ in range(len(self.queue)-1):            temp = self.queue.popleft()            self.queue.append(temp)                temp = self.queue.popleft()        self.queue.append(temp)        return temp         def empty(self) -&gt; bool:        if len(self.queue) == 0:            return True        else:            return False# Your MyStack object will be instantiated and called as such:# obj = MyStack()# obj.push(x)# param_2 = obj.pop()# param_3 = obj.top()# param_4 = obj.empty() ","categories":["Leetcode"],"tags":["stack","queue"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘é“¾è¡¨1-å®šä¹‰","url":"/blog/Leetcode/list1/","content":"é“¾è¡¨å®šä¹‰\næ€§èƒ½å¯¹æ¯”ï¼š\nclass ListNode:    def __init__(self, val, next=None):        self.val = val        self.next = next\n203.ç§»é™¤é“¾è¡¨å…ƒç´ \né¢˜ç›®é“¾æ¥ link\n\nç»™ä½ ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ head å’Œä¸€ä¸ªæ•´æ•° val ï¼Œè¯·ä½ åˆ é™¤é“¾è¡¨ä¸­æ‰€æœ‰æ»¡è¶³ Node.val &#x3D;&#x3D; val çš„èŠ‚ç‚¹ï¼Œå¹¶è¿”å› æ–°çš„å¤´èŠ‚ç‚¹ ã€‚\næ–¹æ³•ä¸€ï¼šä¸ä½¿ç”¨è™šæ‹Ÿå¤´èŠ‚ç‚¹å¦‚æœåˆ é™¤çš„æ—¶å¤´èŠ‚ç‚¹ï¼Œåˆ™éœ€è¦å•ç‹¬å¤„ç†ï¼Œå³ç›´æ¥å°†å¤´èŠ‚ç‚¹æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚\nclass Solution:    def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:        new_head = head        cur = head        pre = None        while cur != None:                        if cur.val == val:                if pre == None:                    cur = cur.next                    new_head = cur                else:                    pre.next = cur.next                    cur = cur.next            else:                pre = cur                cur = cur.next        return new_head\n\næ–¹æ³•äºŒï¼šä½¿ç”¨è™šæ‹Ÿå¤´èŠ‚ç‚¹è®¾ç½®ä¸€ä¸ªè™šæ‹Ÿå¤´ç»“ç‚¹ï¼Œè¿™æ ·åŸé“¾è¡¨çš„æ‰€æœ‰èŠ‚ç‚¹å°±éƒ½å¯ä»¥æŒ‰ç…§ç»Ÿä¸€çš„æ–¹å¼è¿›è¡Œç§»é™¤äº†ã€‚\nclass Solution:    def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:        dummy_head = ListNode(0, head)        cur = head        pre = dummy_head        while cur != None:            if cur.val == val:                pre.next = cur.next            else:                pre = pre.next            cur = cur.next                return dummy_head.next\n\n707.è®¾è®¡é“¾è¡¨\né¢˜ç›®é“¾æ¥ link\n\nä½ å¯ä»¥é€‰æ‹©ä½¿ç”¨å•é“¾è¡¨æˆ–è€…åŒé“¾è¡¨ï¼Œè®¾è®¡å¹¶å®ç°è‡ªå·±çš„é“¾è¡¨ã€‚\nå•é“¾è¡¨ä¸­çš„èŠ‚ç‚¹åº”è¯¥å…·å¤‡ä¸¤ä¸ªå±æ€§ï¼šval å’Œ next ã€‚val æ˜¯å½“å‰èŠ‚ç‚¹çš„å€¼ï¼Œnext æ˜¯æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ&#x2F;å¼•ç”¨ã€‚\nå¦‚æœæ˜¯åŒå‘é“¾è¡¨ï¼Œåˆ™è¿˜éœ€è¦å±æ€§ prev ä»¥æŒ‡ç¤ºé“¾è¡¨ä¸­çš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹ã€‚å‡è®¾é“¾è¡¨ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹ä¸‹æ ‡ä» 0 å¼€å§‹ã€‚\nå®ç° MyLinkedList ç±»ï¼š\n\nMyLinkedList() åˆå§‹åŒ– MyLinkedList å¯¹è±¡ã€‚\nint get(int index) è·å–é“¾è¡¨ä¸­ä¸‹æ ‡ä¸º index çš„èŠ‚ç‚¹çš„å€¼ã€‚å¦‚æœä¸‹æ ‡æ— æ•ˆï¼Œåˆ™è¿”å› -1 ã€‚\nvoid addAtHead(int val) å°†ä¸€ä¸ªå€¼ä¸º val çš„èŠ‚ç‚¹æ’å…¥åˆ°é“¾è¡¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰ã€‚åœ¨æ’å…¥å®Œæˆåï¼Œæ–°èŠ‚ç‚¹ä¼šæˆä¸ºé“¾è¡¨çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚\nvoid addAtTail(int val) å°†ä¸€ä¸ªå€¼ä¸º val çš„èŠ‚ç‚¹è¿½åŠ åˆ°é“¾è¡¨ä¸­ä½œä¸ºé“¾è¡¨çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚\nvoid addAtIndex(int index, int val) å°†ä¸€ä¸ªå€¼ä¸º val çš„èŠ‚ç‚¹æ’å…¥åˆ°é“¾è¡¨ä¸­ä¸‹æ ‡ä¸º index çš„èŠ‚ç‚¹ä¹‹å‰ã€‚å¦‚æœ index ç­‰äºé“¾è¡¨çš„é•¿åº¦ï¼Œé‚£ä¹ˆè¯¥èŠ‚ç‚¹ä¼šè¢«è¿½åŠ åˆ°é“¾è¡¨çš„æœ«å°¾ã€‚å¦‚æœ index æ¯”é•¿åº¦æ›´å¤§ï¼Œè¯¥èŠ‚ç‚¹å°† ä¸ä¼šæ’å…¥ åˆ°é“¾è¡¨ä¸­ã€‚\nvoid deleteAtIndex(int index) å¦‚æœä¸‹æ ‡æœ‰æ•ˆï¼Œåˆ™åˆ é™¤é“¾è¡¨ä¸­ä¸‹æ ‡ä¸º index çš„èŠ‚ç‚¹ã€‚\n\nå•é“¾è¡¨æ³¨æ„ï¼Œåœ¨ addAtIndex æ–¹æ³•ä¸­ï¼Œéœ€è¦åˆ¤æ–­ index æ˜¯å¦ç­‰äº list çš„é•¿åº¦ï¼Œå¦‚æœç­‰äºçš„è¯å°±ç›´æ¥æ’å…¥åˆ°æœ«å°¾ã€‚ä½†æ˜¯åœ¨ while å¾ªç¯ä¸­ï¼Œä¹Ÿæœ‰ index &#x3D;&#x3D; i çš„åˆ¤æ–­ï¼Œè¿™æ ·ä¼šé‡å¤æ’å…¥ï¼ˆè¦†ç›–ï¼‰ï¼Œæ‰€ä»¥ while ä¸­æ’å…¥åï¼Œç›´æ¥ returnï¼ˆä¹‹å‰å†™çš„ breakï¼‰ã€‚\nclass MyLinkedList:    def __init__(self):        self.dummy_head = ListNode(0, None)    def get(self, index: int) -&gt; int:        i = 0        cur = self.dummy_head.next        while cur != None:            if index == i:                return cur.val            else:                cur = cur.next                i += 1        return -1    def addAtHead(self, val: int) -&gt; None:        new_node = ListNode(val, self.dummy_head.next)        self.dummy_head.next = new_node    def addAtTail(self, val: int) -&gt; None:        cur = self.dummy_head.next        pre = self.dummy_head        new_node = ListNode(val, None)        while cur != None:            cur = cur.next            pre = pre.next        pre.next = new_node    def addAtIndex(self, index: int, val: int) -&gt; None:        i = 0        cur = self.dummy_head.next        pre = self.dummy_head        while cur != None:            if index == i:                new_node = ListNode(val, cur)                pre.next = new_node                # è¿™é‡Œè¦å†™ returnï¼Œä¸èƒ½å†™ break                return            else:                i += 1                pre = pre.next                cur = cur.next            # print(i, cur.val)        if index == i:            new_node = ListNode(val, None)            pre.next = new_node            def deleteAtIndex(self, index: int) -&gt; None:        i = 0        cur = self.dummy_head.next        pre = self.dummy_head        while cur != None:            if index == i:                pre.next = cur.next                break            else:                i += 1                pre = pre.next                cur = cur.next\n\nå¯ä»¥å†å®šä¹‰ä¸€ä¸ª size å˜é‡ç”¨äºå­˜å‚¨ list çš„é•¿åº¦ï¼Œè¿™æ ·ä¼šæ–¹ä¾¿å¾ˆå¤šã€‚\nåŒé“¾è¡¨","categories":["Leetcode"],"tags":["list"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘æ ˆå’Œé˜Ÿåˆ—2-æ ˆçš„åº”ç”¨","url":"/blog/Leetcode/stack-queue2/","content":"20. æœ‰æ•ˆçš„æ‹¬å·\nlink\n\nç»™å®šä¸€ä¸ªåªåŒ…æ‹¬ â€˜(â€˜ï¼Œâ€™)â€™ï¼Œâ€™{â€˜ï¼Œâ€™}â€™ï¼Œâ€™[â€˜ï¼Œâ€™]â€™ çš„å­—ç¬¦ä¸² s ï¼Œåˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦æœ‰æ•ˆã€‚æœ‰æ•ˆå­—ç¬¦ä¸²éœ€æ»¡è¶³ï¼š\n\nå·¦æ‹¬å·å¿…é¡»ç”¨ç›¸åŒç±»å‹çš„å³æ‹¬å·é—­åˆã€‚\nå·¦æ‹¬å·å¿…é¡»ä»¥æ­£ç¡®çš„é¡ºåºé—­åˆã€‚\næ¯ä¸ªå³æ‹¬å·éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„ç›¸åŒç±»å‹çš„å·¦æ‹¬å·ã€‚\n\nç¤ºä¾‹ 1ï¼š\n\nè¾“å…¥ï¼šs &#x3D; â€œ()â€è¾“å‡ºï¼štrue\n\næ€è·¯ä½¿ç”¨æ ˆæ¥è¿›è¡Œå­˜å‚¨ï¼Œé‡åˆ°åŒ¹é…çš„åˆ™å‡ºæ ˆã€‚\nclass Solution:    def match(self, i, j):        if i == &quot;]&quot; and j == &quot;[&quot;:            return True        elif i == &#x27;&#125;&#x27; and  j == &#x27;&#123;&#x27;:            return True        elif i == &#x27;)&#x27; and j == &#x27;(&#x27;:            return True        else:            return False    def isValid(self, s: str) -&gt; bool:        stack = []        for i in s:            if len(stack) != 0:                if self.match(i, stack[-1]):                    stack.pop()                else:                    stack.append(i)            else:                stack.append(i)                if len(stack) == 0:            return True        else:            return False\n\n1047. åˆ é™¤å­—ç¬¦ä¸²ä¸­çš„æ‰€æœ‰ç›¸é‚»é‡å¤é¡¹\nlink\n\nç»™å‡ºç”±å°å†™å­—æ¯ç»„æˆçš„å­—ç¬¦ä¸² sï¼Œé‡å¤é¡¹åˆ é™¤æ“ä½œä¼šé€‰æ‹©ä¸¤ä¸ªç›¸é‚»ä¸”ç›¸åŒçš„å­—æ¯ï¼Œå¹¶åˆ é™¤å®ƒä»¬ã€‚åœ¨ s ä¸Šåå¤æ‰§è¡Œé‡å¤é¡¹åˆ é™¤æ“ä½œï¼Œç›´åˆ°æ— æ³•ç»§ç»­åˆ é™¤ã€‚åœ¨å®Œæˆæ‰€æœ‰é‡å¤é¡¹åˆ é™¤æ“ä½œåè¿”å›æœ€ç»ˆçš„å­—ç¬¦ä¸²ã€‚ç­”æ¡ˆä¿è¯å”¯ä¸€ã€‚\n ç¤ºä¾‹ï¼š\n\nè¾“å…¥ï¼šâ€abbacaâ€è¾“å‡ºï¼šâ€caâ€è§£é‡Šï¼šä¾‹å¦‚ï¼Œåœ¨ â€œabbacaâ€ ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥åˆ é™¤ â€œbbâ€ ç”±äºä¸¤å­—æ¯ç›¸é‚»ä¸”ç›¸åŒï¼Œè¿™æ˜¯æ­¤æ—¶å”¯ä¸€å¯ä»¥æ‰§è¡Œåˆ é™¤æ“ä½œçš„é‡å¤é¡¹ã€‚ä¹‹åæˆ‘ä»¬å¾—åˆ°å­—ç¬¦ä¸² â€œaacaâ€ï¼Œå…¶ä¸­åˆåªæœ‰ â€œaaâ€ å¯ä»¥æ‰§è¡Œé‡å¤é¡¹åˆ é™¤æ“ä½œï¼Œæ‰€ä»¥æœ€åçš„å­—ç¬¦ä¸²ä¸º â€œcaâ€ã€‚  \n\næ€è·¯ç±»ä¼¼äºä¸Šä¸€é¢˜ã€‚å¯ä»¥ç†è§£ä¸ºâ€œæ¶ˆæ¶ˆä¹â€ï¼Œé‡åˆ°ç›¸åŒçš„åˆ™å‡ºæ ˆã€‚\nclass Solution:    def removeDuplicates(self, s: str) -&gt; str:        stack = []        for i in s:            if len(stack) != 0 and stack[-1] == i:                stack.pop()            else:                stack.append(i)                return &quot;&quot;.join(stack)\n\n150. é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼\nlink\n\nç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ tokens ï¼Œè¡¨ç¤ºä¸€ä¸ªæ ¹æ® é€†æ³¢å…°è¡¨ç¤ºæ³• è¡¨ç¤ºçš„ç®—æœ¯è¡¨è¾¾å¼ã€‚è¯·ä½ è®¡ç®—è¯¥è¡¨è¾¾å¼ã€‚è¿”å›ä¸€ä¸ªè¡¨ç¤ºè¡¨è¾¾å¼å€¼çš„æ•´æ•°ã€‚\næ³¨æ„ï¼š\n\næœ‰æ•ˆçš„ç®—ç¬¦ä¸º â€˜+â€™ã€â€™-â€˜ã€â€™*â€™ å’Œ â€˜&#x2F;â€˜ ã€‚\næ¯ä¸ªæ“ä½œæ•°ï¼ˆè¿ç®—å¯¹è±¡ï¼‰éƒ½å¯ä»¥æ˜¯ä¸€ä¸ªæ•´æ•°æˆ–è€…å¦ä¸€ä¸ªè¡¨è¾¾å¼ã€‚\nä¸¤ä¸ªæ•´æ•°ä¹‹é—´çš„é™¤æ³•æ€»æ˜¯ å‘é›¶æˆªæ–­ ã€‚\nè¡¨è¾¾å¼ä¸­ä¸å«é™¤é›¶è¿ç®—ã€‚\nè¾“å…¥æ˜¯ä¸€ä¸ªæ ¹æ®é€†æ³¢å…°è¡¨ç¤ºæ³•è¡¨ç¤ºçš„ç®—æœ¯è¡¨è¾¾å¼ã€‚\nç­”æ¡ˆåŠæ‰€æœ‰ä¸­é—´è®¡ç®—ç»“æœå¯ä»¥ç”¨ 32 ä½ æ•´æ•°è¡¨ç¤ºã€‚\n\næ€è·¯æ ¸å¿ƒè§„åˆ™ï¼šé‡åˆ°æ•°å­—åˆ™å…¥æ ˆï¼›é‡åˆ°è¿ç®—ç¬¦åˆ™å–å‡ºæ ˆé¡¶ä¸¤ä¸ªæ•°å­—è¿›è¡Œè®¡ç®—ï¼Œå¹¶å°†ç»“æœå‹å…¥æ ˆä¸­ã€‚\næ³¨æ„é¢˜ç›®ä¸­è¦æ±‚æ˜¯å‘é›¶æˆªæ–­ï¼Œä½¿ç”¨ // ä¸è¡Œã€‚// æ˜¯å‘ä¸‹å–æ•´ï¼Œå¯¹äºå¤æ•°ç»“æœä¸æ»¡è¶³å‘é›¶æˆªæ–­ï¼ˆ-1 &#x2F;&#x2F; 2 &#x3D;&#x3D; -1ï¼‰ã€‚å¯ä»¥ä½¿ç”¨ int(a &#x2F; b)ã€‚\nclass Solution:    def evalRPN(self, tokens: List[str]) -&gt; int:        stack = []        for i in tokens:            if i.isdigit() or i.replace(&#x27;-&#x27;, &#x27;&#x27;).isdigit():                stack.append(int(i))            else:                num2 = stack.pop()                num1 = stack.pop()                if i == &#x27;-&#x27;:                    res = num1 - num2                elif i == &#x27;+&#x27;:                    res = num1 + num2                elif i == &#x27;*&#x27;:                    res = num1 * num2                elif i == &#x27;/&#x27;:                    res = int(num1 / num2)                stack.append(res)                return stack[0]","categories":["Leetcode"],"tags":["stack"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘æ ˆå’Œé˜Ÿåˆ—3-é˜Ÿåˆ—çš„åº”ç”¨","url":"/blog/Leetcode/stack-queue3/","content":"239. æ»‘åŠ¨çª—å£æœ€å¤§å€¼\nlink\n\nç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ numsï¼Œæœ‰ä¸€ä¸ªå¤§å°ä¸º k çš„æ»‘åŠ¨çª—å£ä»æ•°ç»„çš„æœ€å·¦ä¾§ç§»åŠ¨åˆ°æ•°ç»„çš„æœ€å³ä¾§ã€‚ä½ åªå¯ä»¥çœ‹åˆ°åœ¨æ»‘åŠ¨çª—å£å†…çš„ k ä¸ªæ•°å­—ã€‚æ»‘åŠ¨çª—å£æ¯æ¬¡åªå‘å³ç§»åŠ¨ä¸€ä½ã€‚\nè¿”å›æ»‘åŠ¨çª—å£ä¸­çš„æœ€å¤§å€¼ ã€‚\næ€è·¯æ»‘åŠ¨çª—å£å°±æ˜¯ä¸€ä¸ªé˜Ÿåˆ—ï¼Œéœ€è¦å­˜å‚¨å…¶ä¸­çš„æœ€å¤§å€¼ã€‚ï¼ˆä½†æ˜¯å¦‚æœæœ€å¤§å€¼è¢« pop å‡ºå»äº†å‘¢ï¼Ÿè®°å½•æ¬¡å¤§å€¼ä¹Ÿä¸è¡Œï¼‰\næ­£ç¡®æ€è·¯ï¼šç»´æŠ¤ä¸€ä¸ªå•è°ƒé˜Ÿåˆ—ã€‚å•è°ƒé˜Ÿåˆ—ä¸ä¸€å®šè¦å­˜æ”¾çª—å£ä¸­æ‰€æœ‰çš„æ•°ã€‚pop å’Œ push æ“ä½œè¦ä¿æŒå¦‚ä¸‹è§„åˆ™ï¼š\n\npop(value)ï¼šå¦‚æœçª—å£ç§»é™¤çš„å…ƒç´  value ç­‰äºå•è°ƒé˜Ÿåˆ—çš„å‡ºå£å…ƒç´ ï¼Œé‚£ä¹ˆé˜Ÿåˆ—å¼¹å‡ºå…ƒç´ ï¼Œå¦åˆ™ä¸ç”¨ä»»ä½•æ“ä½œ\npush(value)ï¼šå¦‚æœ push çš„å…ƒç´  value å¤§äºå…¥å£å…ƒç´ çš„æ•°å€¼ï¼Œé‚£ä¹ˆå°±å°†é˜Ÿåˆ—å…¥å£çš„å…ƒç´ å¼¹å‡ºï¼Œç›´åˆ° push å…ƒç´ çš„æ•°å€¼å°äºç­‰äºé˜Ÿåˆ—å…¥å£å…ƒç´ çš„æ•°å€¼ä¸ºæ­¢\n\nä¿æŒå¦‚ä¸Šè§„åˆ™ï¼Œæ¯æ¬¡çª—å£ç§»åŠ¨çš„æ—¶å€™ï¼Œåªè¦é—® que.front() ï¼ˆque[0]ï¼‰å°±å¯ä»¥è¿”å›å½“å‰çª—å£çš„æœ€å¤§å€¼ã€‚\nè¿‡ç¨‹å¦‚å›¾æ‰€ç¤ºï¼š\n\nclass MyQueue: #å•è°ƒé˜Ÿåˆ—ï¼ˆä»å¤§åˆ°å°    def __init__(self):        self.queue = deque() #è¿™é‡Œéœ€è¦ä½¿ç”¨dequeå®ç°å•è°ƒé˜Ÿåˆ—ï¼Œç›´æ¥ä½¿ç”¨listä¼šè¶…æ—¶        #æ¯æ¬¡å¼¹å‡ºçš„æ—¶å€™ï¼Œæ¯”è¾ƒå½“å‰è¦å¼¹å‡ºçš„æ•°å€¼æ˜¯å¦ç­‰äºé˜Ÿåˆ—å‡ºå£å…ƒç´ çš„æ•°å€¼ï¼Œå¦‚æœç›¸ç­‰åˆ™å¼¹å‡ºã€‚    #åŒæ—¶popä¹‹å‰åˆ¤æ–­é˜Ÿåˆ—å½“å‰æ˜¯å¦ä¸ºç©ºã€‚    def pop(self, value):        if self.queue and value == self.queue[0]:            self.queue.popleft()#list.pop()æ—¶é—´å¤æ‚åº¦ä¸ºO(n),è¿™é‡Œéœ€è¦ä½¿ç”¨collections.deque()                #å¦‚æœpushçš„æ•°å€¼å¤§äºå…¥å£å…ƒç´ çš„æ•°å€¼ï¼Œé‚£ä¹ˆå°±å°†é˜Ÿåˆ—åç«¯çš„æ•°å€¼å¼¹å‡ºï¼Œç›´åˆ°pushçš„æ•°å€¼å°äºç­‰äºé˜Ÿåˆ—å…¥å£å…ƒç´ çš„æ•°å€¼ä¸ºæ­¢ã€‚    #è¿™æ ·å°±ä¿æŒäº†é˜Ÿåˆ—é‡Œçš„æ•°å€¼æ˜¯å•è°ƒä»å¤§åˆ°å°çš„äº†ã€‚    def push(self, value):        while self.queue and value &gt; self.queue[-1]:            self.queue.pop()        self.queue.append(value)            #æŸ¥è¯¢å½“å‰é˜Ÿåˆ—é‡Œçš„æœ€å¤§å€¼ ç›´æ¥è¿”å›é˜Ÿåˆ—å‰ç«¯ä¹Ÿå°±æ˜¯frontå°±å¯ä»¥äº†ã€‚    def front(self):        return self.queue[0]    class Solution:    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:        que = MyQueue()        result = []        for i in range(k): #å…ˆå°†å‰kçš„å…ƒç´ æ”¾è¿›é˜Ÿåˆ—            que.push(nums[i])        result.append(que.front()) #result è®°å½•å‰kçš„å…ƒç´ çš„æœ€å¤§å€¼        for i in range(k, len(nums)):            que.pop(nums[i - k]) #æ»‘åŠ¨çª—å£ç§»é™¤æœ€å‰é¢å…ƒç´             que.push(nums[i]) #æ»‘åŠ¨çª—å£å‰åŠ å…¥æœ€åé¢çš„å…ƒç´             result.append(que.front()) #è®°å½•å¯¹åº”çš„æœ€å¤§å€¼        return result\n\n347.å‰ K ä¸ªé«˜é¢‘å…ƒç´ \nlink\n\nç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•° k ï¼Œè¯·ä½ è¿”å›å…¶ä¸­å‡ºç°é¢‘ç‡å‰ k é«˜çš„å…ƒç´ ã€‚ä½ å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ç­”æ¡ˆã€‚\nç¤ºä¾‹ 1:\n\nè¾“å…¥: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2è¾“å‡º: [1,2]\n\næ€è·¯ä¸‰ä¸ªæ­¥éª¤ï¼š\n\nè¦ç»Ÿè®¡å…ƒç´ å‡ºç°é¢‘ç‡ï¼ˆå“ˆå¸Œè¡¨ï¼‰\nå¯¹é¢‘ç‡æ’åºï¼ˆä¼˜å…ˆçº§é˜Ÿåˆ—ï¼‰\næ‰¾å‡ºå‰Kä¸ªé«˜é¢‘å…ƒç´ \n\nä¼˜å…ˆçº§é˜Ÿåˆ—å…¶å®å°±æ˜¯ä¸€ä¸ªæŠ«ç€é˜Ÿåˆ—å¤–è¡£çš„å †ï¼Œå› ä¸ºä¼˜å…ˆçº§é˜Ÿåˆ—å¯¹å¤–æ¥å£åªæ˜¯ä»é˜Ÿå¤´å–å…ƒç´ ï¼Œä»é˜Ÿå°¾æ·»åŠ å…ƒç´ ï¼Œå†æ— å…¶ä»–å–å…ƒç´ çš„æ–¹å¼ï¼Œçœ‹èµ·æ¥å°±æ˜¯ä¸€ä¸ªé˜Ÿåˆ—ã€‚ä¼˜å…ˆçº§é˜Ÿåˆ—å†…éƒ¨å…ƒç´ æ˜¯è‡ªåŠ¨ä¾ç…§å…ƒç´ çš„æƒå€¼æ’åˆ—ã€‚\nå †ï¼ˆHeapï¼‰æ˜¯ä¸€æ£µå®Œå…¨äºŒå‰æ ‘ï¼Œæ ‘ä¸­æ¯ä¸ªç»“ç‚¹çš„å€¼éƒ½ä¸å°äºï¼ˆæˆ–ä¸å¤§äºï¼‰å…¶å·¦å³å­©å­çš„å€¼ã€‚ å¦‚æœçˆ¶äº²ç»“ç‚¹æ˜¯å¤§äºç­‰äºå·¦å³å­©å­å°±æ˜¯å¤§é¡¶å †ï¼Œå°äºç­‰äºå·¦å³å­©å­å°±æ˜¯å°é¡¶å †ã€‚å¤§é¡¶å †ï¼ˆå †å¤´æ˜¯æœ€å¤§å…ƒç´ ï¼‰ï¼Œå°é¡¶å †ï¼ˆå †å¤´æ˜¯æœ€å°å…ƒç´ ï¼‰ã€‚\nå †çš„å¸¸è§ç”¨é€”ï¼š\n\nä¼˜å…ˆé˜Ÿåˆ—ï¼ˆPriority Queueï¼‰ï¼šæ¯”å¦‚ Python çš„ heapq é»˜è®¤æ˜¯å°é¡¶å †ã€‚\nå †æ’åºï¼ˆHeap Sortï¼‰ï¼šåˆ©ç”¨å¤§é¡¶å †å¯å®ç°å‡åºæ’åºï¼Œæ—¶é—´å¤æ‚åº¦ O(n log n)ã€‚\nTop K é—®é¢˜ï¼šç»´æŠ¤ä¸€ä¸ªå¤§å°ä¸º K çš„å°é¡¶å †æ¥è·å–æœ€å¤§çš„ K ä¸ªå…ƒç´ ã€‚\n\né¢˜ç›®è¦æ±‚å‰ K ä¸ªé«˜é¢‘å…ƒç´ ï¼Œé‚£ä¹ˆæœæ–­ç”¨å¤§é¡¶å †ã€‚é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œå®šä¹‰ä¸€ä¸ªå¤§å°ä¸º k çš„å¤§é¡¶å †ï¼Œåœ¨æ¯æ¬¡ç§»åŠ¨æ›´æ–°å¤§é¡¶å †çš„æ—¶å€™ï¼Œæ¯æ¬¡å¼¹å‡ºéƒ½æŠŠæœ€å¤§çš„å…ƒç´ å¼¹å‡ºå»äº†ï¼Œé‚£ä¹ˆæ€ä¹ˆä¿ç•™ä¸‹æ¥å‰Kä¸ªé«˜é¢‘å…ƒç´ å‘¢ã€‚è€Œä¸”ä½¿ç”¨å¤§é¡¶å †å°±è¦æŠŠæ‰€æœ‰å…ƒç´ éƒ½è¿›è¡Œæ’åºï¼Œé‚£èƒ½ä¸èƒ½åªæ’åºkä¸ªå…ƒç´ å‘¢ï¼Ÿæ‰€ä»¥æˆ‘ä»¬è¦ç”¨å°é¡¶å †ï¼Œå› ä¸ºè¦ç»Ÿè®¡æœ€å¤§å‰kä¸ªå…ƒç´ ï¼Œåªæœ‰å°é¡¶å †æ¯æ¬¡å°†æœ€å°çš„å…ƒç´ å¼¹å‡ºï¼Œæœ€åå°é¡¶å †é‡Œç§¯ç´¯çš„æ‰æ˜¯å‰kä¸ªæœ€å¤§å…ƒç´ ã€‚\nå¯»æ‰¾å‰kä¸ªæœ€å¤§å…ƒç´ æµç¨‹å¦‚å›¾æ‰€ç¤ºï¼šï¼ˆå›¾ä¸­çš„é¢‘ç‡åªæœ‰ä¸‰ä¸ªï¼Œæ‰€ä»¥æ­£å¥½æ„æˆä¸€ä¸ªå¤§å°ä¸º3çš„å°é¡¶å †ï¼Œå¦‚æœé¢‘ç‡æ›´å¤šä¸€äº›ï¼Œåˆ™ç”¨è¿™ä¸ªå°é¡¶å †è¿›è¡Œæ‰«æï¼‰\n\nimport heapqclass Solution:    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:        #è¦ç»Ÿè®¡å…ƒç´ å‡ºç°é¢‘ç‡        map_ = &#123;&#125; #nums[i]:å¯¹åº”å‡ºç°çš„æ¬¡æ•°        for i in range(len(nums)):            map_[nums[i]] = map_.get(nums[i], 0) + 1                #å¯¹é¢‘ç‡æ’åº        #å®šä¹‰ä¸€ä¸ªå°é¡¶å †ï¼Œå¤§å°ä¸ºk        pri_que = [] #å°é¡¶å †                #ç”¨å›ºå®šå¤§å°ä¸ºkçš„å°é¡¶å †ï¼Œæ‰«ææ‰€æœ‰é¢‘ç‡çš„æ•°å€¼        for key, freq in map_.items():            heapq.heappush(pri_que, (freq, key))            if len(pri_que) &gt; k: #å¦‚æœå †çš„å¤§å°å¤§äºäº†Kï¼Œåˆ™é˜Ÿåˆ—å¼¹å‡ºï¼Œä¿è¯å †çš„å¤§å°ä¸€ç›´ä¸ºk                heapq.heappop(pri_que)                #æ‰¾å‡ºå‰Kä¸ªé«˜é¢‘å…ƒç´ ï¼Œå› ä¸ºå°é¡¶å †å…ˆå¼¹å‡ºçš„æ˜¯æœ€å°çš„ï¼Œæ‰€ä»¥å€’åºæ¥è¾“å‡ºåˆ°æ•°ç»„        result = [0] * k        for i in range(k-1, -1, -1):            result[i] = heapq.heappop(pri_que)[1]        return result\n","categories":["Leetcode"],"tags":["queue"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘é“¾è¡¨3","url":"/blog/Leetcode/list3/","content":"142.ç¯å½¢é“¾è¡¨II\né¢˜ç›®é“¾æ¥ link\n\nç»™å®šä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹  head ï¼Œè¿”å›é“¾è¡¨å¼€å§‹å…¥ç¯çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ å¦‚æœé“¾è¡¨æ— ç¯ï¼Œåˆ™è¿”å› nullã€‚\nå¦‚æœé“¾è¡¨ä¸­æœ‰æŸä¸ªèŠ‚ç‚¹ï¼Œå¯ä»¥é€šè¿‡è¿ç»­è·Ÿè¸ª next æŒ‡é’ˆå†æ¬¡åˆ°è¾¾ï¼Œåˆ™é“¾è¡¨ä¸­å­˜åœ¨ç¯ã€‚ ä¸ºäº†è¡¨ç¤ºç»™å®šé“¾è¡¨ä¸­çš„ç¯ï¼Œè¯„æµ‹ç³»ç»Ÿå†…éƒ¨ä½¿ç”¨æ•´æ•° pos æ¥è¡¨ç¤ºé“¾è¡¨å°¾è¿æ¥åˆ°é“¾è¡¨ä¸­çš„ä½ç½®ï¼ˆç´¢å¼•ä» 0 å¼€å§‹ï¼‰ã€‚å¦‚æœ pos æ˜¯ -1ï¼Œåˆ™åœ¨è¯¥é“¾è¡¨ä¸­æ²¡æœ‰ç¯ã€‚æ³¨æ„ï¼špos ä¸ä½œä¸ºå‚æ•°è¿›è¡Œä¼ é€’ï¼Œä»…ä»…æ˜¯ä¸ºäº†æ ‡è¯†é“¾è¡¨çš„å®é™…æƒ…å†µã€‚\nä¸å…è®¸ä¿®æ”¹ é“¾è¡¨ã€‚\nç¤ºä¾‹ 1ï¼š\n\nè¿”å›çš„èŠ‚ç‚¹ä¸º 2\n\næ€è·¯ 1ï¼šå“ˆå¸Œè¡¨æŠŠé‡åˆ°çš„èŠ‚ç‚¹å­˜èµ·æ¥ï¼Œå¦‚æœé‡å¤é‡åˆ°äº†èŠ‚ç‚¹ï¼Œè¯´æ˜è¯¥èŠ‚ç‚¹æ˜¯ç¯çš„èµ·ç‚¹ã€‚\nclass Solution:    def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        cur = head        nodes = []        while cur != None:            if cur in nodes:                return cur            else:                nodes.append(cur)                cur = cur.next\n\næ€è·¯ 2ï¼šå¿«æ…¢æŒ‡é’ˆæ ¸å¿ƒæ€æƒ³ä¸ºï¼šæ…¢æŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨ä¸€æ ¼ï¼Œå¿«æŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨ä¸¤æ ¼ï¼Œå¦‚æœå¿«æ…¢æŒ‡é’ˆç›¸é‡ï¼Œåˆ™ä¸€å®šåœ¨ç¯ä¸Šã€‚ï¼ˆå¿«æŒ‡é’ˆè¿½ä¸Šæ…¢æŒ‡é’ˆï¼‰\næ€è·¯ 2-1å¿«æ…¢æŒ‡é’ˆç›¸é‡åï¼Œå…ˆè®©æ…¢æŒ‡é’ˆèµ°ä¸€åœˆå¾—åˆ°å…¶åœˆçš„é•¿åº¦ã€‚ç„¶åä»å¤´é‡æ–°å®šä¹‰å¿«æ…¢æŒ‡é’ˆï¼Œå¿«æŒ‡é’ˆå…ˆèµ°åœˆçš„é•¿åº¦ï¼Œç„¶åä¸¤ä¸ªæŒ‡é’ˆä¸€èµ·èµ°ï¼Œè¿™æ ·å°±ä¼šåœ¨åœˆçš„èµ·ç‚¹ç›¸é‡ã€‚å¦‚å›¾æ‰€ç¤ºï¼š\n\næ€è·¯ 2-2æ›´è¿›ä¸€æ­¥ï¼Œå¦‚å›¾æ‰€ç¤ºï¼Œæ…¢æŒ‡é’ˆèµ°äº† bï¼Œå¿«æŒ‡é’ˆèµ°äº† b + ncï¼ˆn ä¸ºåœˆæ•°ï¼‰ï¼Œå¿«æŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨ä¸¤æ ¼ï¼Œæ‰€ä»¥æœ‰ 2b &#x3D; b + ncï¼Œå³ b &#x3D; ncã€‚ç›¸å½“äºæ…¢æŒ‡é’ˆèµ°çš„æ€»é•¿åº¦ä¸ºåœˆé•¿åº¦çš„ n å€ã€‚ä½†æ˜¯ï¼Œæ…¢æŒ‡é’ˆèµ°çš„è·¯ç¨‹ä¸­ï¼ˆncï¼‰ä¸­ï¼Œæœ‰ä¸€æ®µä¸åœ¨ç¯ä¸­ï¼ˆå³è¦æ±‚çš„ aï¼‰ï¼Œæ‰€ä»¥è¯´ï¼Œè¿˜éœ€è¦å†èµ° a æ‰ç›¸å½“äºèµ°æ»¡äº† n åœˆã€‚\nç„¶åå†ä½¿ç”¨åŒæŒ‡é’ˆï¼Œåˆ†åˆ«ä»å¤´èŠ‚ç‚¹å’Œç›¸é‡èŠ‚ç‚¹å‡ºå‘ï¼Œä»–ä»¬ä¸€å®šä¼šåœ¨ç¯çš„èµ·ç‚¹ç›¸é‡ã€‚\næ€è·¯ 2-1 å¯ä»¥è®¤ä¸ºæ˜¯ç‰¹æ®Šæƒ…å†µï¼Œå…ˆæ±‚å‡ºç¯çš„é•¿åº¦ cï¼Œå¿«æŒ‡é’ˆå…ˆèµ° cï¼Œè¿˜éœ€è¦å†èµ° a æ‰èƒ½å›åˆ°ç¯çš„èµ·ç‚¹ï¼Œæ­¤æ—¶ä¸¤ä¸ªæŒ‡é’ˆåŒæ—¶ç§»åŠ¨ï¼Œç›¸é‡æ—¶åˆ™èµ°äº† aã€‚\n\nclass Solution:    def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        fast = head        slow = head        while fast != None and fast.next != None:            fast = fast.next.next            slow = slow.next            if fast == slow:                new_slow = head                while new_slow != slow:                    slow = slow.next                    new_slow = new_slow.next                                return new_slow                return None","categories":["Leetcode"],"tags":["list"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘äºŒå‰æ ‘1-éå†","url":"/blog/Leetcode/tree1/","content":"äºŒå‰æ ‘æ¦‚å¿µæ»¡äºŒå‰æ ‘å’Œå®Œå…¨äºŒå‰æ ‘\n\näºŒå‰æœç´¢æ ‘äºŒå‰æœç´¢æ ‘æ˜¯ä¸€ä¸ªæœ‰åºæ ‘ã€‚\n\nè‹¥å®ƒçš„å·¦å­æ ‘ä¸ç©ºï¼Œåˆ™å·¦å­æ ‘ä¸Šæ‰€æœ‰ç»“ç‚¹çš„å€¼å‡å°äºå®ƒçš„æ ¹ç»“ç‚¹çš„å€¼ï¼›\nè‹¥å®ƒçš„å³å­æ ‘ä¸ç©ºï¼Œåˆ™å³å­æ ‘ä¸Šæ‰€æœ‰ç»“ç‚¹çš„å€¼å‡å¤§äºå®ƒçš„æ ¹ç»“ç‚¹çš„å€¼ï¼›\nå®ƒçš„å·¦ã€å³å­æ ‘ä¹Ÿåˆ†åˆ«ä¸ºäºŒå‰æ’åºæ ‘\n\n\nå¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼Œåˆè¢«ç§°ä¸ºAVLï¼ˆAdelson-Velsky and Landisï¼‰æ ‘ï¼Œä¸”å…·æœ‰ä»¥ä¸‹æ€§è´¨ï¼šå®ƒæ˜¯ä¸€æ£µç©ºæ ‘æˆ–å®ƒçš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡1ï¼Œå¹¶ä¸”å·¦å³ä¸¤ä¸ªå­æ ‘éƒ½æ˜¯ä¸€æ£µå¹³è¡¡äºŒå‰æ ‘ã€‚\n\nå­˜å‚¨æ–¹å¼é“¾å¼å­˜å‚¨ï¼š\n\né¡ºåºå­˜å‚¨ï¼š\n\nå¦‚æœçˆ¶èŠ‚ç‚¹çš„æ•°ç»„ä¸‹æ ‡æ˜¯ iï¼Œé‚£ä¹ˆå®ƒçš„å·¦å­©å­å°±æ˜¯ i * 2 + 1ï¼Œå³å­©å­å°±æ˜¯ i * 2 + 2ã€‚\néå†\næ·±åº¦ä¼˜å…ˆéå†\nå‰åºéå†ï¼ˆé€’å½’æ³•ï¼Œè¿­ä»£æ³•ï¼‰\nä¸­åºéå†ï¼ˆé€’å½’æ³•ï¼Œè¿­ä»£æ³•ï¼‰\nååºéå†ï¼ˆé€’å½’æ³•ï¼Œè¿­ä»£æ³•ï¼‰\n\n\nå¹¿åº¦ä¼˜å…ˆéå†\nå±‚æ¬¡éå†ï¼ˆè¿­ä»£æ³•ï¼‰\n\n\n\næ³¨æ„ï¼Œè¿™é‡Œå‰ä¸­åï¼Œå…¶å®æŒ‡çš„å°±æ˜¯ä¸­é—´èŠ‚ç‚¹çš„éå†é¡ºåºï¼Œåªè¦å¤§å®¶è®°ä½å‰ä¸­ååºæŒ‡çš„å°±æ˜¯ä¸­é—´èŠ‚ç‚¹çš„ä½ç½®å°±å¯ä»¥äº†ã€‚\näºŒå‰æ ‘çš„é€’å½’éå†è¿­ä»£ï¼ˆiterationï¼‰æ˜¯é‡å¤åé¦ˆè¿‡ç¨‹çš„æ´»åŠ¨ï¼Œå…¶ç›®çš„é€šå¸¸æ˜¯é€¼è¿‘æ‰€éœ€ç›®æ ‡æˆ–ç»“æœï¼›é€’å½’ï¼ˆrecursionï¼‰æ˜¯é‡å¤è°ƒç”¨å‡½æ•°è‡ªèº«ã€‚è¿­ä»£é€šå¸¸ç”±è®¡æ•°å™¨æ¥åˆ¤æ–­æ˜¯å¦ç»“æŸï¼›è€Œé€’å½’åˆ™æ»¡è¶³ç»ˆæ­¢æ¡ä»¶æ‰é€å±‚è¿”å›ã€‚\né€’å½’ä¸‰è¦ç´ ï¼š\n\nç¡®å®šé€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ï¼šå‚æ•°ä¸ºå½“å‰èŠ‚ç‚¹ï¼Œè¿”å›å€¼ä¸ºç»“æœæ•°ç»„ï¼ˆåœ¨æ–¹æ³•å†…å®šä¹‰è¿­ä»£å‡½æ•°ï¼Œå¯ä»¥ä¸è®¾ç½®è¿”å›å€¼ï¼‰\nç¡®å®šç»ˆæ­¢æ¡ä»¶ï¼šå½“å‰èŠ‚ç‚¹ä¸ºç©ºåˆ™è¿”å›\nç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘ï¼šä¸‰ä¸ªæ­¥éª¤ï¼Œæ ¹æ®éå†çš„ç±»å‹æ¥è°ƒæ•´é¡ºåº\néå†å½“å‰èŠ‚ç‚¹ï¼ˆå°†å½“å‰èŠ‚ç‚¹çš„å†…å®¹åŠ åˆ°ç»“æœæ•°ç»„ä¸­ï¼‰\néå†å·¦å­æ ‘\néå†å³å­æ ‘\n\n\n\nå‰åºéå†ä»£ç å¦‚ä¸‹ï¼Œä¸­åºå’Œååºéå†åªéœ€è¦æ›´æ”¹é€’å½’å‡½æ•°ä¸­çš„é€»è¾‘é¡ºåºå³å¯\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:        def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        res = []        def recursion(node):            if node != None:                res.append(node.val)                recursion(node.left)                recursion(node.right)                recursion(root)        return res\n\näºŒå‰æ ‘çš„è¿­ä»£éå†é€’å½’çš„å®ç°æ˜¯ï¼šæ¯ä¸€æ¬¡é€’å½’è°ƒç”¨éƒ½ä¼šæŠŠå‡½æ•°çš„å±€éƒ¨å˜é‡ã€å‚æ•°å€¼å’Œè¿”å›åœ°å€ç­‰å‹å…¥è°ƒç”¨æ ˆä¸­ï¼Œç„¶åé€’å½’è¿”å›çš„æ—¶å€™ï¼Œä»æ ˆé¡¶å¼¹å‡ºä¸Šä¸€æ¬¡é€’å½’çš„å„é¡¹å‚æ•°ï¼Œæ‰€ä»¥è¿™å°±æ˜¯é€’å½’ä¸ºä»€ä¹ˆå¯ä»¥è¿”å›ä¸Šä¸€å±‚ä½ç½®çš„åŸå› ã€‚\nå‰åºéå†å½“æ ˆä¸ä¸ºç©ºæ—¶ï¼Œå°†æ ˆé¡¶èŠ‚ç‚¹ popï¼Œè®¿é—®å…¶å…ƒç´ ï¼Œå¹¶å°†å…¶å­èŠ‚ç‚¹åˆ†åˆ«æ”¾å…¥æ ˆä¸­ã€‚æ³¨æ„è¦å…ˆæ”¾å³èŠ‚ç‚¹å†æ”¾å·¦èŠ‚ç‚¹ï¼Œä»¥ä¿è¯å·¦èŠ‚ç‚¹å…ˆè®¿é—®ã€‚\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:        def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        res = []        stack = [root]        while len(stack) != 0:            cur = stack.pop()            if cur != None:                res.append(cur.val)                stack.append(cur.right)                stack.append(cur.left)                return res\n\nä¸­åºéå†å‰åºéå†çš„é¡ºåºæ˜¯ä¸­å·¦å³ï¼Œå…ˆè®¿é—®çš„å…ƒç´ æ˜¯ä¸­é—´èŠ‚ç‚¹ï¼ˆå­èŠ‚ç‚¹åˆ†åˆ«æ”¾åˆ°æ ˆä¸­ï¼‰ï¼Œå…ˆå¤„ç†çš„å…ƒç´ ä¹Ÿæ˜¯ä¸­é—´èŠ‚ç‚¹ï¼ˆå°† val å­˜å…¥ resï¼‰ï¼Œæ‰€ä»¥åˆšåˆšæ‰èƒ½å†™å‡ºç›¸å¯¹ç®€æ´çš„ä»£ç ï¼Œå› ä¸ºè¦è®¿é—®çš„å…ƒç´ å’Œè¦å¤„ç†çš„å…ƒç´ é¡ºåºæ˜¯ä¸€è‡´çš„ï¼Œéƒ½æ˜¯ä¸­é—´èŠ‚ç‚¹ã€‚\nä¸­åºéå†æ˜¯å·¦ä¸­å³ï¼Œå…ˆè®¿é—®çš„æ˜¯äºŒå‰æ ‘é¡¶éƒ¨çš„èŠ‚ç‚¹ï¼Œç„¶åä¸€å±‚ä¸€å±‚å‘ä¸‹è®¿é—®ï¼Œç›´åˆ°åˆ°è¾¾æ ‘å·¦é¢çš„æœ€åº•éƒ¨ï¼Œå†å¼€å§‹å¤„ç†èŠ‚ç‚¹ï¼ˆä¹Ÿå°±æ˜¯åœ¨æŠŠèŠ‚ç‚¹çš„æ•°å€¼æ”¾è¿›resultæ•°ç»„ä¸­ï¼‰ï¼Œè¿™å°±é€ æˆäº†å¤„ç†é¡ºåºå’Œè®¿é—®é¡ºåºæ˜¯ä¸ä¸€è‡´çš„ã€‚\nå¯¹äºå½“å‰æ ˆé¡¶èŠ‚ç‚¹èŠ‚ç‚¹ï¼Œä¸€ç›´éå†å·¦å­æ ‘ï¼Œç›´åˆ°ä¸ºç©ºï¼ˆè®¿é—®å·¦ï¼‰ï¼›ç„¶åï¼Œå°† val å­˜å…¥ resï¼ˆå¤„ç†ä¸­ï¼‰ï¼›æœ€åå†å°†å½“å‰èŠ‚ç‚¹çš„å³å­æ ‘æ”¾åˆ°æ ˆä¸­ï¼ˆè®¿é—®å³ï¼‰ã€‚\nclass Solution:    def inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        res = []        stack = []        cur = root        while True:            while cur != None:                stack.append(cur)                cur = cur.left                        if len(stack) == 0:                break            cur = stack.pop()            res.append(cur.val)            cur = cur.right        return res\n\nåç»­éå†æ€è·¯ 1å’Œä¸­åºéå†ä¸€æ ·ï¼Œå¯¹äºå½“å‰èŠ‚ç‚¹ï¼Œä¸€ç›´éå†å…¶å·¦å­æ ‘ï¼Œç›´åˆ°ä¸ºç©ºï¼ˆè®¿é—®å·¦ï¼‰ï¼›ç„¶åå¯¹å…¶å³å­æ ‘è¿›è¡Œåˆ¤æ–­ï¼ˆè®¿é—®å³ï¼‰ï¼Œå¦‚æœï¼š\n\nå³å­æ ‘ä¸ºç©ºï¼Œåˆ™è®¿é—®å½“å‰å…ƒç´ ï¼ˆå¤„ç†ä¸­ï¼‰\nå³å­æ ‘ä¸ä¸ºç©ºï¼Œæ­¤æ—¶éœ€è¦åˆ¤æ–­å½“å‰å³å­æ ‘æ˜¯å¦è¢«è®¿é—®è¿‡ï¼š\nå³å­æ ‘è®¿é—®è¿‡ï¼Œåˆ™è®¿é—®å½“å‰å…ƒç´ \næ²¡è®¿é—®è¿‡ï¼Œåˆ™å½“å‰èŠ‚ç‚¹å†æ¬¡å…¥æ ˆï¼Œå¹¶ä¸”å½“å‰æŒ‡é’ˆæŒ‡å‘å³èŠ‚ç‚¹\n\n\n\næ€»ç»“ä¸€ä¸‹ï¼Œå³å­æ ‘ä¸ä¸ºç©ºå¹¶ä¸”æ²¡è¢«è®¿é—®è¿‡ï¼Œåˆ™è®¿é—®å³å­æ ‘ï¼›å¦åˆ™è®¿é—®å½“å‰å…ƒç´ ï¼Œå¹¶è®°å½•å½“å‰å…ƒç´ å·²ç»è®¿é—®ã€‚\nclass Solution:        def postorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        res = []        stack = []        cur = root        prev = None        while True:            while cur != None:                stack.append(cur)                cur = cur.left                        if len(stack) == 0:                break                        cur = stack.pop()            if cur.right != None and prev != cur.right:                stack.append(cur)                cur = cur.right            else:                res.append(cur.val)                prev = cur                cur = None        return res\n\næ€è·¯ 2å…ˆåºéå†æ˜¯ä¸­å·¦å³ï¼Œååºéå†æ˜¯å·¦å³ä¸­ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦è°ƒæ•´ä¸€ä¸‹å…ˆåºéå†çš„ä»£ç é¡ºåºï¼Œå°±å˜æˆä¸­å³å·¦çš„éå†é¡ºåºï¼Œç„¶ååœ¨åè½¬resultæ•°ç»„ï¼Œè¾“å‡ºçš„ç»“æœé¡ºåºå°±æ˜¯å·¦å³ä¸­äº†ã€‚\nç»Ÿä¸€è¿­ä»£éå†é€’å½’æœ¬è´¨ä¸Šæ˜¯ç»´æŠ¤ä¸€ä¸ªæ ˆæ¥ä¿å­˜è°ƒç”¨é¡ºåºã€‚ä½†æ˜¯å¯èƒ½ä¼šé¢ä¸´è®¿é—®ï¼ˆè®¿é—®å­èŠ‚ç‚¹ï¼‰å’Œå¤„ç†ï¼ˆè¯»å–å€¼ï¼‰ä¸åŒæ­¥çš„æƒ…å†µï¼Œå¯¼è‡´ä¸åŒçš„éå†é¡ºåºå†™æ³•ä¸åŒã€‚è¦ç»Ÿä¸€å†™æ³•ï¼Œå°†è®¿é—®çš„èŠ‚ç‚¹æ”¾å…¥æ ˆä¸­ï¼ŒæŠŠè¦å¤„ç†çš„èŠ‚ç‚¹ä¹Ÿæ”¾å…¥æ ˆä¸­ä½†æ˜¯è¦åšæ ‡è®°ï¼š\n\næ–¹æ³•ä¸€ï¼šå°±æ˜¯è¦å¤„ç†çš„èŠ‚ç‚¹æ”¾å…¥æ ˆä¹‹åï¼Œç´§æ¥ç€æ”¾å…¥ä¸€ä¸ªç©ºæŒ‡é’ˆä½œä¸ºæ ‡è®°ã€‚ è¿™ç§æ–¹æ³•å¯ä»¥å«åšç©ºæŒ‡é’ˆæ ‡è®°æ³•ã€‚\n\næ–¹æ³•äºŒï¼šåŠ ä¸€ä¸ª boolean å€¼è·Ÿéšæ¯ä¸ªèŠ‚ç‚¹ï¼Œfalse (é»˜è®¤å€¼) è¡¨ç¤ºéœ€è¦ä¸ºè¯¥èŠ‚ç‚¹å’Œå®ƒçš„å·¦å³å„¿å­å®‰æ’åœ¨æ ˆä¸­çš„ä½æ¬¡ï¼Œtrue è¡¨ç¤ºè¯¥èŠ‚ç‚¹çš„ä½æ¬¡ä¹‹å‰å·²ç»å®‰æ’è¿‡äº†ï¼Œå¯ä»¥æ”¶å‰²èŠ‚ç‚¹äº†ã€‚ è¿™ç§æ–¹æ³•å¯ä»¥å«åšboolean æ ‡è®°æ³•ã€‚è¿™ç§æ–¹æ³•æ›´å®¹æ˜“ç†è§£ï¼Œåœ¨é¢è¯•ä¸­æ›´å®¹æ˜“å†™å‡ºæ¥ã€‚\n\n\næ–¹æ³•ä¸€é¦–å…ˆæŠŠæ ¹èŠ‚ç‚¹æ”¾åˆ° stack ä¸­ï¼ˆä¿è¯ä¸ä¸ºç©ºï¼‰ï¼Œæ ¸å¿ƒé€»è¾‘ä¸ºï¼šæ ˆå¤´å…ƒç´ å‡ºæ ˆï¼Œåˆ¤æ–­è¯¥èŠ‚ç‚¹æ˜¯å¦ä¸ºç©º\n\nå¦‚æœä¸ºç©ºï¼Œè¯´æ˜å½“å‰çš„æ ˆå¤´å…ƒç´ çš„å­å…ƒç´ å·²ç»è®¿é—®è¿‡ï¼Œåˆ™å½“å‰æ ˆå¤´å…ƒç´ å‡ºæ ˆï¼Œè¯»å–å…¶ valï¼›\nå¦‚æœä¸ä¸ºç©ºï¼Œè¯´æ˜å½“å‰å…ƒç´ çš„å­å…ƒç´ æ²¡è¢«è®¿é—®è¿‡ï¼Œåˆ™å°†å½“å‰èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ã€å½“å‰èŠ‚ç‚¹å’Œä¸€ä¸ªç©ºèŠ‚ç‚¹åŠ å…¥åˆ° stack ä¸­ã€‚ï¼ˆæ³¨æ„ stack å…ˆè¿›å…ˆå‡ºï¼Œæ‰€ä»¥è¦é€†åºï¼Œå³å‰åºéå†æ˜¯ä¸­å·¦å³ï¼Œåˆ™æ”¾å…¥ stack çš„é¡ºåºä¸ºï¼šå³ã€å·¦ï¼Œä¸­+ç©ºèŠ‚ç‚¹ï¼‰\n\nå‰åºä»£ç å¦‚ä¸‹ï¼Œä¸­åºå’Œååºåªéœ€è¦æ›´æ”¹ä¸‰ä¸ªæ­¥éª¤çš„é¡ºåºå³å¯ã€‚\nclass Solution:        def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        res = []        stack = []        if root != None:            stack.append(root)        while len(stack) != 0:            cur = stack.pop()            if cur != None:                # å³èŠ‚ç‚¹å…¥æ ˆ                if cur.right:                    stack.append(cur.right)                # å·¦èŠ‚ç‚¹å…¥æ ˆ                if cur.left:                    stack.append(cur.left)                # ä¸­é—´èŠ‚ç‚¹å…¥æ ˆ                stack.append(cur)                stack.append(None)            else:                cur = stack.pop()                res.append(cur.val)        return res\n\næ–¹æ³•äºŒæ ˆå­˜æ”¾ä¸€ä¸ªå…ƒç»„ï¼ŒåŒ…å«èŠ‚ç‚¹å’Œä¸€ä¸ª flagï¼Œè¡¨ç¤ºå½“å‰èŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ˜¯å¦è¢«è®¿é—®è¿‡ã€‚æ¥ä¸‹æ¥åˆ™å’Œæ–¹æ³•ä¸€ç±»ä¼¼ï¼Œå¯¹äºæ¯ä¸ªèŠ‚ç‚¹éƒ½æ£€æŸ¥è¿™ä¸ª flagï¼Œå¦‚æœä¸º Falseï¼Œè¯´æ˜å­èŠ‚ç‚¹æ²¡æœ‰è¢«è®¿é—®è¿‡ï¼Œåˆ™éå†å­èŠ‚ç‚¹ï¼›å¦‚æœä¸º Trueï¼Œåˆ™å¤„ç†å½“å‰èŠ‚ç‚¹ã€‚\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:        def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        res = []        stack = []        if root != None:            stack.append((root, False))        while len(stack) != 0:            cur, flag = stack.pop()            if flag == False:                if cur.right:                    stack.append((cur.right, False))                if cur.left:                    stack.append((cur.left, False))                stack.append((cur, True))            else:                res.append(cur.val)        return res\n\n102.äºŒå‰æ ‘çš„å±‚åºéå†\nlink\n\nç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ å±‚åºéå† ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚\nç¤ºä¾‹\n\n\nè¾“å…¥ï¼šroot &#x3D; [3,9,20,null,null,15,7]è¾“å‡ºï¼š[[3],[9,20],[15,7]]  \n\næ€è·¯ä¸€ä¸ªé˜Ÿåˆ—æ¥å­˜å‚¨èŠ‚ç‚¹ã€‚å¯¹äºå½“å‰èŠ‚ç‚¹ï¼Œè®¿é—®ä¹‹åå°†å…¶å­èŠ‚ç‚¹åŠ å…¥åˆ°é˜Ÿåˆ—ä¸­ï¼Œç›´åˆ°é˜Ÿåˆ—ä¸ºç©ºã€‚\nclass Solution:    def levelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:        que = deque()        res = []        if root:            que.append(root)                while que:            cur = que.popleft()            res.append(cur.val)            if cur.left:                que.append(cur.left)            if cur.right:                que.append(cur.right)                return res\nä¸éš¾å†™å‡ºä»¥ä¸Šä»£ç ï¼Œä½†æ˜¯æ³¨æ„åˆ°é¢˜ç›®è¦æ±‚æ¯ä¸€å±‚çš„èŠ‚ç‚¹åœ¨å•ç‹¬çš„ä¸€ä¸ª list ä¸­ã€‚è§£å†³æ–¹æ³•ï¼Œä¿è¯æ¯æ¬¡å¾ªç¯ï¼ˆque é•¿åº¦ä¸ä¸º 0ï¼‰æ—¶ï¼Œé˜Ÿåˆ—ä¸­åªæœ‰ä¸€å±‚çš„èŠ‚ç‚¹ï¼Œæ‰€ä»¥å¯ä»¥ä¸€æ¬¡æ€§æŠŠå½“å‰å±‚çš„æ‰€æœ‰å­èŠ‚ç‚¹å…¨éƒ¨æ”¾åˆ°é˜Ÿåˆ—ä¸­ã€‚åªéœ€è¦å¯¹å½“å‰é˜Ÿåˆ—è¿›è¡Œéå†å³å¯ã€‚\nclass Solution:    def levelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:        que = deque()        res = []        if root:            que.append(root)                while que:            cur_level = []            for _ in range(len(que)):                cur = que.popleft()                cur_level.append(cur.val)                if cur.left:                    que.append(cur.left)                if cur.right:                    que.append(cur.right)            res.append(cur_level)        return res\n\n107.äºŒå‰æ ‘çš„å±‚æ¬¡éå† IIç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼è‡ªåº•å‘ä¸Šçš„å±‚æ¬¡éå†ã€‚ ï¼ˆå³æŒ‰ä»å¶å­èŠ‚ç‚¹æ‰€åœ¨å±‚åˆ°æ ¹èŠ‚ç‚¹æ‰€åœ¨çš„å±‚ï¼Œé€å±‚ä»å·¦å‘å³éå†ï¼‰\næ€è·¯ï¼šç›¸è¾ƒäºä¸Šä¸€é¢˜ï¼Œåªéœ€è¦æŠŠç»“æœåè¿‡æ¥å³å¯\n199.äºŒå‰æ ‘çš„å³è§†å›¾\nlink\n\n\næ€è·¯ï¼šéå†æ¯ä¸€å±‚æ—¶ï¼Œåªéœ€è¦ä¿ç•™å½“å‰å±‚çš„æœ€åä¸€ä¸ªå…ƒç´ å³å¯\nclass Solution:    def rightSideView(self, root: Optional[TreeNode]) -&gt; List[int]:        que = deque()        res = []        count = 0        if root:            que.append(root)            count += 1                while que:            l = len(que)            for i in range(len(que)):                cur = que.popleft()                if i == l - 1:                    res.append(cur.val)                if cur.left:                    que.append(cur.left)                if cur.right:                    que.append(cur.right)        return res\n\n637.äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼ç»™å®šä¸€ä¸ªéç©ºäºŒå‰æ ‘, è¿”å›ä¸€ä¸ªç”±æ¯å±‚èŠ‚ç‚¹å¹³å‡å€¼ç»„æˆçš„æ•°ç»„ã€‚\næ€è·¯ï¼šéå†æ¯ä¸€å±‚æ—¶æ±‚å‡å€¼å³å¯\n429.Nå‰æ ‘çš„å±‚åºéå†å’ŒäºŒå‰æ ‘ç›¸åŒï¼Œåªä¸è¿‡ N å‰æ ‘çš„å­èŠ‚ç‚¹ä¸ºä¸€ä¸ª Node çš„æ•°ç»„\n515.åœ¨æ¯ä¸ªæ ‘è¡Œä¸­æ‰¾æœ€å¤§å€¼å°†æ¯è¡Œæ•°ç»„ä¸­æœ€å¤§çš„å€¼å­˜å…¥ res å³å¯\n116.å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ\næ€è·¯ï¼šåœ¨æ¯ä¸€å±‚ï¼Œé’ˆå¯¹æ¯ä¸€ä¸ªèŠ‚ç‚¹è¿›è¡Œæ“ä½œå³å¯\n104.äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦äºŒå‰æ ‘çš„å±‚åºéå†ï¼Œæœ€åè¿”å› res çš„é•¿åº¦å³å¯\n111.äºŒå‰æ ‘çš„æœ€å°æ·±åº¦åŒæ ·æ˜¯å±‚åºéå†ï¼Œåªä¸è¿‡åˆ¤æ–­æ¡ä»¶æ˜¯å·¦å³å­©å­å…¨ä¸ºç©ºåˆ™è¯´æ˜åˆ°äº†æœ€æµ…çš„èŠ‚ç‚¹ï¼ˆå› ä¸ºæ˜¯ä¸¥æ ¼æŒ‰ç…§ä¸€å±‚ä¸€å±‚æ¥è¿›è¡Œéå†çš„ï¼‰ã€‚\n","categories":["Leetcode"],"tags":["tree"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘äºŒå‰æ ‘2-å±æ€§1","url":"/blog/Leetcode/tree2/","content":"101. å¯¹ç§°äºŒå‰æ ‘\nlinkç»™ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œ æ£€æŸ¥å®ƒæ˜¯å¦è½´å¯¹ç§°ã€‚\n\næ€è·¯å±‚åºéå†ï¼Œåˆ¤æ–­æ¯ä¸€å±‚æ˜¯å¦ä¸ºå¯¹ç§°ã€‚æ³¨æ„éœ€è¦è®°å½•å½“å‰åœ¨ç¬¬å‡ å±‚ï¼Œè¿˜éœ€è¦åˆ¤æ–­å½“å‰å±‚çš„é•¿åº¦æ˜¯å¦æ˜¯ 2^nã€‚ä½†æ˜¯ï¼Œè¿™ç§æ–¹æ³•åªè€ƒè™‘äº†æ»¡äºŒå‰æ ‘çš„æƒ…å†µã€‚\nclass Solution:    def isSymmetric(self, root: Optional[TreeNode]) -&gt; bool:        que = deque()        if root:            que.append(root)        count = 0        while que:            cur_level = []            for _ in range(len(que)):                cur = que.popleft()                cur_level.append(cur.val)                if cur.left:                    que.append(cur.left)                if cur.right:                    que.append(cur.right)            if len(cur_level) == 2 ** count:                l, r = 0, len(cur_level) - 1                while l &lt;= r:                    if cur_level[l] != cur_level[r]:                        return False                    else:                        l += 1                        r -= 1            else:                return False            count += 1        return True\n\næ­£ç¡®æ€è·¯å¯¹äºæ ¹èŠ‚ç‚¹ï¼Œåº”è¯¥è¦åˆ¤æ–­å…¶ä¸¤ä¸ªå­æ ‘æ˜¯å¦æ˜¯å¯¹ç§°çš„ï¼Œæ‰€ä»¥éœ€è¦åŒæ—¶éå†ä¸¤ä¸ªå­æ ‘ã€‚æ³¨æ„ï¼Œä¸¤ä¸ªå­æ ‘çš„éå†æ–¹æ³•ä¹Ÿéœ€è¦å¯¹ç§°ï¼Œæœ¬é¢˜éå†åªèƒ½æ˜¯â€œååºéå†â€ï¼Œå› ä¸ºæˆ‘ä»¬è¦é€šè¿‡é€’å½’å‡½æ•°çš„è¿”å›å€¼æ¥åˆ¤æ–­ä¸¤ä¸ªå­æ ‘çš„å†…ä¾§èŠ‚ç‚¹å’Œå¤–ä¾§èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰ã€‚ï¼ˆï¼Ÿï¼‰\né€’å½’ä¸‰éƒ¨æ›²ï¼š\n\nå‚æ•°å’Œè¿”å›ç±»å‹ï¼šä¼ å…¥å·¦å³å­æ ‘ï¼Œè¿”å›ä¸¤ä¸ªå­æ ‘æ˜¯å¦ç›¸ç­‰\nç»ˆæ­¢æ¡ä»¶ï¼šæ¯”è¾ƒä¸¤ä¸ªå­èŠ‚ç‚¹\nå•å±‚é€’å½’é€»è¾‘ï¼šåˆ†åˆ«æ¯”è¾ƒå¤–ä¾§å’Œå†…ä¾§èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰\n\nclass Solution:    def isSymmetric(self, root: Optional[TreeNode]) -&gt; bool:                def treverse(l, r):            if l != None and r == None:                return False            elif l == None and r != None:                return False            elif l == None and r == None:                return True            else:                if r.val != l.val:                    return False                else:                    # å·¦å³èŠ‚ç‚¹éƒ½ä¸ä¸ºç©ºï¼Œä¸”èŠ‚ç‚¹ç›¸ç­‰ï¼Œå¼€å§‹éå†å­èŠ‚ç‚¹                    inter = treverse(l.right, r.left)                    out = treverse(l.left, r.right)                                        if out &amp; inter:                        return True                    else:                        return False                if root:            return treverse(root.left, root.right)        else:            return False\n\n\n\n104.äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦å±‚åºéå†ï¼Œè¿”å› res çš„é•¿åº¦\n111.äºŒå‰æ ‘çš„æœ€å°æ·±åº¦å±‚åºéå†ï¼ŒèŠ‚ç‚¹çš„å·¦å³éƒ½ä¸ºç©ºæ—¶ï¼Œåˆ™è¿”å›å½“å‰æ·±åº¦\n222.å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°å®Œå…¨äºŒå‰æ ‘ï¼šé™¤äº†æœ€åº•å±‚èŠ‚ç‚¹å¯èƒ½æ²¡å¡«æ»¡å¤–ï¼Œå…¶ä½™æ¯å±‚èŠ‚ç‚¹æ•°éƒ½è¾¾åˆ°æœ€å¤§å€¼ï¼Œå¹¶ä¸”æœ€ä¸‹é¢ä¸€å±‚çš„èŠ‚ç‚¹éƒ½é›†ä¸­åœ¨è¯¥å±‚æœ€å·¦è¾¹çš„è‹¥å¹²ä½ç½®ã€‚è‹¥æœ€åº•å±‚ä¸ºç¬¬ h å±‚ï¼Œåˆ™è¯¥å±‚åŒ…å« 1~ 2^(h-1)  ä¸ªèŠ‚ç‚¹\næ€è·¯1ç›´æ¥éå†\næ€è·¯2å®Œå…¨äºŒå‰æ ‘åªæœ‰ä¸¤ç§æƒ…å†µï¼Œæƒ…å†µä¸€ï¼šå°±æ˜¯æ»¡äºŒå‰æ ‘ï¼Œæƒ…å†µäºŒï¼šæœ€åä¸€å±‚å¶å­èŠ‚ç‚¹æ²¡æœ‰æ»¡ã€‚\nå¯¹äºæƒ…å†µä¸€ï¼Œå¯ä»¥ç›´æ¥ç”¨ 2^æ ‘æ·±åº¦ - 1 æ¥è®¡ç®—ï¼Œæ³¨æ„è¿™é‡Œæ ¹èŠ‚ç‚¹æ·±åº¦ä¸º1ã€‚\nå¯¹äºæƒ…å†µäºŒï¼Œåˆ†åˆ«é€’å½’å·¦å­©å­ï¼Œå’Œå³å­©å­ï¼Œé€’å½’åˆ°æŸä¸€æ·±åº¦ä¸€å®šä¼šæœ‰å·¦å­©å­æˆ–è€…å³å­©å­ä¸ºæ»¡äºŒå‰æ ‘ï¼Œç„¶åä¾ç„¶å¯ä»¥æŒ‰ç…§æƒ…å†µ1æ¥è®¡ç®—ã€‚\n\nåœ¨å®Œå…¨äºŒå‰æ ‘ä¸­ï¼Œå¦‚æœé€’å½’å‘å·¦éå†çš„æ·±åº¦ç­‰äºé€’å½’å‘å³éå†çš„æ·±åº¦ï¼Œé‚£è¯´æ˜å°±æ˜¯æ»¡äºŒå‰æ ‘ã€‚\nclass Solution:    def countNodes(self, root: Optional[TreeNode]) -&gt; int:        def treverse(node):            if node!= None:                leftd, rightd = 1, 1                rightn = node.right                leftn = node.left                while rightn:                    rightd += 1                    rightn = rightn.right                while leftn:                    leftd += 1                    leftn = leftn.left                if leftd == rightd:                    return 2 ** leftd - 1                else:                    return treverse(node.left) + treverse(node.right) + 1            else:                return 0        return treverse(root)\n\n110.å¹³è¡¡äºŒå‰æ ‘\nlink\n\nå¹³è¡¡äºŒå‰æ ‘å®šä¹‰ä¸ºï¼šä¸€ä¸ªäºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹ çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡1ã€‚\n\näºŒå‰æ ‘èŠ‚ç‚¹çš„æ·±åº¦ï¼šæŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°è¯¥èŠ‚ç‚¹çš„æœ€é•¿ç®€å•è·¯å¾„è¾¹çš„æ¡æ•°ã€‚\näºŒå‰æ ‘èŠ‚ç‚¹çš„é«˜åº¦ï¼šæŒ‡ä»è¯¥èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„æœ€é•¿ç®€å•è·¯å¾„è¾¹çš„æ¡æ•°ã€‚\n\n\nä½¿ç”¨ååºéå†ï¼š\n\nå‚æ•°ï¼šå½“å‰ä¼ å…¥èŠ‚ç‚¹ã€‚ è¿”å›å€¼ï¼šä»¥å½“å‰ä¼ å…¥èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„æ ‘çš„é«˜åº¦ã€‚\né€’å½’çš„è¿‡ç¨‹ä¸­ä¾ç„¶æ˜¯é‡åˆ°ç©ºèŠ‚ç‚¹äº†ä¸ºç»ˆæ­¢ï¼Œè¿”å›0ï¼Œè¡¨ç¤ºå½“å‰èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„æ ‘é«˜åº¦ä¸º0\nåˆ¤æ–­ä»¥å½“å‰ä¼ å…¥èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„äºŒå‰æ ‘æ˜¯å¦æ˜¯å¹³è¡¡äºŒå‰æ ‘ï¼šå…¶å·¦å­æ ‘é«˜åº¦å’Œå…¶å³å­æ ‘é«˜åº¦çš„å·®å€¼ã€‚ä»£ç ä¸­è¿”å› -1 è¡¨ç¤ºå½“å‰å·²ç»æœ‰å­æ ‘ä¸æ»¡è¶³å¹³è¡¡æ¡ä»¶äº†ï¼Œæ‰€ä»¥ä¸ç”¨è¿›è¡Œåç»­æ¯”è¾ƒï¼Œç›´æ¥é€€å‡ºå³å¯ã€‚\n\nclass Solution:    def isBalanced(self, root: Optional[TreeNode]) -&gt; bool:        def treverse(node):            if node != None:                leftd = treverse(node.left)                rightd = treverse(node.right)                if leftd == -1:                    return -1                if rightd == -1:                    return -1                if abs(leftd - rightd) &gt; 1:                    return -1                else:                    return 1 + max(leftd, rightd)            else:                return 0                if treverse(root) == -1:            return False        else:            return True","categories":["Leetcode"],"tags":["tree"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘å­—ç¬¦ä¸²1","url":"/blog/Leetcode/string1/","content":"344. åè½¬å­—ç¬¦ä¸²\nlink\n\nç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå…¶ä½œç”¨æ˜¯å°†è¾“å…¥çš„å­—ç¬¦ä¸²åè½¬è¿‡æ¥ã€‚è¾“å…¥å­—ç¬¦ä¸²ä»¥å­—ç¬¦æ•°ç»„ s çš„å½¢å¼ç»™å‡ºã€‚\nä¸è¦ç»™å¦å¤–çš„æ•°ç»„åˆ†é…é¢å¤–çš„ç©ºé—´ï¼Œä½ å¿…é¡»åŸåœ°ä¿®æ”¹è¾“å…¥æ•°ç»„ã€ä½¿ç”¨ O(1) çš„é¢å¤–ç©ºé—´è§£å†³è¿™ä¸€é—®é¢˜ã€‚\nç¤ºä¾‹ 1ï¼š\n\nè¾“å…¥ï¼šs &#x3D; [â€œhâ€,â€eâ€,â€lâ€,â€lâ€,â€oâ€]è¾“å‡ºï¼š[â€œoâ€,â€lâ€,â€lâ€,â€eâ€,â€hâ€]  \n\næ€è·¯ä»å¤´åˆ°å°¾ã€ä»å°¾åˆ°å¤´åŒæ—¶éå†ï¼Œç„¶åäº¤æ¢ã€‚\nclass Solution:    def reverseString(self, s: List[str]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify s in-place instead.        &quot;&quot;&quot;        left = 0        right = len(s) - 1        while left &lt; right:            temp = s[left]            s[left] = s[right]            s[right] = temp            left += 1            right -= 1        \n\n541. åè½¬å­—ç¬¦ä¸² II\nlink\n\nç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² s å’Œä¸€ä¸ªæ•´æ•° kï¼Œä»å­—ç¬¦ä¸²å¼€å¤´ç®—èµ·ï¼Œæ¯è®¡æ•°è‡³ 2k ä¸ªå­—ç¬¦ï¼Œå°±åè½¬è¿™ 2k å­—ç¬¦ä¸­çš„å‰ k ä¸ªå­—ç¬¦ã€‚\nå¦‚æœå‰©ä½™å­—ç¬¦å°‘äº k ä¸ªï¼Œåˆ™å°†å‰©ä½™å­—ç¬¦å…¨éƒ¨åè½¬ã€‚å¦‚æœå‰©ä½™å­—ç¬¦å°äº 2k ä½†å¤§äºæˆ–ç­‰äº k ä¸ªï¼Œåˆ™åè½¬å‰ k ä¸ªå­—ç¬¦ï¼Œå…¶ä½™å­—ç¬¦ä¿æŒåŸæ ·ã€‚\nç¤ºä¾‹ 1ï¼š\n\nè¾“å…¥ï¼šs &#x3D; â€œabcdefgâ€, k &#x3D; 2è¾“å‡ºï¼šâ€bacdfegâ€\n\næ€è·¯æ¨¡æ‹Ÿè¿‡ç¨‹ï¼Œæ¯è¿‡ 2k ä¸ªæ­¥éª¤å°±å¤„ç†ä¸€æ¬¡\nclass Solution:    def reserve(self, s):        left = 0        right = len(s) - 1        while left &lt; right:            temp = s[left]            s[left] = s[right]            s[right] = temp            left += 1            right -= 1        return &quot;&quot;.join(s)    def reverseStr(self, s: str, k: int) -&gt; str:        s_list = list(s)        res = []        for i in range(0, len(s_list), 2 * k):            left = len(s_list) - i            if left &gt;= 2 * k:                res.append(self.reserve(s_list[i:i+k]))                res.append(&quot;&quot;.join(s_list[i+k:i+2*k]))            elif left &lt; 2 * k and left &gt;= k:                res.append(self.reserve(s_list[i:i+k]))                res.append(&quot;&quot;.join(s_list[i+k:]))            else:                res.append(self.reserve(s_list[i:]))                return &quot;&quot;.join(res)\n\næ›¿æ¢æ•°å­—\nlink\n\nç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œå®ƒåŒ…å«å°å†™å­—æ¯å’Œæ•°å­—å­—ç¬¦ï¼Œè¯·ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå°†å­—ç¬¦ä¸²ä¸­çš„å­—æ¯å­—ç¬¦ä¿æŒä¸å˜ï¼Œè€Œå°†æ¯ä¸ªæ•°å­—å­—ç¬¦æ›¿æ¢ä¸ºnumberã€‚\nä¾‹å¦‚ï¼Œå¯¹äºè¾“å…¥å­—ç¬¦ä¸² â€œa1b2c3â€ï¼Œå‡½æ•°åº”è¯¥å°†å…¶è½¬æ¢ä¸º â€œanumberbnumbercnumberâ€ã€‚\næ€è·¯ç›´æ¥éå†ï¼Œç„¶åå°†ç»“æœå­˜åœ¨æ•°ç»„ä¸­å³å¯\nimport sysinput = sys.stdin.readdata = input()res = []for i in data:    if i.isdigit():        res.append(&quot;number&quot;)    else:        res.append(i)print(&quot;&quot;.join(res))\n\nè¿˜å¯ä»¥ä½¿ç”¨åŒæŒ‡é’ˆçš„æ–¹æ³•ï¼Œå³é¦–å…ˆç¡®å®šæ•°å­—çš„æ•°é‡ï¼Œç„¶åä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«åœ¨åŸå­—ç¬¦ä¸²å’Œæ–°çš„ç»“æœ list ä¸Šç§»åŠ¨ã€‚\nimport sysinput = sys.stdin.readdata = input()num = 0for i in data:    if i.isdigit():        num += 1res = [&quot;0&quot;] * (num * 5 + len(data))j = 0s = &quot;number&quot;for i in range(len(data)):    if data[i].isdigit():        for index in range(len(s)):            res[j+index] = s[index]                j += 6    else:        res[j] = data[i]        j += 1print(&quot;&quot;.join(res))\n\nä¸Šè¿°ä»£ç æ˜¯ä»å‰å¾€åå¡«å……ï¼Œä½†æ˜¯æŸäº›é¢˜ç›®è¦æ±‚åœ¨åŸå¯¹è±¡ä¸Šä¿®æ”¹ï¼ˆæ‰©å®¹ä¹‹åï¼‰ï¼Œæ‰€ä»¥æœ€å¥½æ˜¯ä»åå¾€å‰å¡«å……ã€‚ç¤ºæ„å›¾å¦‚ä¸‹ï¼š\n\n151.ç¿»è½¬å­—ç¬¦ä¸²é‡Œçš„å•è¯\nlink\n\nç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s ï¼Œè¯·ä½ åè½¬å­—ç¬¦ä¸²ä¸­ å•è¯ çš„é¡ºåºã€‚\nå•è¯ æ˜¯ç”±éç©ºæ ¼å­—ç¬¦ç»„æˆçš„å­—ç¬¦ä¸²ã€‚s ä¸­ä½¿ç”¨è‡³å°‘ä¸€ä¸ªç©ºæ ¼å°†å­—ç¬¦ä¸²ä¸­çš„ å•è¯ åˆ†éš”å¼€ã€‚\nè¿”å› å•è¯ é¡ºåºé¢ å€’ä¸” å•è¯ ä¹‹é—´ç”¨å•ä¸ªç©ºæ ¼è¿æ¥çš„ç»“æœå­—ç¬¦ä¸²ã€‚\næ³¨æ„ï¼šè¾“å…¥å­—ç¬¦ä¸² sä¸­å¯èƒ½ä¼šå­˜åœ¨å‰å¯¼ç©ºæ ¼ã€å°¾éšç©ºæ ¼æˆ–è€…å•è¯é—´çš„å¤šä¸ªç©ºæ ¼ã€‚è¿”å›çš„ç»“æœå­—ç¬¦ä¸²ä¸­ï¼Œå•è¯é—´åº”å½“ä»…ç”¨å•ä¸ªç©ºæ ¼åˆ†éš”ï¼Œä¸”ä¸åŒ…å«ä»»ä½•é¢å¤–çš„ç©ºæ ¼ã€‚\nç¤ºä¾‹ 1ï¼š\n\nè¾“å…¥ï¼šs &#x3D; â€œthe sky is blueâ€è¾“å‡ºï¼šâ€blue is sky theâ€  \n\næ€è·¯ç›¸å½“äºæ˜¯ä½¿ç”¨ split() ä¹‹ååœ¨å€’åºã€‚æ³¨æ„ï¼šsplit()ï¼šå¤šä¸ªç©ºæ ¼å½“æˆä¸€ä¸ªç©ºæ ¼ï¼›split(â€˜ â€˜)ï¼šå¤šä¸ªç©ºæ ¼éƒ½è¦åˆ†å‰²ï¼Œæ¯ä¸ªç©ºæ ¼åˆ†å‰²å‡ºæ¥ç©ºå­—ç¬¦ä¸²ã€‚ä½†æ˜¯è¦æˆ‘ä»¬è‡ªå·±å®ç° split() æ–¹æ³•ã€‚è¿™é‡Œä½¿ç”¨äº†åŒæŒ‡é’ˆæ¥åˆ¤æ–­å•è¯çš„èµ·å§‹ä½ç½®ï¼Œç„¶åæŠŠå•è¯å­˜èµ·æ¥ã€‚\nclass Solution:    def reverseWords(self, s: str) -&gt; str:                s_list = list(s)        slow = 0        fast = 0        res = []        while fast &lt; len(s):            if slow == fast:                 if s_list[slow] == &quot; &quot; :                    slow += 1                    fast += 1                elif fast == len(s) - 1:                    res.append(&quot;&quot;.join(s[slow:fast+1]))                    fast += 1                else:                    fast += 1            else:                if s_list[fast] == &quot; &quot;:                    res.append(&quot;&quot;.join(s[slow:fast]))                    slow = fast                elif fast == len(s) - 1:                    res.append(&quot;&quot;.join(s[slow:fast+1]))                    fast += 1                else:                    fast += 1        new_res = []        for i in range(len(res)-1, -1, -1):            new_res.append(res[i])        return &quot; &quot;.join(new_res)\n\nè¿›é˜¶å¦‚æœè¦æ±‚ç©ºé—´å¤æ‚åº¦ä¸º O(1) å‘¢ï¼Ÿç±»ä¼¼äºä¹‹å‰çš„ ç§»é™¤å…ƒç´  ï¼ŒåŒæ ·ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œåˆ é™¤å¤šä½™çš„ç©ºæ ¼ã€‚ç„¶åç¿»è½¬æ•´ä¸ªå­—ç¬¦ä¸²ï¼Œå†éå†å…¶ä¸­çš„å•è¯ï¼ŒæŠŠå•è¯ç¿»è½¬å›æ¥ã€‚è§£é¢˜æ€è·¯å¦‚ä¸‹ï¼š\n\nç§»é™¤å¤šä½™ç©ºæ ¼\nå°†æ•´ä¸ªå­—ç¬¦ä¸²åè½¬\nå°†æ¯ä¸ªå•è¯åè½¬\n\nä¸¾ä¸ªä¾‹å­ï¼Œæºå­—ç¬¦ä¸²ä¸ºï¼šâ€ the sky is blue  â€œ\n\nç§»é™¤å¤šä½™ç©ºæ ¼ : â€œthe sky is blueâ€\nå­—ç¬¦ä¸²åè½¬ï¼šâ€eulb si yks ehtâ€\nå•è¯åè½¬ï¼šâ€blue is sky theâ€\n\nè¿™æ ·ç©ºé—´å¤æ‚åº¦ä¸º O(1)ï¼Œä½†æ˜¯ python çš„ string ä¸æ”¯æŒä¿®æ”¹ï¼Œæ‰€ä»¥å¯ä»¥å°†å­—ç¬¦ä¸²è½¬æ¢ä¸º list æ¥è¿›è¡Œæ“ä½œã€‚\nå³æ—‹å­—ç¬¦ä¸²\nlink\n\nå­—ç¬¦ä¸²çš„å³æ—‹è½¬æ“ä½œæ˜¯æŠŠå­—ç¬¦ä¸²å°¾éƒ¨çš„è‹¥å¹²ä¸ªå­—ç¬¦è½¬ç§»åˆ°å­—ç¬¦ä¸²çš„å‰é¢ã€‚ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² s å’Œä¸€ä¸ªæ­£æ•´æ•° kï¼Œè¯·ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå°†å­—ç¬¦ä¸²ä¸­çš„åé¢ k ä¸ªå­—ç¬¦ç§»åˆ°å­—ç¬¦ä¸²çš„å‰é¢ï¼Œå®ç°å­—ç¬¦ä¸²çš„å³æ—‹è½¬æ“ä½œã€‚ \nä¾‹å¦‚ï¼Œå¯¹äºè¾“å…¥å­—ç¬¦ä¸² â€œabcdefgâ€ å’Œæ•´æ•° 2ï¼Œå‡½æ•°åº”è¯¥å°†å…¶è½¬æ¢ä¸º â€œfgabcdeâ€ã€‚\næ€è·¯ç®€å•çš„æƒ³æ³•è‚¯å®šæ˜¯ç”¨ä¸€ä¸ªæ–°çš„æ•°ç»„æ¥å­˜æ”¾ç»“æœã€‚ä½†æ˜¯å¦‚æœè¦æ±‚åœ¨åŸæœ‰çš„æ•°ç»„åŸºç¡€ä¸Šè¿›è¡Œä¿®æ”¹ï¼Œå¯ä»¥å‚è€ƒä¸Šä¸€é¢˜ä½¿ç”¨æ•´ä½“åè½¬+å±€éƒ¨åè½¬å°±å¯ä»¥å®ç°åè½¬å•è¯é¡ºåºçš„æ€æƒ³ã€‚å¦‚å›¾æ‰€ç¤ºï¼š\n\nå…¶å®ï¼Œæ€è·¯å°±æ˜¯ é€šè¿‡ æ•´ä½“å€’å™ï¼ŒæŠŠä¸¤æ®µå­ä¸²é¡ºåºé¢ å€’ï¼Œä¸¤ä¸ªæ®µå­ä¸²é‡Œçš„çš„å­—ç¬¦åœ¨å€’å™ä¸€æŠŠï¼Œè´Ÿè´Ÿå¾—æ­£ï¼Œè¿™æ ·å°±ä¸å½±å“å­ä¸²é‡Œé¢å­—ç¬¦çš„é¡ºåºäº†ã€‚\n","categories":["Leetcode"],"tags":["string"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘å­—ç¬¦ä¸²2-KMPç®—æ³•","url":"/blog/Leetcode/string2/","content":"KMP ç®—æ³•KMPæœ‰ä»€ä¹ˆç”¨KMPçš„ç»å…¸æ€æƒ³å°±æ˜¯:å½“å‡ºç°å­—ç¬¦ä¸²ä¸åŒ¹é…æ—¶ï¼Œå¯ä»¥è®°å½•ä¸€éƒ¨åˆ†ä¹‹å‰å·²ç»åŒ¹é…çš„æ–‡æœ¬å†…å®¹ï¼Œåˆ©ç”¨è¿™äº›ä¿¡æ¯é¿å…ä»å¤´å†å»åšåŒ¹é…ã€‚æ‰€ä»¥å¦‚ä½•è®°å½•å·²ç»åŒ¹é…çš„æ–‡æœ¬å†…å®¹ï¼Œæ˜¯KMPçš„é‡ç‚¹ï¼Œä¹Ÿæ˜¯nextæ•°ç»„è‚©è´Ÿçš„é‡ä»»ã€‚\nnextæ•°ç»„å°±æ˜¯ä¸€ä¸ªå‰ç¼€è¡¨ï¼ˆprefix tableï¼‰ã€‚å‰ç¼€è¡¨æ˜¯ç”¨æ¥å›é€€çš„ï¼Œå®ƒè®°å½•äº†æ¨¡å¼ä¸²ä¸ä¸»ä¸²(æ–‡æœ¬ä¸²)ä¸åŒ¹é…çš„æ—¶å€™ï¼Œæ¨¡å¼ä¸²åº”è¯¥ä»å“ªé‡Œå¼€å§‹é‡æ–°åŒ¹é…ã€‚\nä¾‹å­ï¼šè¦åœ¨æ–‡æœ¬ä¸²ï¼šaabaabaafa ä¸­æŸ¥æ‰¾æ˜¯å¦å‡ºç°è¿‡ä¸€ä¸ªæ¨¡å¼ä¸²ï¼šaabaafã€‚\n\nå¯ä»¥çœ‹å‡ºï¼Œæ–‡æœ¬ä¸²ä¸­ç¬¬å…­ä¸ªå­—ç¬¦b å’Œ æ¨¡å¼ä¸²çš„ç¬¬å…­ä¸ªå­—ç¬¦fï¼Œä¸åŒ¹é…äº†ã€‚å¦‚æœæš´åŠ›åŒ¹é…ï¼Œå‘ç°ä¸åŒ¹é…ï¼Œæ­¤æ—¶å°±è¦ä»å¤´åŒ¹é…äº†ã€‚\nä½†å¦‚æœä½¿ç”¨å‰ç¼€è¡¨ï¼Œå°±ä¸ä¼šä»å¤´åŒ¹é…ï¼Œè€Œæ˜¯ä»ä¸Šæ¬¡å·²ç»åŒ¹é…çš„å†…å®¹å¼€å§‹åŒ¹é…ï¼Œæ‰¾åˆ°äº†æ¨¡å¼ä¸²ä¸­ç¬¬ä¸‰ä¸ªå­—ç¬¦bç»§ç»­å¼€å§‹åŒ¹é…ã€‚\nç†è§£ï¼šåœ¨å½“å‰å¯¹æ–‡æœ¬ä¸²å’Œæ¨¡å¼ä¸²æ£€ç´¢çš„è¿‡ç¨‹ä¸­ï¼Œè‹¥å‡ºç°äº†ä¸åŒ¹é…ï¼Œå¦‚ä½•å……åˆ†åˆ©ç”¨å·²ç»åŒ¹é…çš„éƒ¨åˆ†ã€‚åˆ°ä¸åŒ¹é…æ—¶ï¼Œæ‰¾åˆ°åŒ¹é…çš„å­—ç¬¦ä¸²ä¸­ï¼Œæœ€é•¿çš„ç›¸ç­‰çš„å‰åç¼€ã€‚ä¾‹å¦‚ä¸Šé¢çš„ä¾‹å­ï¼Œå·²ç»åŒ¹é…äº† aabaaï¼Œä¸‹ä¸€ä¸ªä¸åŒ¹é…äº†ï¼Œæ‰¾åˆ°æœ€é•¿ç›¸ç­‰çš„å‰åç¼€ä¸º aaã€‚è¿™ä¸ª aa è¡¨ç¤ºï¼š\n\næ¨¡å¼ä¸²çš„å‰ä¸¤ä¸ª aa\nåŒ¹é…äº†çš„æ–‡æœ¬ä¸²çš„åä¸¤ä¸ª aa\n\nè¿™ä¸¤ä¸ªéƒ¨åˆ†æ˜¯ç›¸ç­‰çš„ï¼Œæ‰€ä»¥è¿™ä¸¤éƒ¨åˆ†ä¸ç”¨åŒ¹é…ï¼Œç›´æ¥ä» aa çš„ä¸‹ä¸€ä¸ªå­—ç¬¦å¼€å§‹åŒ¹é…ï¼Œå¦‚å›¾æ‰€ç¤ºï¼š\n\nnext æ•°ç»„å‚è€ƒè®²è§£ bilibiliï¼Œä»¥åŠå…¶ä¸­çš„è¯„è®ºï¼š  \n\nå€Ÿè§†é¢‘ä¸­ä¾‹å­è¯´æ˜ä¸€ä¸‹ prefix_len &#x3D; nextã€prefix_len - 1ã€‘ çš„åŸå› ã€‚ä¾‹å¦‚ï¼Œä¸² A B A C A B A Bã€€ã€€ã€€ã€€ 0 1 2 3 4 5 6 7æ‰«æåˆ° 6 å·ä½çš„ A æ—¶ï¼Œæœ€é•¿å…¬å…±å‰åç¼€æ˜¯ ABAï¼›è€Œæ‰«æåˆ° 7 å·ä½çš„ B æ—¶ï¼ŒABAC å’Œ ABAB ä¸åŒ¹é…äº†ï¼Œå³åŸæ¥çš„æœ€é•¿å…¬å…±å‰åç¼€å¤±é…ã€‚è¿™æ—¶å€™æˆ‘ä»¬è¦åšçš„äº‹æƒ…å°±æ˜¯ï¼Œæ‰¾ä¸Šä¸€æ¬¡åŒ¹é…ä¸­æ¬¡é•¿çš„å…¬å…±å‰åç¼€ï¼Œçœ‹ä¸ 7 å·ä½çš„ B æ‹¼æ¥èµ·æ¥æ˜¯å¦èƒ½åŒ¹é…ã€‚è¿™æ—¶å€™ï¼Œæ³¨æ„åˆ°ä¸Šä¸€æ¬¡æ‰«æä¸­ 0 ~ 2 ä½çš„ ABA æ˜¯å’Œ 4 ~ 6 ä½çš„ ABA å®Œå…¨ç›¸åŒçš„ï¼ˆè´ªå¿ƒåŸåˆ™ä¿è¯ä¸Šæ¬¡ç»“æœä¸€å®šæ˜¯åŒ…å«å‰ä¸€ä½ç½®å­—ç¬¦çš„æœ€é•¿å…¬å…±å‰åç¼€ï¼‰ï¼Œæ‰€ä»¥è€ƒå¯Ÿä¸Šä¸€æ¬¡åŒ¹é…ä¸­æ¬¡é•¿çš„å…¬å…±å‰åç¼€ï¼Œåªèƒ½åœ¨è€ƒå¯Ÿä¸Šä¸€æ¬¡åŒ¹é…ä¸­çš„æœ€é•¿å…¬å…±å‰åç¼€ä¸­è€ƒå¯Ÿï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œåªèƒ½è€ƒå¯Ÿ ABA ä¸­æ›´çŸ­çš„ BAã€A æ˜¯å¦æ˜¯æ¬¡é•¿çš„ï¼Œè€Œè¿™ç›´æ¥åœ¨å‰é¢ä¸€ä¸ª ABA ä¸­è€ƒå¯Ÿéƒ½è¡Œï¼Œæ‰€ä»¥æˆ‘ä»¬æŠŠ ABA C ABA ä¸­ä¸­é—´éƒ¨åˆ†ï¼ˆCï¼‰å’Œåç¼€ï¼ˆABAï¼‰ç›´æ¥æŠ›å¼ƒï¼Œç­‰æ•ˆäºä¸€ä¸ªä¸² ABAï¼ˆä¹Ÿå°±æ˜¯å‰ç¼€ï¼‰ä¸ B æ‹¼æ¥æˆ ABABã€‚è¿™æ ·å†æ¥è®¡ç®—ç¬¬ 7 ä½çš„ B çš„ next å€¼ï¼Œç­‰ä»·äºè®¡ç®— ABAB ç¬¬ 3 ä½çš„ B çš„ next å€¼ã€‚prefix_len &#x3D; nextã€prefix_len - 1ã€‘ ä¹Ÿå°±æ˜¯è¿™ä¸ªç­‰æ•ˆè¿‡ç¨‹çš„ä»£ç å±•ç¤ºã€‚  \n\nnext æ•°ç»„è¡¨ç¤ºçš„å°±æ˜¯ï¼šä¸‹æ ‡iä¹‹å‰ï¼ˆåŒ…æ‹¬iï¼‰çš„å­—ç¬¦ä¸²ä¸­ï¼Œæœ‰å¤šå¤§é•¿åº¦çš„ç›¸åŒå‰ç¼€åç¼€ã€‚\n\nåœ¨æ¯”è¾ƒæ—¶æ‰¾åˆ°çš„ä¸åŒ¹é…çš„ä½ç½®ï¼Œé‚£ä¹ˆæ­¤æ—¶æˆ‘ä»¬è¦çœ‹å®ƒçš„å‰ä¸€ä¸ªå­—ç¬¦çš„å‰ç¼€è¡¨çš„æ•°å€¼æ˜¯å¤šå°‘ã€‚ç„¶åç§»åŠ¨åˆ°å‰ç¼€è¡¨æ•°å€¼å¯¹åº”çš„ä¸‹æ ‡å¤„é‡æ–°å¼€å§‹åŒ¹é…ã€‚\nå¦‚ä½•è®¡ç®— next æ•°ç»„ï¼Ÿæ ¸å¿ƒæ˜¯â€œå›é€€â€ï¼Œåˆ©ç”¨å‰é¢è®¡ç®—å¥½çš„ next æ•°ç»„æ¥ç®€åŒ–è®¡ç®—ã€‚å¯ä»¥åˆ†ä¸ºä¸‰ä¸ªæ­¥éª¤ï¼š\n\nåˆå§‹åŒ–\nå­—ç¬¦ç›¸åŒæ—¶\nå­—ç¬¦ä¸åŒæ—¶\n\nåˆå§‹åŒ–åˆå§‹åŒ–ä¸¤ä¸ªæŒ‡é’ˆï¼Œi è¡¨ç¤ºåç¼€çš„æœ«å°¾ï¼Œä» 1 å¼€å§‹ï¼›j è¡¨ç¤ºå‰ç¼€çš„æœ«å°¾ï¼ˆä¹Ÿè¡¨ç¤ºå‰ç¼€çš„é•¿åº¦ï¼‰ï¼Œä» 0 å¼€å§‹ã€‚æœ€å¼€å§‹ next[0] ä¸€å®šä¸º 0ï¼Œå› ä¸ºæ²¡æœ‰æ„ä¹‰ã€‚ç„¶å i éå† range(1, len(patt))ã€‚åˆ†åˆ«å¤„ç†ç›¸åŒå’Œä¸ç›¸åŒçš„æƒ…å†µã€‚ï¼ˆå…ˆç†è§£åé¢ä¸¤ç§æƒ…å†µï¼Œç„¶åå†ç†è§£ä¸ºä»€ä¹ˆè¿™æ ·åˆå§‹åŒ–ï¼‰\nå­—ç¬¦ç›¸åŒä¾‹å¦‚ï¼Œå·²ç»æ‰¾åˆ°äº†å½“å‰æœ€é•¿çš„ç›¸åŒå‰åç¼€ä¸º ABï¼Œæ­¤æ—¶ j&#x3D;1ï¼ˆBï¼‰ï¼Œi&#x3D;5ï¼ˆBï¼‰ã€‚åœ¨ä¸‹ä¸€è½®ï¼Œæˆ‘ä»¬åªéœ€è¦åˆ¤æ–­ä¸‹ä¸€ä¸ªå­—ç¬¦æ˜¯å¦ç›¸åŒï¼Œå³ j&#x3D;2ï¼ˆAï¼‰ï¼Œi&#x3D;6ï¼ˆBï¼‰ï¼Œæ­¤æ—¶ç›¸åŒï¼Œé‚£ä¹ˆå°±å¯ä»¥ç›´æ¥å°†å‰ç¼€é•¿åº¦ jï¼ˆä¹Ÿç­‰äº next[i-1]ï¼Œä½†æ˜¯ä¸ºäº†ç»Ÿä¸€è¡¨è¾¾ï¼Œè¿˜æ˜¯ä½¿ç”¨ jï¼Œè¯¦è§ä¸‹é¢çš„æƒ…å†µï¼‰ åŠ ä¸€ä½œä¸ºå½“å‰çš„ next[i]ã€‚\nå­—ç¬¦ä¸åŒä¸Šä¸€æ­¥å·²ç»æ‰¾åˆ°æœ€é•¿çš„ç›¸åŒå‰åç¼€ä¸º ABAï¼Œä½†æ˜¯ä¸‹ä¸€ä¸ªå­—ç¬¦ä¸ç›¸åŒã€‚æ­¤æ—¶è¦åšçš„äº‹æƒ…æ˜¯ï¼Œæ‰¾ä¸Šä¸€æ¬¡åŒ¹é…ä¸­æ¬¡é•¿çš„ç›¸åŒå‰åç¼€ï¼Œçœ‹ä¸ i&#x3D;7 çš„ B æ‹¼æ¥èµ·æ¥æ˜¯å¦èƒ½åŒ¹é…ï¼ˆå› ä¸ºè¦ä½¿ç”¨ä¹‹å‰è®¡ç®—çš„ next æ•°ç»„ï¼Œæœ€é•¿çš„ä¸ç¬¦åˆå°±æ‰¾æ¬¡é•¿çš„ï¼‰ã€‚\nè€Œæ‰¾æ¬¡é•¿çš„ç›¸åŒå‰åç¼€ï¼Œç­‰ä»·ä»¥å½“å‰æœ€é•¿çš„ç›¸åŒå‰åç¼€ä¸ºå¯¹è±¡ï¼Œæ‰¾æœ€é•¿çš„ç›¸åŒå‰åç¼€ã€‚ï¼ˆä¹Ÿå°±æ˜¯å°† ABA çœ‹ä½œå•ç‹¬çš„å­—ç¬¦ä¸²ï¼Œæ‰¾ ABA çš„æœ€é•¿ç›¸åŒå­å­—ç¬¦ä¸²ï¼‰ã€‚å› ä¸ºæ¬¡é•¿çš„ç›¸åŒå‰åç¼€ä¸€å®šåœ¨æœ€é•¿çš„å‰åç¼€ä¸­ï¼ˆè´ªå¿ƒåŸåˆ™ï¼Œæ¯æ¬¡éƒ½æ˜¯åœ¨ä¸Šä¸€è½®æœ€é•¿å‰åç¼€çš„åŸºç¡€ä¸Šæ‰©å±•ï¼‰ã€‚\nè€Œ ABA çš„æœ€é•¿ç›¸åŒå‰åç¼€åœ¨ä¹‹å‰å·²ç»è®¡ç®—å¥½äº†ï¼Œä¸º next[j-1]ï¼ˆæ­¤æ—¶ j&#x3D;3ï¼‰ï¼ˆå·¦å›¾ï¼‰ã€‚æ‰€ä»¥ j å°±å›é€€åˆ°æ¬¡é•¿çš„ç›¸åŒå‰åç¼€å¤„ï¼ˆå›é€€å j&#x3D;1ï¼‰ï¼Œå†æ¬¡è¿›è¡Œæ¯”è¾ƒï¼ˆä¸­å›¾ï¼‰ã€‚æ­¤æ—¶å­—ç¬¦ç›¸åŒï¼Œå°±å¯ä»¥ç›´æ¥å°†å‰ç¼€é•¿åº¦ j åŠ ä¸€ä½œä¸ºå½“å‰çš„ next[i]ï¼ˆå³å›¾ï¼Œæ³¨æ„ï¼Œæ­¤æ—¶å°±ä¸èƒ½å†åƒä¸Šé¢é‚£ä¸ªæƒ…å†µä¸€æ ·ï¼Œä½¿ç”¨ next[i-1] æ¥èµ‹å€¼ï¼‰ã€‚\n\nè®¡ç®— next æ•°ç»„åœ¨éå† i æ—¶ï¼Œæ³¨æ„ for å’Œ while å¾ªç¯çš„ä¸åŒå†™æ³•ã€‚å› ä¸ºåœ¨å­—ç¬¦ä¸ç›¸åŒæ—¶ï¼Œj éœ€è¦å›é€€åˆ°æ¬¡é•¿ç›¸åŒå‰åç¼€çš„ä½ç½®æ¥å†æ¬¡æ¯”è¾ƒï¼Œå¦‚æœè¿˜æ˜¯ä¸ç›¸åŒè¿˜éœ€è¦å›é€€ã€‚æ‰€ä»¥ i çš„å€¼éœ€è¦æ‰‹åŠ¨æ§åˆ¶ï¼ˆä½¿ç”¨ while å¾ªç¯ï¼‰æˆ–è€…å¯¹å½“å‰ i è¿›è¡Œå¤šæ¬¡æ¯”è¾ƒï¼ˆfor å¾ªç¯ä¸­å†å¥—ä¸€å±‚ whileï¼‰ã€‚ä»£ç å¦‚ä¸‹ï¼š\ni = 1j = 0next = [0] * len(patt)while i &lt; len(patt):    if patt[i] == patt[j]:        next[i] = j + 1        j += 1        i += 1    else:        if j == 0:            next[i] = j            i += 1        else:            j = next[j - 1]\n\nj = 0next = [0] * len(patt)for i in range(1, len(patt)):    while j &gt; 0 and patt[i] != patt[j]:        j = next[j-1]    if patt[i] == patt[j]:        j += 1        next[i] = j\n\n28. å®ç° strStr()\nlink\n\nç»™ä½ ä¸¤ä¸ªå­—ç¬¦ä¸² haystack å’Œ needle ï¼Œè¯·ä½ åœ¨ haystack å­—ç¬¦ä¸²ä¸­æ‰¾å‡º needle å­—ç¬¦ä¸²çš„ç¬¬ä¸€ä¸ªåŒ¹é…é¡¹çš„ä¸‹æ ‡ï¼ˆä¸‹æ ‡ä» 0 å¼€å§‹ï¼‰ã€‚å¦‚æœ needle ä¸æ˜¯ haystack çš„ä¸€éƒ¨åˆ†ï¼Œåˆ™è¿”å›  -1 ã€‚\nç¤ºä¾‹ 1ï¼š\n\nè¾“å…¥ï¼šhaystack &#x3D; â€œsadbutsadâ€, needle &#x3D; â€œsadâ€è¾“å‡ºï¼š0è§£é‡Šï¼šâ€sadâ€ åœ¨ä¸‹æ ‡ 0 å’Œ 6 å¤„åŒ¹é…ã€‚ç¬¬ä¸€ä¸ªåŒ¹é…é¡¹çš„ä¸‹æ ‡æ˜¯ 0 ï¼Œæ‰€ä»¥è¿”å› 0 ã€‚\n\nç¤ºä¾‹ 2ï¼š\n\nè¾“å…¥ï¼šhaystack &#x3D; â€œleetcodeâ€, needle &#x3D; â€œleetoâ€è¾“å‡ºï¼š-1è§£é‡Šï¼šâ€leetoâ€ æ²¡æœ‰åœ¨ â€œleetcodeâ€ ä¸­å‡ºç°ï¼Œæ‰€ä»¥è¿”å› -1 ã€‚  \n\næ€è·¯KMP ç®—æ³•çš„åº”ç”¨ï¼Œè®¡ç®—å®Œ next æ•°ç»„åï¼Œå°±éœ€è¦è¿›è¡ŒåŒ¹é…ã€‚ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆï¼Œåˆ†åˆ«åœ¨æ–‡æœ¬ä¸²å’Œæ¨¡å¼ä¸²ä¸Šç§»åŠ¨ï¼Œå½“ä¸åŒ¹é…æ—¶ï¼Œæ¨¡å¼ä¸²ä¸Šçš„æŒ‡é’ˆ j å°±å›é€€åˆ°å‰ä¸€ä½å¯¹åº”çš„ next æ•°ç»„çš„å€¼å¤„ï¼Œå³ j &#x3D; next[j-1]ã€‚ï¼ˆä»è¿™é‡Œä¹Ÿå¯ä»¥çœ‹å‡ºï¼Œè®¡ç®— next æ•°ç»„æœ¬è´¨ä¸Šä¹Ÿæ˜¯ KMP ç®—æ³•ï¼ï¼‰\næ³¨æ„ä¸¤ç§å†™æ³•çš„è¿”å›å€¼ä¸ä¸€æ ·ï¼\nfor å†™æ³•ï¼ši æ˜¯åœ¨æ¯æ¬¡å¾ªç¯å¼€å§‹æ‰å¢åŠ ï¼Œåœ¨å¾ªç¯ä¸­ï¼Œj å…ˆå¢åŠ ï¼Œæ‰€ä»¥åˆ¤æ–­æ˜¯å¦éå†åˆ°æ¨¡å¼ä¸²æœ«å°¾æ—¶ï¼Œåªæœ‰ j å¢åŠ äº†ï¼Œæ‰€ä»¥è¿”å›éœ€è¦åŠ  1ã€‚\nclass Solution:    def strStr(self, haystack: str, needle: str) -&gt; int:        j = 0        next = [0] * len(needle)        for i in range(1, len(needle)):            while j &gt; 0 and needle[i] != needle[j]:                j = next[j-1]            if needle[i] == needle[j]:                j += 1                        next[i] = j                j = 0        i = 0        for i in range(len(haystack)):            while j &gt; 0 and haystack[i] != needle[j]:                j = next[j-1]            if haystack[i] == needle[j]:                j += 1            if j == len(needle):                return i - j + 1    return -1\n\nwhile å†™æ³•ï¼šwhile å¾ªç¯æ˜¯æˆ‘ä»¬è‡ªå·±æ§åˆ¶ i å’Œ j çš„å¢å‡ï¼Œæ‰€ä»¥å¦‚æœæ»¡è¶³æ¡ä»¶ï¼Œä»–ä»¬æ˜¯åŒæ—¶å¢åŠ çš„ã€‚æ‰€ä»¥åˆ¤æ–­æ˜¯å¦éå†åˆ°æ¨¡å¼ä¸²æœ«å°¾æ—¶ï¼Œä¸éœ€è¦åŠ  1ã€‚\nclass Solution:    def strStr(self, haystack: str, needle: str) -&gt; int:        j = 0        next = [0] * len(needle)        for i in range(1, len(needle)):            while j &gt; 0 and needle[i] != needle[j]:                j = next[j-1]            if needle[i] == needle[j]:                j += 1                        next[i] = j                j = 0        i = 0                    while i &lt; len(haystack):            if haystack[i] == needle[j]:                j += 1                i += 1            else:                if j == 0:                    i += 1                else:                    j = next[j-1]            if j == len(needle):                return i - j         return -1\n\n459. é‡å¤çš„å­å­—ç¬¦ä¸²\nlink\n\nç»™å®šä¸€ä¸ªéç©ºçš„å­—ç¬¦ä¸² s ï¼Œæ£€æŸ¥æ˜¯å¦å¯ä»¥é€šè¿‡ç”±å®ƒçš„ä¸€ä¸ªå­ä¸²é‡å¤å¤šæ¬¡æ„æˆã€‚\nç¤ºä¾‹ 1:\n\nè¾“å…¥: s &#x3D; â€œababâ€è¾“å‡º: trueè§£é‡Š: å¯ç”±å­ä¸² â€œabâ€ é‡å¤ä¸¤æ¬¡æ„æˆã€‚  \n\nç¤ºä¾‹ 2:\n\nè¾“å…¥: s &#x3D; â€œabaâ€è¾“å‡º: false  \n\næ€è·¯ 1å¯¹æ¯ä¸ªå­ä¸²éƒ½åº”ç”¨ KMP ç®—æ³•ï¼Œä¼˜åŒ–çš„ç‚¹ï¼š\n\nä¼ å…¥çš„ haystack ä¸²å¯ä»¥å»é™¤é€‰æ‹©çš„å­ä¸²\néå†å­ä¸²çš„æ—¶å€™ï¼Œå¦‚æœå‰©ä½™é•¿åº¦å°äºå­ä¸²é•¿åº¦ï¼Œåˆ™è·³è¿‡\nreturn çš„æ—¶æœºï¼š  \nä¸ç›¸ç­‰ç›´æ¥ return False\nä¸¤ä¸ªæŒ‡é’ˆåŒæ—¶æŒ‡å‘å„è‡ªå­—ç¬¦ä¸²çš„æœ«å°¾\n\n\n\nä½†æ˜¯ä¼šè¶…å‡ºæ—¶é—´é™åˆ¶\nclass Solution:    def kmp(self, haystack, needle):        j = 0        next = [0] * len(needle)        for i in range(1, len(needle)):            while j &gt; 0 and needle[i] != needle[j]:                j = next[j-1]            if needle[i] == needle[j]:                j += 1                        next[i] = j                j = 0        i = 0                    while i &lt; len(haystack):            if haystack[i] == needle[j]:                j += 1                i += 1            else:                return False            if j == len(needle):                if i == len(haystack):                    return True                else:                    j = 0    def repeatedSubstringPattern(self, s: str) -&gt; bool:        for i in range(len(s)):            left = len(s) - i - 1            if left &lt; i + 1:                return False                        if self.kmp(s[i+1:], s[0:i+1]):                return True        \næ€è·¯ 2ï¼šæš´åŠ›ä¸€ä¸ªforå¾ªç¯è·å– å­ä¸²çš„ç»ˆæ­¢ä½ç½®ï¼Œ ç„¶ååˆ¤æ–­å­ä¸²æ˜¯å¦èƒ½é‡å¤æ„æˆå­—ç¬¦ä¸²ï¼ŒåˆåµŒå¥—ä¸€ä¸ªforå¾ªç¯ï¼Œæ‰€ä»¥æ˜¯O(n^2)çš„æ—¶é—´å¤æ‚åº¦ã€‚\næ€è·¯ 3ï¼šç§»åŠ¨åŒ¹é…å¦‚æœä¸€ä¸ªå­—ç¬¦ä¸² s ç”±å­ä¸²æ„æˆï¼Œé‚£ä¹ˆ s+s å»æ‰é¦–å°¾ä¹‹åä¸€å®šåŒ…å« sã€‚\néœ€è¦è¯æ˜å……è¦æ€§:ï¼ˆï¼Ÿï¼‰\n\nsÂ å¯ç”±æŸä¸ªéç©ºå­ä¸²é‡å¤Â kâ‰¥2Â æ¬¡æ„æˆ &lt;â€“&gt; sÂ æ˜¯Â (s+s)[1:âˆ’1]Â çš„ä¸€ä¸ªå­ä¸².\n\nå¯ä»¥ç›´æ¥ç”¨ inï¼Œä¹Ÿå¯ä»¥ç”¨ KMP å®ç°çš„ strStr()ã€‚\nclass Solution:    def strStr(self, haystack: str, needle: str) -&gt; int:        j = 0        next = [0] * len(needle)        for i in range(1, len(needle)):            while j &gt; 0 and needle[i] != needle[j]:                j = next[j-1]            if needle[i] == needle[j]:                j += 1                        next[i] = j                j = 0        i = 0                    while i &lt; len(haystack):            if haystack[i] == needle[j]:                j += 1                i += 1            else:                if j == 0:                    i += 1                else:                    j = next[j-1]            if j == len(needle):                return True        return False    def repeatedSubstringPattern(self, s: str) -&gt; bool:                ss = s + s        return self.strStr(ss[1:-1], s)\n\næ€è·¯ 4ï¼šKMPåœ¨ä¸€ä¸ªä¸²ä¸­æŸ¥æ‰¾æ˜¯å¦å‡ºç°è¿‡å¦ä¸€ä¸ªä¸²ï¼Œè¿™æ˜¯KMPçš„çœ‹å®¶æœ¬é¢†ã€‚KMPç®—æ³•ä¸­nextæ•°ç»„ä¸ºä»€ä¹ˆé‡åˆ°å­—ç¬¦ä¸åŒ¹é…çš„æ—¶å€™å¯ä»¥æ‰¾åˆ°ä¸Šä¸€ä¸ªåŒ¹é…è¿‡çš„ä½ç½®ç»§ç»­åŒ¹é…ï¼Œé çš„æ˜¯æœ‰è®¡ç®—å¥½çš„å‰ç¼€è¡¨ã€‚å‰ç¼€è¡¨é‡Œï¼Œç»Ÿè®¡äº†å„ä¸ªä½ç½®ä¸ºç»ˆç‚¹å­—ç¬¦ä¸²çš„æœ€é•¿ç›¸åŒå‰åç¼€çš„é•¿åº¦ã€‚é‚£ä¹ˆ æœ€é•¿ç›¸åŒå‰åç¼€å’Œé‡å¤å­ä¸²çš„å…³ç³»åˆæœ‰ä»€ä¹ˆå…³ç³»å‘¢ï¼Ÿ\nå­—ç¬¦ä¸²sæ˜¯ç”±é‡å¤å­ä¸²ç»„æˆ &lt;&#x3D;&#x3D;&#x3D;&gt; æœ€é•¿ç›¸ç­‰å‰åç¼€ä¸åŒ…å«çš„å­ä¸²æ˜¯å­—ç¬¦ä¸²sçš„æœ€å°é‡å¤å­ä¸²\n","categories":["Leetcode"],"tags":["string"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘äºŒå‰æ ‘3-å±æ€§2","url":"/blog/Leetcode/tree3/","content":"257. äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„\nlink\n\nç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼ŒæŒ‰ ä»»æ„é¡ºåº ï¼Œè¿”å›æ‰€æœ‰ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ã€‚å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚\næ€è·¯è¦ä»æ ¹èŠ‚ç‚¹å‡ºå‘ï¼Œè®°å½•è·¯å¾„ï¼Œä¸€ç›´èµ°åˆ°å¶å­èŠ‚ç‚¹ï¼ŒæŠŠè¿™æ¡è·¯å¾„è®°å½•ä¸‹æ¥ã€‚å¿…é¡»å…ˆè®¿é—®æ ¹èŠ‚ç‚¹ï¼Œæ‰€ä»¥åªèƒ½ç”¨å‰åºéå†ã€‚æ¶‰åŠåˆ°å›æº¯ï¼Œå› ä¸ºæˆ‘ä»¬è¦æŠŠè·¯å¾„è®°å½•ä¸‹æ¥ï¼Œéœ€è¦å›æº¯æ¥å›é€€ä¸€ä¸ªè·¯å¾„å†è¿›å…¥å¦ä¸€ä¸ªè·¯å¾„ã€‚\né€’å½’æ³•(DFS)é€»è¾‘\n\næŠŠå½“å‰èŠ‚ç‚¹çš„å€¼åŠ å…¥è·¯å¾„ä¸­ \nå¦‚æœæ˜¯å¶å­èŠ‚ç‚¹ï¼Œå°±æŠŠè·¯å¾„åŠ å…¥ç»“æœé›†\nå¦åˆ™ç»§ç»­é€’å½’å·¦å³å­æ ‘\nå›æº¯æ—¶ï¼ŒæŠŠè·¯å¾„ä¸­å½“å‰èŠ‚ç‚¹çš„å€¼å¼¹å‡ºï¼Œå›é€€åˆ°ä¸Šä¸€æ­¥\n\nclass Solution:    def binaryTreePaths(self, root: Optional[TreeNode]) -&gt; List[str]:        res = []        path = []        def treverse(node):            path.append(str(node.val))            if node.left == None and node.right == None:                res.append(&quot;-&gt;&quot;.join(path))            if node.left:                treverse(node.left)            if node.right:                treverse(node.right)                        path.pop()                if root !=None:            treverse(root)        return res\n\nBFSå±‚åºéå†ï¼Œé˜Ÿåˆ—ä¸­ç›´æ¥å­˜å‚¨å½“å‰èŠ‚ç‚¹ä»¥åŠå…¶å¯¹åº”çš„è·¯å¾„\nclass Solution:    def binaryTreePaths(self, root: Optional[TreeNode]) -&gt; List[str]:        res = []        que = deque()        if root != None:            que.append((root, [str(root.val)]))        while que:            cur, path = que.popleft()            if cur.left == None and cur.right == None:                res.append(&quot;-&gt;&quot;.join(path))            if cur.left:                que.append((cur.left, path + [str(cur.left.val)]))            if cur.right:                que.append((cur.right, path + [str(cur.right.val)]))        return res\n\næ³¨æ„ï¼Œä¸Šè¿°ä»£ç ä¸­ï¼Œå…¥é˜Ÿæ—¶ä¸èƒ½ä½¿ç”¨ appendï¼Œå› ä¸ºå¦‚æœå·¦å³èŠ‚ç‚¹éƒ½å­˜åœ¨ï¼Œé‚£ä¹ˆä¼šé”™è¯¯æ·»åŠ å…ƒç´ \n404.å·¦å¶å­ä¹‹å’Œ\nlink\n\n\n\nè¾“å…¥: root &#x3D; [3,9,20,null,null,15,7]è¾“å‡º: 24è§£é‡Š: åœ¨è¿™ä¸ªäºŒå‰æ ‘ä¸­ï¼Œæœ‰ä¸¤ä¸ªå·¦å¶å­ï¼Œåˆ†åˆ«æ˜¯ 9 å’Œ 15ï¼Œæ‰€ä»¥è¿”å› 24  \n\næ€è·¯dfs éå†è¯¥æ ‘ï¼Œé‡åˆ°å·¦èŠ‚ç‚¹ä¸ºå¶å­èŠ‚ç‚¹å°±è®°å½•å…¶æ•°å€¼ï¼Œå¦åˆ™éå†å…¶å­æ ‘ã€‚æ³¨æ„è¿™é‡Œå†™æˆäº† res &#x3D; [0]ï¼Œä¸å†™ res&#x3D;0 æ˜¯å› ä¸ºåœ¨å‡½æ•°å†…éƒ¨å¯¹æŸä¸ªå˜é‡èµ‹å€¼ï¼ˆå¦‚ res +&#x3D; â€¦ï¼‰ï¼ŒPython ä¼šé»˜è®¤æŠŠè¿™ä¸ªå˜é‡å½“ä½œå‡½æ•°çš„å±€éƒ¨å˜é‡ã€‚\nclass Solution:    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -&gt; int:        res = [0]  # âœ… ä½¿ç”¨ list åŒ…è£…æˆå¯å˜å¯¹è±¡        def dfs(node):            if node.left:                # å¦‚æœå·¦å­©å­æ˜¯å¶å­èŠ‚ç‚¹æ‰åŠ                 if not node.left.left and not node.left.right:                    res[0] += node.left.val                else:                    dfs(node.left)            if node.right:                dfs(node.right)        if root:            dfs(root)        return res[0]\n\n513.æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼\nlink\n\nç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„ æ ¹èŠ‚ç‚¹ rootï¼Œè¯·æ‰¾å‡ºè¯¥äºŒå‰æ ‘çš„ æœ€åº•å±‚ æœ€å·¦è¾¹ èŠ‚ç‚¹çš„å€¼ã€‚\næ€è·¯å±‚åºéå†ï¼Œå–æœ€åä¸€å±‚çš„ç¬¬ä¸€ä¸ªç»“æœ\nclass Solution:    def findBottomLeftValue(self, root: Optional[TreeNode]) -&gt; int:        res = []        que = deque()        que.append(root)        while que:            cur_level = []            for _ in range(len(que)):                                cur = que.popleft()                cur_level.append(cur.val)                if cur.left:                    que.append(cur.left)                if cur.right:                    que.append(cur.right)                                        res.append(cur_level)                return res[-1][0]\n112. è·¯å¾„æ€»å’Œ\nlink\n\nç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root å’Œä¸€ä¸ªè¡¨ç¤ºç›®æ ‡å’Œçš„æ•´æ•° targetSum ã€‚åˆ¤æ–­è¯¥æ ‘ä¸­æ˜¯å¦å­˜åœ¨ æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹ çš„è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹å€¼ç›¸åŠ ç­‰äºç›®æ ‡å’Œ targetSum ã€‚å¦‚æœå­˜åœ¨ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚\næ€è·¯ç±»ä¼¼äº 257. äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„ï¼Œåªæ˜¯å½“è®¿é—®åˆ°å¶å­èŠ‚ç‚¹æ—¶ï¼Œå°±è®¡ç®—è·¯å¾„å’Œï¼Œåˆ¤æ–­æ˜¯å¦æ»¡è¶³æ¡ä»¶ã€‚ä½¿ç”¨ BFS è¾ƒä¸ºç®€å•ï¼Œå¯ä»¥æ›´å¥½æ§åˆ¶è¿”å›æ—¶æœºã€‚\nclass Solution:    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -&gt; bool:        que = deque()        if root:            que.append((root, [root.val]))        while que:            cur, path = que.popleft()            if cur.left == None and cur.right == None:                s = sum(path)                if s == targetSum:                    return True            if cur.left:                que.append((cur.left, path + [cur.left.val]))                        if cur.right:                que.append((cur.right, path + [cur.right.val]))                return False\n\n","categories":["Leetcode"],"tags":["tree"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘äºŒå‰æ ‘4-ä¿®æ”¹ä¸æ”¹é€ ","url":"/blog/Leetcode/tree4/","content":"226.ç¿»è½¬äºŒå‰æ ‘\nlink\n\nç¿»è½¬ä¸€é¢—äºŒå‰æ ‘\næ€è·¯å‰åºéå†æˆ–è€…åç»­éå†ï¼Œåœ¨è®¿é—®å½“å‰èŠ‚ç‚¹çš„æ—¶å€™å°±ç¿»è½¬èŠ‚ç‚¹çš„ä¸¤ä¸ªå­æ ‘ã€‚\né€’å½’å†™æ³•\nclass Solution:    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:        def treverse(node):            if node != None:                temp = node.right                node.right = node.left                node.left = temp                treverse(node.left)                treverse(node.right)                treverse(root)        return root\n\nè¿­ä»£å†™æ³•ï¼ˆç»Ÿä¸€çš„æ€è·¯ï¼‰\nclass Solution:    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:                stack = []        if root != None:            stack.append(root)                while stack:            cur = stack.pop()            if cur != None:                # å³èŠ‚ç‚¹å…¥æ ˆ                if cur.right:                    stack.append(cur.right)                # å·¦èŠ‚ç‚¹å…¥æ ˆ                if cur.left:                    stack.append(cur.left)                # ä¸­é—´èŠ‚ç‚¹å…¥æ ˆ                stack.append(cur)                stack.append(None)            else:                cur = stack.pop()                temp = cur.left                cur.left = cur.right                cur.right = temp        return root\n\n106.ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘\nlink\n\nç»™å®šä¸¤ä¸ªæ•´æ•°æ•°ç»„ inorder å’Œ postorder ï¼Œå…¶ä¸­ inorder æ˜¯äºŒå‰æ ‘çš„ä¸­åºéå†ï¼Œ postorder æ˜¯åŒä¸€æ£µæ ‘çš„ååºéå†ï¼Œè¯·ä½ æ„é€ å¹¶è¿”å›è¿™é¢— äºŒå‰æ ‘ ã€‚\næ€è·¯æ˜ç¡®ï¼š\n\nååºéå†çš„æ€§è´¨ï¼šååºéå†çš„æœ€åä¸€ä¸ªå…ƒç´ ä¸€å®šæ˜¯æ•´æ£µæ ‘çš„æ ¹èŠ‚ç‚¹ã€‚å³ postorder &#x3D; [å·¦å­æ ‘â€¦, å³å­æ ‘â€¦, æ ¹]\nä¸­åºéå†çš„æ€§è´¨ï¼šåœ¨ä¸­åºéå†ä¸­ï¼Œæ ¹èŠ‚ç‚¹å·¦è¾¹çš„å…ƒç´ æ˜¯å·¦å­æ ‘ï¼Œå³è¾¹çš„æ˜¯å³å­æ ‘ã€‚\n\nè¿‡ç¨‹å¦‚ä¸‹ï¼š\n\nä»ååºéå†ä¸­å–å‡ºæœ€åä¸€ä¸ªå…ƒç´ ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼›\nåœ¨ä¸­åºéå†ä¸­æ‰¾åˆ°è¿™ä¸ªæ ¹èŠ‚ç‚¹çš„ä½ç½®ï¼›\né€’å½’æ„å»ºå·¦å³å­æ ‘ï¼š\nä¸­åºå·¦è¾¹éƒ¨åˆ† â†’ å·¦å­æ ‘\nä¸­åºå³è¾¹éƒ¨åˆ† â†’ å³å­æ ‘\nååºä¸­è¦å¯¹åº”åˆ†æˆå·¦å­æ ‘å’Œå³å­æ ‘çš„åŒºé—´\n\n\n\n\næ³¨æ„åœ¨é€’å½’ä¸­ï¼Œè¦ä¼˜å…ˆå¤„ç†å³å­æ ‘ï¼Œå› ä¸ºå³å­æ ‘æ›´é è¿‘æ ¹èŠ‚ç‚¹ï¼Œéœ€è¦å…ˆ popï¼ˆä½†æ˜¯ä¸ºä»€ä¹ˆä¸éœ€è¦æ‰‹åŠ¨åˆ‡ç‰‡ï¼Ÿè¿™é‡Œçš„ posto ä¸æ˜¯å±€éƒ¨å˜é‡å—ï¼Ÿï¼‰\nclass Solution:    def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; Optional[TreeNode]:                def make(ino, posto):            if not ino or not posto:                return None            val = posto.pop()            index = ino.index(val)            root = TreeNode(val)            subinleft = ino[0:index]            subinright = ino[index+1:]            root.right = make(subinright, posto)            root.left = make(subinleft, posto)            return root        return make(inorder, postorder)        \n\n\n105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘\nlink\n\nç±»ä¼¼äºä¸Šä¸€é¢˜ï¼Œåªä¸è¿‡ç”±äºå‰åºéå†æ˜¯æ ¹èŠ‚ç‚¹åœ¨ç´¢å¼• 0ï¼Œæ— æ³•åŠ¨æ€æ›´æ–°æ•°ç»„ï¼Œæ‰€ä»¥éœ€è¦è¿›è¡Œæ‰‹åŠ¨åˆ‡ç‰‡ï¼Œæ­¤æ—¶å°±ä¸éœ€è¦åœ¨ä¹å…ˆå¤„ç†å“ªä¸ªå­æ ‘äº†ï¼Œå› ä¸ºå·²ç»æ˜¾ç¤ºåœ°æŒ‡å®šã€‚ä¸Šä¸€é¢˜éœ€è¦å…ˆå¤„ç†å³å­æ ‘ï¼Œæ˜¯å› ä¸ºéœ€è¦åœ¨é€’å½’çš„è¿‡ç¨‹ä¸­å¤šæ¬¡ä¿®æ”¹ posto æ•°ç»„ã€‚\nclass Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:        def make(ino, posto):            if not ino or not posto:                return None            val = posto[0]            index = ino.index(val)            root = TreeNode(val)            subinleft = ino[0:index]            subinright = ino[index+1:]            root.left = make(subinleft, posto[1:len(subinleft)+1])            root.right = make(subinright, posto[len(subinleft)+1:])            return root        return make(inorder, preorder)\nå°æ€»ç»“\nå‰åºå’Œä¸­åºå¯ä»¥å”¯ä¸€ç¡®å®šä¸€æ£µäºŒå‰æ ‘ã€‚\nååºå’Œä¸­åºå¯ä»¥å”¯ä¸€ç¡®å®šä¸€æ£µäºŒå‰æ ‘ã€‚\nä½†æ˜¯å‰åºå’Œååºä¸èƒ½å”¯ä¸€ç¡®å®šä¸€æ£µäºŒå‰æ ‘ï¼\n\nå› ä¸ºæ— æ³•ç¡®å®šæ ¹èŠ‚ç‚¹ï¼Œå°±æ— æ³•è¿›è¡Œåˆ†å‰²\n654.æœ€å¤§äºŒå‰æ ‘\nlink\n\nç»™å®šä¸€ä¸ªä¸é‡å¤çš„æ•´æ•°æ•°ç»„ nums ã€‚ æœ€å¤§äºŒå‰æ ‘ å¯ä»¥ç”¨ä¸‹é¢çš„ç®—æ³•ä» nums é€’å½’åœ°æ„å»º:\n\nåˆ›å»ºä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œå…¶å€¼ä¸º nums ä¸­çš„æœ€å¤§å€¼ã€‚\né€’å½’åœ°åœ¨æœ€å¤§å€¼ å·¦è¾¹ çš„ å­æ•°ç»„å‰ç¼€ä¸Š æ„å»ºå·¦å­æ ‘ã€‚\né€’å½’åœ°åœ¨æœ€å¤§å€¼ å³è¾¹ çš„ å­æ•°ç»„åç¼€ä¸Š æ„å»ºå³å­æ ‘ã€‚\n\næ€è·¯ç±»ä¼¼äºæ„é€ äºŒå‰æ ‘ï¼Œæ€è·¯åœ¨é¢˜ç›®ä¸­å·²ç»ç»™å‡º\nclass Solution:    def constructMaximumBinaryTree(self, nums: List[int]) -&gt; Optional[TreeNode]:                def make(num_list):            if not num_list:                return None            max_num = max(num_list)            index = num_list.index(max_num)            root = TreeNode(max_num)            root.left = make(num_list[:index])            root.right = make(num_list[index+1:])            return root                return make(nums)\n\n617.åˆå¹¶äºŒå‰æ ‘\nlink\n\nåŒæ—¶éå†ä¸¤é¢—æ ‘å³å¯ã€‚æ³¨æ„é€’å½’çš„ä¸»é€»è¾‘åˆ¤æ–­ï¼Œå½“ä¸€ä¸ªèŠ‚ç‚¹ä¸ºç©ºæ—¶ï¼Œç›´æ¥è¿”å›å¦ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä¸ç”¨è€ƒè™‘å¦ä¸€ä¸ªèŠ‚ç‚¹æ˜¯å¦ä¸ºç©ºã€‚åªæœ‰ä¸¤ä¸ªèŠ‚ç‚¹éƒ½ä¸ä¸ºç©ºçš„æ—¶å€™æ‰éœ€è¦å•ç‹¬åˆ¤æ–­ã€‚\nclass Solution:    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -&gt; Optional[TreeNode]:                def make(node1, node2):            if node1 == None:                return node2            if node2 == None:                return node1                        cur = TreeNode(node1.val + node2.val)            cur.left = make(node1.left, node2.left)            cur.right = make(node1.right, node2.right)            return cur                return make(root1, root2)\n\n","categories":["Leetcode"],"tags":["tree"]},{"title":"Pycharm debug æ–¹æ³•è®°å½•","url":"/blog/Mark/debug/","content":"Pycharm è°ƒè¯•æŒ‰é’®\nå‚è€ƒé“¾æ¥\n\n\nstep overï¼ˆF8å¿«æ·é”®ï¼‰ï¼šåœ¨å•æ­¥æ‰§è¡Œæ—¶ï¼Œåœ¨å‡½æ•°å†…é‡åˆ°å­å‡½æ•°æ—¶ä¸ä¼šè¿›å…¥å­å‡½æ•°å†…å•æ­¥æ‰§è¡Œï¼Œè€Œæ˜¯å°†å­å‡½æ•°æ•´ä¸ªæ‰§è¡Œå®Œå†åœæ­¢ï¼Œä¹Ÿå°±æ˜¯æŠŠå­å‡½æ•°æ•´ä¸ªä½œä¸ºä¸€æ­¥ã€‚åœ¨ä¸å­˜åœ¨å­å‡½æ•°çš„æƒ…å†µä¸‹æ˜¯å’Œstep intoæ•ˆæœä¸€æ ·çš„ã€‚\nstep intoï¼ˆF7å¿«æ·é”®ï¼‰ï¼šåœ¨å•æ­¥æ‰§è¡Œæ—¶ï¼Œé‡åˆ°å­å‡½æ•°å°±è¿›å…¥å¹¶ä¸”ç»§ç»­å•æ­¥æ‰§è¡Œï¼Œæœ‰çš„ä¼šè·³åˆ°æºä»£ç é‡Œé¢å»æ‰§è¡Œã€‚\nstep into my codeï¼ˆAlt+Shift+F7å¿«æ·é”®ï¼‰ï¼šåœ¨å•æ­¥æ‰§è¡Œæ—¶ï¼Œé‡åˆ°å­å‡½æ•°å°±è¿›å…¥å¹¶ä¸”ç»§ç»­å•æ­¥æ‰§è¡Œï¼Œä¸ä¼šè¿›å…¥åˆ°æºç ä¸­ã€‚\nstep outï¼ˆShift+F8å¿«æ·é”®ï¼‰ï¼šå‡å¦‚è¿›å…¥äº†ä¸€ä¸ªå‡½æ•°ä½“ä¸­ï¼Œçœ‹äº†ä¸¤è¡Œä»£ç ï¼Œä¸æƒ³çœ‹äº†ï¼Œè·³å‡ºå½“å‰å‡½æ•°ä½“å†…ï¼Œè¿”å›åˆ°è°ƒç”¨æ­¤å‡½æ•°çš„åœ°æ–¹ã€‚\nResume program (F9å¿«æ·é”®)ï¼šæ¢å¤ç¨‹åºï¼Œç›´æ¥è¿è¡Œåˆ°ä¸‹ä¸€æ–­ç‚¹å¤„ã€‚è‹¥æ— ä¸‹ä¸€æ–­ç‚¹ï¼Œåˆ™ç›´æ¥è·‘å®Œç¨‹åºã€‚\n\nè°ƒè¯•æ—¶å¸¦å‚æ•°\nå‚è€ƒé“¾æ¥\n\n\nrun -&gt; edit configurations\næ–°å»ºé€‰æ‹© pythonï¼Œname éšä¾¿å†™ï¼Œscript é€‰æ‹©è¦ debug çš„æ–‡ä»¶ï¼Œä¸‹æ–¹å¡«è¦æ·»åŠ çš„å‚æ•°ï¼Œæœ€ä¸‹æ–¹é€‰æ‹© â€œdebugâ€ ç‚¹å‡»å³å¯\n\n\n\n\n","categories":["ç‹ ç‹ markä½"],"tags":["Python","Pytorch"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘äºŒå‰æ ‘6-äºŒå‰æœç´¢æ ‘çš„å±æ€§","url":"/blog/Leetcode/tree5/","content":"700.äºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢\nlink\n\nç»™å®šäºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„æ ¹èŠ‚ç‚¹ root å’Œä¸€ä¸ªæ•´æ•°å€¼ valã€‚éœ€è¦åœ¨ BST ä¸­æ‰¾åˆ°èŠ‚ç‚¹å€¼ç­‰äº val çš„èŠ‚ç‚¹ã€‚ è¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘ã€‚ å¦‚æœèŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œåˆ™è¿”å› null ã€‚\näºŒå‰æœç´¢æ ‘ï¼šæ¯ä¸ªèŠ‚ç‚¹éƒ½æ»¡è¶³ï¼šå·¦èŠ‚ç‚¹ &lt; å½“å‰èŠ‚ç‚¹ &lt; å³èŠ‚ç‚¹ã€‚\næ€è·¯å‰åºéå†å½“å‰æ ‘ï¼Œåˆ¤æ–­æ˜¯è¿›å…¥å·¦å­æ ‘è¿˜æ˜¯å³å­æ ‘ã€‚è¿­ä»£æ³•è¾ƒä¸ºç®€ä¾¿ï¼Œå¯ä»¥ç›´æ¥ return æ¥è¿”å›ç»“æœã€‚\nclass Solution:    def searchBST(self, root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:        stack = []        if root:            stack.append(root)        while stack:            cur = stack.pop()            if cur.val == val:                return cur            elif cur.val &gt; val:                if cur.left:                    stack.append(cur.left)                else:                    return None                        elif cur.val &lt; val:                if cur.right:                    stack.append(cur.right)                else:                    return None\n\næ›´ç®€ä¾¿çš„æ–¹æ³•ï¼šç›´æ¥è¿›è¡Œéå†ï¼Œä¸éœ€è¦ä½¿ç”¨æ ˆæ¥ç»´æŠ¤è°ƒç”¨é¡ºåº\nclass Solution:    def searchBST(self, root: TreeNode, val: int) -&gt; TreeNode:        while root:            if val &lt; root.val: root = root.left            elif val &gt; root.val: root = root.right            else: return root        return None\n\n98.éªŒè¯äºŒå‰æœç´¢æ ‘\nlink\n\nç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œåˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„äºŒå‰æœç´¢æ ‘ã€‚æœ‰æ•ˆ äºŒå‰æœç´¢æ ‘å®šä¹‰å¦‚ä¸‹ï¼š\n\nèŠ‚ç‚¹çš„å·¦å­æ ‘åªåŒ…å« å°äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚\nèŠ‚ç‚¹çš„å³å­æ ‘åªåŒ…å« å¤§äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚\næ‰€æœ‰å·¦å­æ ‘å’Œå³å­æ ‘è‡ªèº«å¿…é¡»ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ã€‚\n\næ€è·¯é¢˜ç›®ä¸­æš—å«çš„æ˜¯ï¼Œåˆ¤æ–­å½“å‰èŠ‚ç‚¹æ˜¯å¦æ»¡è¶³ï¼Œç„¶åéå†å·¦å³å­æ ‘ï¼Œæœ¬è´¨ä¸Šæ˜¯å‰åºéå†ã€‚ä½†æ˜¯ï¼Œä¸èƒ½å•çº¯çš„æ¯”è¾ƒå·¦èŠ‚ç‚¹å°äºä¸­é—´èŠ‚ç‚¹ï¼Œå³èŠ‚ç‚¹å¤§äºä¸­é—´èŠ‚ç‚¹ï¼Œè¦æ¯”è¾ƒçš„æ˜¯å·¦å­æ ‘æ‰€æœ‰èŠ‚ç‚¹å°äºä¸­é—´èŠ‚ç‚¹ï¼Œå³å­æ ‘æ‰€æœ‰èŠ‚ç‚¹å¤§äºä¸­é—´èŠ‚ç‚¹ã€‚æ‰€ä»¥éœ€è¦è¿›è¡Œä¸­åºéå†ã€‚\næ³¨æ„ä¸­åºéå†ä¸‹ï¼ŒäºŒå‰æœç´¢æ ‘çš„ç»“æœä¸ºæœ‰åºæ•°ç»„ï¼Œæ‰€ä»¥åªéœ€è¦åˆ¤æ–­ä¸­åºéå†çš„ç»“æœæ˜¯å¦ä¸ºæœ‰åºæ•°ç»„å³å¯ã€‚\nclass Solution:    def isValidBST(self, root: Optional[TreeNode]) -&gt; bool:        res = []        def eval(node):            if node.left:                eval(node.left)            res.append(node.val)            if node.right:                eval(node.right)        if root:            eval(root)        for i in range(len(res) - 1):            if res[i] &gt;= res[i+1]:                return False        return True\n\nä¹Ÿå¯ä»¥ç›´æ¥åœ¨ä¸­åºéå†çš„è¿‡ç¨‹ä¸­åˆ¤æ–­ï¼Œåªéœ€è¦è®°å½•å‰ä¸€ä¸ªè®¿é—®çš„èŠ‚ç‚¹ï¼Œç„¶ååˆ¤æ–­æ˜¯å¦æ˜¯å‡åºå³å¯ã€‚\nclass Solution:    def isValidBST(self, root: Optional[TreeNode]) -&gt; bool:                res = []        stack = []        cur = root        pre = float(&#x27;-inf&#x27;)        while True:            while cur != None:                stack.append(cur)                cur = cur.left                        if len(stack) == 0:                break            cur = stack.pop()            if cur.val &lt;= pre:                return False            else:                pre = cur.val            cur = cur.right        return True\n\nï¼ˆæ¥è‡ª gptï¼‰æ­¤å¤–ï¼Œä¹Ÿå¯ä»¥ç»´æŠ¤ä¸€ä¸ªåŒºé—´ï¼Œé€šè¿‡é€’å½’åˆ¤æ–­ä¸€ä¸ªèŠ‚ç‚¹æ˜¯å¦åœ¨æŒ‡å®šçš„èŒƒå›´ä¸­ï¼š\nclass Solution:    def isValidBST(self, root: Optional[TreeNode]) -&gt; bool:        def validate(node, lower=float(&#x27;-inf&#x27;), upper=float(&#x27;inf&#x27;)):            if not node:                return True            if not (lower &lt; node.val &lt; upper):                return False            return (validate(node.left, lower, node.val) and                    validate(node.right, node.val, upper))        return validate(root)\n\n\n530.äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®\nlink\n\nç»™ä½ ä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å› æ ‘ä¸­ä»»æ„ä¸¤ä¸åŒèŠ‚ç‚¹å€¼ä¹‹é—´çš„æœ€å°å·®å€¼ ã€‚å·®å€¼æ˜¯ä¸€ä¸ªæ­£æ•°ï¼Œå…¶æ•°å€¼ç­‰äºä¸¤å€¼ä¹‹å·®çš„ç»å¯¹å€¼ã€‚æ‰€æœ‰èŠ‚ç‚¹å‡ä¸ºæ­£æ•°ã€‚\næ€è·¯ä¸­åºéå†ï¼Œç„¶ååœ¨ç»“æœæ•°ç»„ä¸­ä¾æ¬¡åˆ¤æ–­ç›¸é‚»çš„èŠ‚ç‚¹ã€‚\nä¹Ÿå¯ä»¥åƒå‰ä¸€é¢˜ä¸€æ ·è®°å½•ä¸Šä¸€æ¬¡è®¿é—®çš„æ•°ï¼Œç›´æ¥åˆ¤æ–­ã€‚\nclass Solution:    def getMinimumDifference(self, root: Optional[TreeNode]) -&gt; int:        res = []        stack = []        cur = root        pre = None        mindif = float(&#x27;inf&#x27;)        while True:            while cur != None:                stack.append(cur)                cur = cur.left                        if len(stack) == 0:                break            cur = stack.pop()            if pre != None:                mindif = min(mindif, cur.val - pre)                       pre = cur.val            cur = cur.right        return mindif\n\n\né‡åˆ°åœ¨äºŒå‰æœç´¢æ ‘ä¸Šæ±‚ä»€ä¹ˆæœ€å€¼ï¼Œæ±‚å·®å€¼ä¹‹ç±»çš„ï¼Œéƒ½è¦æ€è€ƒä¸€ä¸‹äºŒå‰æœç´¢æ ‘å¯æ˜¯æœ‰åºçš„ï¼Œè¦åˆ©ç”¨å¥½è¿™ä¸€ç‰¹ç‚¹ã€‚\n501.äºŒå‰æœç´¢æ ‘ä¸­çš„ä¼—æ•°\nlink\n\näºŒå‰æœç´¢æ ‘æ”¾å®½æ¡ä»¶ï¼š\n\nç»“ç‚¹å·¦å­æ ‘ä¸­æ‰€å«èŠ‚ç‚¹çš„å€¼ å°äºç­‰äº å½“å‰èŠ‚ç‚¹çš„å€¼\nç»“ç‚¹å³å­æ ‘ä¸­æ‰€å«èŠ‚ç‚¹çš„å€¼ å¤§äºç­‰äº å½“å‰èŠ‚ç‚¹çš„å€¼\nå·¦å­æ ‘å’Œå³å­æ ‘éƒ½æ˜¯äºŒå‰æœç´¢æ ‘\n\næ€è·¯ç®€å•åšæ³•ä»ç„¶æ˜¯åœ¨éå†ç»“æœä¸­å¯»æ‰¾ã€‚\nå¦‚æœåœ¨éå†çš„è¿‡ç¨‹ä¸­è¿›è¡Œå¤„ç†ï¼Œä¸­åºéå†çš„ç»“æœæ˜¯å‡åºï¼Œæ‰€ä»¥å’Œä¸Šä¸€é¢˜ä¸€æ ·ï¼Œè®°å½•ä¸Šä¸€ä¸ªå€¼ï¼Œå¦‚æœç›¸åŒåˆ™ count åŠ ä¸€ã€‚åŒæ—¶éœ€è¦è®°å½• maxcountï¼Œå¦‚æœå½“å‰çš„ count å¤§äº maxcountï¼Œåˆ™å°†ç»“æœæ¸…ç©ºå†åŠ å…¥å½“å‰å…ƒç´ ã€‚\nclass Solution:    def findMode(self, root: Optional[TreeNode]) -&gt; List[int]:        maxcount = 0        count = 0        res = []        stack = []        cur = root        pre = None        while True:            while cur!= None:                stack.append(cur)                cur = cur.left                        if len(stack) == 0:                break            cur = stack.pop()            if pre != None and pre == cur.val:                count += 1            else: # æœ‰æ–°æ•°å­—å‡ºç° or ç¬¬ä¸€ä¸ªæ•°å­—                count = 1            if count &gt; maxcount:                res.clear()                res.append(cur.val)                maxcount = count            elif count == maxcount:                res.append(cur.val)            pre = cur.val            cur = cur.right        return res\n\n538.æŠŠäºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºç´¯åŠ æ ‘\nlink\n\nç»™å‡ºäºŒå‰ æœç´¢ æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œè¯¥æ ‘çš„èŠ‚ç‚¹å€¼å„ä¸ç›¸åŒï¼Œè¯·ä½ å°†å…¶è½¬æ¢ä¸ºç´¯åŠ æ ‘ï¼ˆGreater Sum Treeï¼‰ï¼Œä½¿æ¯ä¸ªèŠ‚ç‚¹ node çš„æ–°å€¼ç­‰äºåŸæ ‘ä¸­å¤§äºæˆ–ç­‰äº node.val çš„å€¼ä¹‹å’Œã€‚\næ€è·¯èŠ‚ç‚¹ node çš„æ–°å€¼ç­‰äºåŸæ ‘ä¸­å¤§äºæˆ–ç­‰äº node.val çš„å€¼ä¹‹å’Œã€‚è€ŒäºŒå‰æœç´¢æ ‘ä¸­åºéå†æ˜¯å‡åºæ’åˆ—ã€‚å¦‚æœæˆ‘ä»¬ä»å³åˆ°å·¦ä¸­åºéå†ï¼ˆå³ â†’ æ ¹ â†’ å·¦ï¼‰ï¼Œå°±ä¼šå¾—åˆ°é™åºåºåˆ—ã€‚å°±å¯ä»¥ä»å¤§åˆ°å°è¿›è¡Œç´¯åŠ ã€‚\nclass Solution:    def convertBST(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:        stack = []        s = 0        cur = root        while True:            while cur:                stack.append(cur)                cur = cur.right                        if len(stack) == 0:                break            cur = stack.pop()            s += cur.val            cur.val = s            cur = cur.left                return root","categories":["Leetcode"],"tags":["tree"]},{"title":"git timeout æŠ¥é”™443è§£å†³æ–¹æ³•","url":"/blog/Mark/git-443/","content":"\nå‚è€ƒé“¾æ¥\n\nè§£å†³æ–¹æ³•\næŸ¥çœ‹ä»£ç†çš„ç«¯å£å·ï¼ˆclash çš„ General èœå•ä¸­ï¼Œé»˜è®¤ä¸º7890ï¼‰\næŸ¥çœ‹å¹¶å–æ¶ˆ git çš„ http å’Œ https ä»£ç†// é¦–å…ˆï¼ŒæŸ¥ä¸€ä¸‹å½“å‰å…¨å±€çš„ http ä»£ç†ï¼šgit config --global http.proxy// å¦‚æœæœ‰ä»£ç†ï¼Œå°±å–æ¶ˆgit config --global --unset http.proxy // å†æŸ¥ https çš„ä»£ç†ï¼šgit config --global https.proxy// åŒæ ·çš„ï¼Œæœ‰å°±å–æ¶ˆgit config --global --unset https.proxy\nè®¾ç½®ä»£ç†//è®¾ç½®gitç«¯å£å·å’Œä¸Šé¢çš„ç«¯å£å·ä¿æŒä¸€è‡´git config --global http.proxy http://127.0.0.1:7890git config --global https.proxy https://127.0.0.1:7890\n\n","categories":["ç‹ ç‹ markä½"],"tags":["Git"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘äºŒå‰æ ‘5-å…¬å…±ç¥–å…ˆé—®é¢˜","url":"/blog/Leetcode/tree6/","content":"236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ\nlink\n\nç»™å®šä¸€ä¸ªäºŒå‰æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªèŠ‚ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªèŠ‚ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆï¼‰ã€‚â€\n\n\nè¾“å…¥ï¼šroot &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1è¾“å‡ºï¼š3è§£é‡Šï¼šèŠ‚ç‚¹ 5 å’ŒèŠ‚ç‚¹ 1 çš„æœ€è¿‘å…¬å…±ç¥–å…ˆæ˜¯èŠ‚ç‚¹ 3 ã€‚  \n\næ€è·¯è‡ªåº•å‘ä¸ŠæŸ¥æ‰¾å³å¯ï¼ˆå›æº¯ï¼‰ï¼Œååºéå†å¤©ç„¶æ»¡è¶³è¿™ä¸ªæ¡ä»¶ã€‚æ¥ä¸‹æ¥å°±çœ‹å¦‚ä½•åˆ¤æ–­ä¸€ä¸ªèŠ‚ç‚¹æ˜¯èŠ‚ç‚¹qå’ŒèŠ‚ç‚¹pçš„å…¬å…±ç¥–å…ˆã€‚\né¦–å…ˆæœ€å®¹æ˜“æƒ³åˆ°çš„ä¸€ä¸ªæƒ…å†µï¼šå¦‚æœæ‰¾åˆ°ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå‘ç°å·¦å­æ ‘å‡ºç°ç»“ç‚¹ pï¼Œå³å­æ ‘å‡ºç°èŠ‚ç‚¹ qï¼Œæˆ–è€… å·¦å­æ ‘å‡ºç°ç»“ç‚¹ qï¼Œå³å­æ ‘å‡ºç°èŠ‚ç‚¹ pï¼Œé‚£ä¹ˆè¯¥èŠ‚ç‚¹å°±æ˜¯èŠ‚ç‚¹ p å’Œ q çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚ å³æƒ…å†µä¸€ï¼š\n\nåˆ¤æ–­é€»è¾‘æ˜¯ å¦‚æœé€’å½’éå†é‡åˆ° qï¼Œå°±å°† q è¿”å›ï¼Œé‡åˆ° p å°±å°† p è¿”å›ï¼Œé‚£ä¹ˆå¦‚æœ å·¦å³å­æ ‘çš„è¿”å›å€¼éƒ½ä¸ä¸ºç©ºï¼Œè¯´æ˜æ­¤æ—¶çš„ä¸­èŠ‚ç‚¹ï¼Œä¸€å®šæ˜¯ q å’Œ p çš„æœ€è¿‘ç¥–å…ˆã€‚\næ¥ç€æ˜¯æƒ…å†µäºŒï¼Œq æˆ–è€… p ä¸ºç¥–å…ˆèŠ‚ç‚¹ï¼š\n\nclass Solution:    def lowestCommonAncestor(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; &#x27;TreeNode&#x27;:        def dfs(node):            # æ‰¾åˆ°pæˆ–è€…qï¼Œæˆ–è€…ä¸ºç©º            if node == p or node == q or node == None:                return node            # åˆ†åˆ«åœ¨å·¦å³å­æ ‘å»æ‰¾            lres = dfs(node.left)            rres = dfs(node.right)            # å·¦è¾¹å³è¾¹éƒ½æ‰¾åˆ°äº†ï¼Œç›´æ¥è¿”å›å½“å‰èŠ‚ç‚¹            if lres and rres:                return node            # åœ¨å·¦ï¼ˆå³ï¼‰è¾¹æ‰¾åˆ°ï¼Œå¯èƒ½æ˜¯æ‰¾åˆ°pï¼ˆqï¼‰ï¼Œ            # ä¹Ÿå¯èƒ½æ˜¯æ‰¾åˆ°äº†å…¬å…±èŠ‚ç‚¹ï¼Œå›æº¯å»åˆ¤æ–­ã€‚            if lres:                return lres            if rres:                return rres            return None        return dfs(root)\n\næ³¨æ„ï¼Œæƒ…å†µ 2 åœ¨ç¬¬ä¸€ä¸ª if å°±åˆ¤æ–­äº†ï¼Œä¾‹å¦‚å¯¹äºä¾‹å­ä¸­çš„ 6ï¼Œåˆ¤æ–­ä¸ä¸º q æˆ–è€… pï¼Œåˆ™è®¿é—®å…¶å­èŠ‚ç‚¹ï¼Œå·¦è¾¹ç›´æ¥è¿”å› qï¼Œå³è¾¹è¿”å› Noneï¼Œæ­¤æ—¶å°±ç›´æ¥è¿”å› q ä¸ºæœ€ç»ˆç»“æœäº†ã€‚å› ä¸ºåœ¨å·¦è¾¹æŸ¥æ‰¾åˆ°äº†ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå³è¾¹ä¸ºç©ºï¼Œåˆ™è¯´æ˜ä¸¤ä¸ªèŠ‚ç‚¹ä¸€å®šåœ¨ä¸€ä¸ªå­æ ‘ä¸Šï¼Œæ‰€ä»¥ç›´æ¥è¿”å›æ‰¾åˆ°çš„ qã€‚\n235. äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ\nlink\n\nåœ¨ä¸Šä¸€é¢˜çš„åŸºç¡€ä¸Šæ·»åŠ äº†é™åˆ¶ä¸ºäºŒå‰æœç´¢æ ‘ã€‚\næ€è·¯æœç´¢äºŒå‰æ ‘æ˜¯æœ‰åºçš„ï¼Œæ‰€ä»¥æœ€è¿‘å…¬å…±å­èŠ‚ç‚¹ä¸€å®šåœ¨åŒºé—´ [q, p] æˆ–è€… [p, q] ä¸­ã€‚é‚£ä¹ˆåªè¦ä»ä¸Šåˆ°ä¸‹å»éå†ï¼Œé‡åˆ° curèŠ‚ç‚¹æ˜¯æ•°å€¼åœ¨[p, q]åŒºé—´ä¸­åˆ™ä¸€å®šå¯ä»¥è¯´æ˜è¯¥èŠ‚ç‚¹curå°±æ˜¯p å’Œ qçš„å…¬å…±ç¥–å…ˆã€‚ é‚£é—®é¢˜æ¥äº†ï¼Œä¸€å®šæ˜¯æœ€è¿‘å…¬å…±ç¥–å…ˆå—ï¼Ÿ\nå¦‚å›¾æ‰€ç¤ºï¼Œé¦–å…ˆéå†åˆ° 10ï¼Œq p éƒ½å°äº 10ï¼Œåˆ™éå†å·¦å­æ ‘ï¼Œç¬¬ä¸€æ¬¡é‡åˆ° 5ï¼Œæ»¡è¶³æ¡ä»¶ï¼Œp q ä¸€å®šä¸€ä¸ªåœ¨å·¦è¾¹ä¸€ä¸ªåœ¨å³è¾¹ï¼Œå¦‚ä½•å†éå†ï¼Œåˆ™åç»­èŠ‚ç‚¹éƒ½ä¸æ˜¯å…¬å…±ç¥–å…ˆäº†ã€‚\n\nclass Solution:    def lowestCommonAncestor(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; &#x27;TreeNode&#x27;:        stack = []        if root:            stack.append(root)        while stack:            cur = stack.pop()            if (min(q.val, p.val) &lt;= cur.val &lt;= max(q.val, p.val)):                return cur            if cur.val &gt; max(q.val, p.val):                stack.append(cur.left)             if cur.val &lt; min(q.val, p.val):                stack.append(cur.right)","categories":["Leetcode"],"tags":["tree"]},{"title":"hexoåŸºæœ¬å‘½ä»¤","url":"/blog/Mark/hexo-command/","content":"å¿«é€Ÿå¼€å§‹åˆ›å»ºæ–°åšå®¢$ hexo new &quot;My New Post&quot;\n\n\nè¿è¡ŒæœåŠ¡å™¨$ hexo server\nåŠ¨æ€éƒ¨ç½²ï¼Œä¿®æ”¹ä»£ç å®æ—¶æ›´æ–°ã€‚\nç”Ÿæˆé™æ€æ–‡ä»¶$ hexo generate\n\nè¿œç«¯éƒ¨ç½²$ hexo deploy\n\n\næ¸…ç†ç¼“å­˜$ hexo clean\nDonâ€™t forget to clean cacheâ€¦\næ ‡ç­¾æ’ä»¶é“¾æ¥åˆ°å…¶ä»–åšå®¢é¡µé¢ä½¿ç”¨ post_link æ ‡ç­¾ã€‚æ³¨æ„è¦ä»¥ &#x2F;_posts æ–‡ä»¶å¤¹ä¸ºæ ¹è·¯å¾„ã€‚å³ä½¿ä¸¤ä¸ª post åœ¨åŒä¸€ä¸ªå­æ–‡ä»¶ä¸‹ï¼Œä¹Ÿéœ€è¦å†™å‡ºå­æ–‡ä»¶å¤¹çš„åå­—ï¼Œä¾‹å¦‚ä¸‹é¢çš„ hello-world é¡µé¢ä½äº _post æ–‡ä»¶å¤¹ä¸‹ï¼Œå°±ç›´æ¥å†™æ–‡ä»¶åã€‚\n&#123;% post_link ç›¸å¯¹è·¯å¾„ &#x27;é“¾æ¥æ–‡å­—&#x27; %&#125;&lt;!-- &#123;% post_link hello-world &#x27;è®¿é—®é¦–é¡µ&#x27; %&#125; --&gt;\nè®¿é—®é¦–é¡µ\n\nå¼•ç”¨å—å†™æ³• 1&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content&#123;% endblockquote %&#125;\nexample\nhexo-officialä»£ç å—\n\nå†™æ³• 2&gt; &gt; &gt; \n\n\nè¿™æ˜¯å¼•ç”¨è¿™æ˜¯å¼•ç”¨  \n\næ³¨æ„è¿™ç§æ–¹æ³•çš„æ¯ä¸€è¡Œåé¢è¦æ‰“è¿ä¸¤ä¸ªç©ºæ ¼ï¼Œç”¨äºæ¢è¡Œ\nå†™æ³• 3æŸäº›æƒ…å†µä¸‹ï¼Œå¼•ç”¨å—ä¸­éœ€è¦ç¼©è¿›ï¼Œä¸Šé¢ä¸¤ç§æ–¹æ³•éƒ½æ— æ³•å¤„ç†ç¼©è¿›ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ä»¥ä¸‹æ ‡ç­¾ï¼š\n&lt;blockquote&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/blockquote&gt;\n\n\næ— ç¼©è¿›\n    å››ä¸ªå­—ç¬¦ï¼ˆä¸€ä¸ª tabï¼‰ç¼©è¿›\n        å…«ä¸ªå­—ç¬¦ï¼ˆä¸¤ä¸ª tabï¼‰ç¼©è¿›\n\n\nä»£ç å—&#123;% codeblock %&#125;alert(&#x27;Hello World!&#x27;);&#123;% endcodeblock %&#125;\nç­‰åŒäºä½¿ç”¨åå¼•å· \n``` your code ``` \n\n\nHexoæ–°å»ºæ–‡ç« åˆ°å­ç›®å½•hexo new å‘½ä»¤è¯´æ˜ï¼š\nUsage: hexo new [layout] &lt;title&gt;Description:Create a new post.Arguments:  layout  Post layout. Use post, page, draft or whatever you want.  title   Post title. Wrap it with quotations to escape.Options:  -p, --path     Post path. Customize the path of the post.  -r, --replace  Replace the current post if existed.  -s, --slug     Post slug. Customize the URL of the post.\nä¾‹å¦‚ï¼Œåœ¨ 202411/ æ–‡ä»¶å¤¹ä¸‹æ–°å»º test.md æ–‡ä»¶\nhexo n -p 202411/test.md\n\n","categories":["ç‹ ç‹ markä½"],"tags":["Hexo"]},{"title":"Huggingface ç›¸å…³é—®é¢˜","url":"/blog/Mark/hf/","content":"æ›´æ¢ Huggingface æº\nexport HF_ENDPOINT&#x3D;https://hf-mirror.com\n\nä¸€é”®ä¸‹è½½ Huggingface æ¨¡å‹ä¸‹è½½ huggingface-cli ã€‚\n\nhuggingface-cli download model_name â€“local-dir .&#x2F;your_download_dir\n\nåªéœ€è¦æ›´æ”¹ model_name å’Œ ./your_download_dir ã€‚\n","categories":["ç‹ ç‹ markä½"],"tags":["LLM","Linux"]},{"title":"è®¾ç½®HTTPä»£ç†","url":"/blog/Mark/http-proxy/","content":"é—®é¢˜åœ¨ Ubuntu è®¾ç½®ä¸­å·²ç»ä½¿ç”¨äº†æ‰‹åŠ¨ä»£ç†ï¼Œä½†æ˜¯åœ¨ç»ˆç«¯ä¸­æ— æ•ˆ\nè§£å†³æ–¹æ³•Ubuntu çš„â€œè®¾ç½® â†’ ç½‘ç»œ â†’ ä»£ç†â€åªä¼šå½±å“ï¼š\n\nGNOME æ¡Œé¢ç¯å¢ƒä¸­çš„ å›¾å½¢åŒ–åº”ç”¨ç¨‹åºï¼ˆå¦‚ Firefoxã€Software Centerï¼‰\næŸäº›æ”¯æŒ GNOME D-Bus ä»£ç†è‡ªåŠ¨æ£€æµ‹çš„ GUI è½¯ä»¶\n\nä½†å®ƒä¸ä¼šè‡ªåŠ¨å½±å“ï¼š\n\nå‘½ä»¤è¡Œå·¥å…·ï¼ˆå¦‚ curl, wget, git, pip, requests, huggingface_hubï¼‰\nPython&#x2F;Conda è„šæœ¬è¿è¡Œç¯å¢ƒ\nåå°æœåŠ¡è¿›ç¨‹ï¼ˆsystemd ç­‰ï¼‰\n\nè¿™äº›ç¨‹åºéœ€è¦é€šè¿‡ç¯å¢ƒå˜é‡æ˜¾å¼è·å–ä»£ç†è®¾ç½®ï¼Œå‘½ä»¤å¦‚ä¸‹ï¼š\nexport HTTP_PROXY=http://127.0.0.1:7890export HTTPS_PROXY=http://127.0.0.1:7890\nä½†æ˜¯ä¸Šè¿°å‘½ä»¤åªæ˜¯ä¸´æ—¶çš„ï¼Œåªå¯¹å½“å‰ç»ˆç«¯æœ‰æ•ˆã€‚å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å†™å…¥é…ç½®æ–‡ä»¶ï¼š\necho &quot;export HTTP_PROXY=http://127.0.0.1:7890&quot; &gt;&gt; ~/.bashrcecho &quot;export HTTPS_PROXY=http://127.0.0.1:7890&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc\n","categories":["ç‹ ç‹ markä½"],"tags":["Linux"]},{"title":"Numpy æŠ¥é”™ï¼šnumpy is not available","url":"/blog/Mark/numpy/","content":"æè¿°æŠ¥é”™å¦‚ä¸‹ï¼š\n\nA module is compiled with numpy 1.X cannot be run in numpy 2.X\n\nè§£å†³æ–¹æ³•æ¢æ—§ç‰ˆæœ¬çš„ numpy\npip uninstall numpypip install numpy==1.25.3\n","categories":["ç‹ ç‹ markä½"],"tags":["Python","Pytorch"]},{"title":"Ubuntu å†…æ ¸ä¸ Nvidia é©±åŠ¨ä¸åŒ¹é…é—®é¢˜","url":"/blog/Mark/nvidia-kernal/","content":"\nä¸€å®šè¦å…³ç³»è‡ªåŠ¨æ›´æ–°ï¼ï¼\nå¸è½½å¹¶å®‰è£…é©±åŠ¨\nhttps://www.cnblogs.com/aliving/articles/18389099\n\n\næ›´æ”¹å†…æ ¸ç‰ˆæœ¬\nhttps://blog.csdn.net/damifeng/article/details/132985518\n\næŸ¥çœ‹å¯ä»¥å®‰è£…çš„å†…æ ¸ç‰ˆæœ¬ï¼ˆæœºå­ä¸Šæ›¾ç»ä¸‹è¿‡çš„ï¼Œä¸ä¼šåˆ é™¤ï¼‰\n\ndpkg â€“get-selections|grep linux\n\n\nä¸‹è½½æŒ‡å®šç‰ˆæœ¬\n  sudo apt-get install linux-image-xxx-genericsudo apt-get install linux-headers-xxx-genericsudo apt-get install linux-modules-xxx-genericsudo apt-get install linux-modules-extra-xxx-genericsudo apt-get install linux-tools-xxx-generic\næ›´æ–° initramfs\n\nsudo update-initramfs -u -k all\n\n\nä¿®æ”¹ grubï¼Œé€‰æ‹©æŒ‡å®šå†…æ ¸\n\nhttps://www.8kiz.cn/archives/14385.html\nå¼€æœºç‹‚æŒ‰ shiftï¼Œé€‰æ‹© advanced options\n\n\nä¸€å®šè¦\n  sudo update-grub\n\n\nåˆ é™¤ä¸‹è½½çš„å†…æ ¸ï¼ˆä¸æ˜¯çœŸçš„åˆ é™¤ï¼‰\nhttps://download.csdn.net/blog/column/12270246/130411204\n\n\n\n","categories":["ç‹ ç‹ markä½"],"tags":["Linux"]},{"title":"ã€ä»£ç éšæƒ³å½•ã€‘äºŒå‰æ ‘7-äºŒå‰æœç´¢æ ‘çš„ä¿®æ”¹ä¸æ”¹é€ ","url":"/blog/Leetcode/tree7/","content":"701.äºŒå‰æœç´¢æ ‘ä¸­çš„æ’å…¥æ“ä½œ\nlink\n\nç»™å®šäºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„æ ¹èŠ‚ç‚¹ root å’Œè¦æ’å…¥æ ‘ä¸­çš„å€¼ value ï¼Œå°†å€¼æ’å…¥äºŒå‰æœç´¢æ ‘ã€‚ è¿”å›æ’å…¥åäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚ è¾“å…¥æ•°æ® ä¿è¯ ï¼Œæ–°å€¼å’ŒåŸå§‹äºŒå‰æœç´¢æ ‘ä¸­çš„ä»»æ„èŠ‚ç‚¹å€¼éƒ½ä¸åŒã€‚\næ³¨æ„ï¼Œå¯èƒ½å­˜åœ¨å¤šç§æœ‰æ•ˆçš„æ’å…¥æ–¹å¼ï¼Œåªè¦æ ‘åœ¨æ’å…¥åä»ä¿æŒä¸ºäºŒå‰æœç´¢æ ‘å³å¯ã€‚ ä½ å¯ä»¥è¿”å› ä»»æ„æœ‰æ•ˆçš„ç»“æœ ã€‚\næ€è·¯é¢˜ç›®ä¸­è¯´éšä¾¿è¿”å›ä¸€ç§ç»“æœå³å¯ï¼Œæ‰€ä»¥å¯ä»¥ä¸€æ¡è·¯èµ°åˆ°åº•ï¼Œä¸ç”¨éå†æ•´ä¸ªæ ‘\nclass Solution:    def insertIntoBST(self, root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:        cur = root        node = TreeNode(val)        pre = None        if root == None:            return node        while cur:            pre = cur            if cur.val &gt; val:                cur = cur.left            else:                cur = cur.right        if pre.val &lt; val:            pre.right = node        else:            pre.left = node                    return root\n\n450.åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹\nlink\n\nç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ root å’Œä¸€ä¸ªå€¼ keyï¼Œåˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„ key å¯¹åº”çš„èŠ‚ç‚¹ï¼Œå¹¶ä¿è¯äºŒå‰æœç´¢æ ‘çš„æ€§è´¨ä¸å˜ã€‚è¿”å›äºŒå‰æœç´¢æ ‘ï¼ˆæœ‰å¯èƒ½è¢«æ›´æ–°ï¼‰çš„æ ¹èŠ‚ç‚¹çš„å¼•ç”¨ã€‚\næ€è·¯æ‰¾åˆ°èŠ‚ç‚¹åï¼Œéœ€è¦ä¿®æ”¹ä»¥å½“å‰èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘ï¼Œåˆ¤æ–­å…¶å·¦å³èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨ï¼Œå¯ä»¥æŒ‰ç…§å¦‚ä¸‹ä¿®æ”¹ï¼š\n\næŠŠå·¦å­æ ‘ä½œä¸ºå½“å‰æ ¹èŠ‚ç‚¹ï¼Œå³å­æ ‘æ”¾åˆ°åŸæœ‰å·¦å­æ ‘çš„æœ€å³è¾¹\nå³å­æ ‘ä½œä¸ºå½“å‰æ ¹èŠ‚ç‚¹ï¼Œå·¦å­æ ‘æ”¾åˆ°åŸæœ‰å·¦å­æ ‘çš„å·¦è¾¹\n\nè¿”å›çš„å€¼ä¸ºæ›´æ–°åçš„å­æ ‘\nclass Solution:    def deleteNode(self, root: Optional[TreeNode], key: int) -&gt; Optional[TreeNode]:        def dfs(node):            if not node:                return None            if node.val &gt; key:                node.left =  dfs(node.left)                return node                        if node.val &lt; key:                node.right = dfs(node.right)                return node                        if not node.left and not node.right:                return None            if not node.left and node.right:                return node.right            if node.left and not node.right:                return node.left                        cur = node.right            pre = node            while cur:                pre = cur                cur = cur.left            pre.left = node.left            return node.right        return dfs(root)\n\n669. ä¿®å‰ªäºŒå‰æœç´¢æ ‘\nlink\n\nç»™ä½ äºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼ŒåŒæ—¶ç»™å®šæœ€å°è¾¹ç•Œ low å’Œæœ€å¤§è¾¹ç•Œ highã€‚é€šè¿‡ä¿®å‰ªäºŒå‰æœç´¢æ ‘ï¼Œä½¿å¾—æ‰€æœ‰èŠ‚ç‚¹çš„å€¼åœ¨ [low, high] ä¸­ã€‚ä¿®å‰ªæ ‘ ä¸åº”è¯¥ æ”¹å˜ä¿ç•™åœ¨æ ‘ä¸­çš„å…ƒç´ çš„ç›¸å¯¹ç»“æ„ (å³ï¼Œå¦‚æœæ²¡æœ‰è¢«ç§»é™¤ï¼ŒåŸæœ‰çš„çˆ¶ä»£å­ä»£å…³ç³»éƒ½åº”å½“ä¿ç•™)ã€‚ å¯ä»¥è¯æ˜ï¼Œå­˜åœ¨ å”¯ä¸€çš„ç­”æ¡ˆ ã€‚\næ€è·¯ç›´æ¥çš„æ€è·¯æ˜¯åˆ¤æ–­å½“å‰èŠ‚ç‚¹æ˜¯å¦åœ¨åŒºé—´å¤–ï¼Œå¦‚æœåœ¨åŒºé—´å·¦è¾¹å°±ç›´æ¥åˆ é™¤å·¦å­æ ‘ï¼Œåœ¨åŒºé—´å³è¾¹å°±åˆ é™¤å³å­æ ‘ã€‚ä½†æ˜¯ï¼Œå­æ ‘é‡Œé¢å¯èƒ½æœ‰åœ¨åŒºé—´å†…çš„èŠ‚ç‚¹ï¼Œå¦‚å›¾æ‰€ç¤º\n\nä½¿ç”¨é€’å½’çš„æ–¹æ³•ï¼Œåœ¨é‡åˆ°ä¸Šè¿°ä¸¤ç§æƒ…å†µæ—¶ï¼Œå¯ä»¥ç›´æ¥è¿”å›é€’å½’å­æ ‘çš„ç»“æœã€‚æ¥ä¸‹æ¥å°±å¤„ç†æ ¹èŠ‚ç‚¹åœ¨åŒºé—´å†…çš„æƒ…å†µï¼Œå³æ ¹èŠ‚ç‚¹çš„å·¦å³å­æ ‘åˆ†åˆ«é€’å½’å¤„ç†ï¼Œå¹¶å°†è¿”å›ç»“æœèµ‹å€¼ç»™å·¦å³æŒ‡é’ˆã€‚\nclass Solution:    def trimBST(self, root: Optional[TreeNode], low: int, high: int) -&gt; Optional[TreeNode]:                def dfs(node, l, h):            if not node:                return None            if node.val &gt; h:                return dfs(node.left, l, h)            if node.val &lt; l:                return dfs(node.right, l, h)                        # å½“å‰èŠ‚ç‚¹åœ¨åŒºé—´å†…            node.left = dfs(node.left, l, h)            node.right = dfs(node.right, l, h)            return node                return dfs(root, low, high)\n\n108.å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘\nlink\n\nå°†ä¸€ä¸ªæŒ‰ç…§å‡åºæ’åˆ—çš„æœ‰åºæ•°ç»„ï¼Œè½¬æ¢ä¸ºä¸€æ£µé«˜åº¦å¹³è¡¡äºŒå‰æœç´¢æ ‘ã€‚æœ¬é¢˜ä¸­ï¼Œä¸€ä¸ªé«˜åº¦å¹³è¡¡äºŒå‰æ ‘æ˜¯æŒ‡ä¸€ä¸ªäºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹ çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1ã€‚\n\næ€è·¯é€’å½’è°ƒç”¨ï¼š\n\né€’å½’å‡½æ•°æ¥å—å½“å‰çš„åŒºé—´ï¼Œè¿”å›åŸºäºå½“å‰åŒºé—´æ„å»ºçš„å­æ ‘\nå½“åŒºé—´é•¿åº¦ä¸º 0 æ—¶å°±åœæ­¢é€’å½’ï¼Œè¿”å›ç©º\nä¸»è¦é€»è¾‘ï¼š\næ‰¾åˆ°åŒºé—´ä¸­ç‚¹ï¼ŒåŸºäºåŒºé—´ä¸­ç‚¹åˆ›å»ºæ ¹èŠ‚ç‚¹\nåˆ’åˆ†åŒºé—´ï¼Œå·¦åŒºé—´æ„å»ºå·¦å­æ ‘ï¼Œå³åŒºé—´æ„å»ºå³å­æ ‘\nå°†ä¸¤ä¸ªå­æ ‘èµ‹å€¼ç»™æ ¹èŠ‚ç‚¹\n\n\n\nclass Solution:    def sortedArrayToBST(self, nums: List[int]) -&gt; Optional[TreeNode]:                def dfs(num):            if len(num) == 0:                return None            index = len(num) // 2            root = TreeNode(num[index])            root.left = dfs(num[:index])            root.right = dfs(num[index+1:])            return root        return dfs(nums)","categories":["Leetcode"],"tags":["tree"]},{"title":"swanlab ä½¿ç”¨","url":"/blog/Mark/swanlab/","content":"è§£å†³ wandb æ— æ³•è®¿é—®çš„é—®é¢˜é¦–å…ˆåœ¨ç¯å¢ƒä¸­å®‰è£… swanlabï¼Œç„¶åç™»å½•\npip install swanlabswanlab login\n\nç„¶ååœ¨è¦è¿è¡Œçš„ Python æ–‡ä»¶å‰åŠ ä¸Šä»¥ä¸‹ä»£ç ï¼Œæ³¨æ„è¦åœ¨ wandb.init() ä¹‹å‰ã€‚\nimport swanlabswanlab.sync_wandb()\n\næœ€åæŠŠ wandb è®¾ç½®ä¸ºç¦»çº¿æ¨¡å¼ã€‚åœ¨ç»ˆç«¯è¿è¡Œæˆ–è€…å†™åœ¨ bash æ–‡ä»¶ä¸­å‡å¯ã€‚ï¼ˆå†™åœ¨ bash æ–‡ä»¶ä¸­è¦ç»™ offline åŠ å¼•å·ï¼‰\nexport WANDB_MDOE=offline","categories":["ç‹ ç‹ markä½"],"tags":["Python"]}]