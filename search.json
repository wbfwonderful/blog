[{"title":"Hello World 👋","url":"/blog/hello-world/","content":"😏欢迎来到我的博客你也许可以看到：\n\n✍️学习记录\n💻技术分享\n📑日常流水账\n…\n\n"},{"title":"【Kaggle Courses】3-机器学习介绍","url":"/blog/Kaggle-course/intro-to-ML/","content":"Learn the core ideas in machine learning, and build your first models. Click here for more information.\n\n\n模型是如何工作的？\nThe first step.\n\n引入考虑以下场景：\n\n你表弟做房地产投机赚了几百万美元。因为你对数据科学感兴趣，他提出要和你成为商业伙伴。他会提供钱，你会提供模型来预测各种房子的价值。\n你问你的堂兄他过去是如何预测房地产价值的，他说这只是直觉。但更多的质疑表明，他从过去看过的房子中识别出了价格模式，并用这些模式来预测他正在考虑的新房。\n…\n\n考虑这个简单的决策树：它只把房子分成两类。所考虑的任何房屋的预测价格都是同一类别房屋的历史平均价格。\n通过数据来决定如何将房屋分为两类，同时决定其预测价格。从数据中捕获模式的这一步称为拟合(fitting)或训练(training)模型。用于拟合模型的数据称为训练数据(training data)。\n改进决策树以下哪个决策树更有效？左边的决策树（决策树1）可能更有意义，因为它抓住了一个现实，即卧室多的房子往往比卧室少的房子卖得更高。这种模式最大的缺点是，它没有考虑到影响房价的大多数因素，比如浴室数量、地块大小、位置等。\n可以使用具有更多“分裂”的树来捕获更多因素。这些树被称为“更深的”树。考虑到每栋房子地块总面积的决策树可能是这样的：房子的预测价格在这棵树的底部。我们做出预测的底部点被称为叶子 (leaf)。\n初步探索数据\nLoad and understand your data.\n\n使用 Pandas 来加载数据Pandas 是数据科学家用来探索和操作数据的主要工具。大多数人在代码中将 pandas 缩写为 pd：\nimport pandas as pd\nPandas 库中最重要的部分是 DataFrame。DataFrame 保存了您可能认为是表的数据类型。这类似于 Excel 中的工作表或 SQL 数据库中的表。\n使用如下命令来读取 csv 文件，并进行展示：\ndf = pd.read_csv(&#x27;my_csv.csv&#x27;)df.describe()\n更多关于 pandas 的介绍。\n对数据的解释某个 csv 文件通过 .describe() 展示的结果为：\n\n结果为原始数据集中的每列显示8个数字。第一个数字是 count，显示有多少行具有非缺失值。\n缺失值的产生有很多原因。例如，在调查一间卧室的房子时，不会收集第二间卧室的大小。我们将回到丢失数据的话题。\n\n\n第二个值是均值，也就是平均值。在此之下，std 是标准偏差，它衡量数值的数值分布。\n后续五个值：将该列的数据升序排序形成一个列表，在列表中走四分之一，会发现一个大于 25% 且小于 75% 的值。这是 25% 的定义。\n\n第一个机器学习模型\nBuilding your first model. Hurray!\n\n选择建模的数据一条数据有很多变量，如何选择合适的变量？我们先用直觉选几个变量。后面的课程将展示自动确定变量优先级的统计技术。\n首先需要查看数据集中所有列的列表。通过 DataFrame 的 columns 属性完成：\nimport pandas as pdmelbourne_file_path = &#x27;../input/melbourne-housing-snapshot/melb_data.csv&#x27;melbourne_data = pd.read_csv(melbourne_file_path) print(melbourne_data.columns)\nIndex([&#x27;Suburb&#x27;, &#x27;Address&#x27;, &#x27;Rooms&#x27;, &#x27;Type&#x27;, &#x27;Price&#x27;, &#x27;Method&#x27;, &#x27;SellerG&#x27;,       &#x27;Date&#x27;, &#x27;Distance&#x27;, &#x27;Postcode&#x27;, &#x27;Bedroom2&#x27;, &#x27;Bathroom&#x27;, &#x27;Car&#x27;,       &#x27;Landsize&#x27;, &#x27;BuildingArea&#x27;, &#x27;YearBuilt&#x27;, &#x27;CouncilArea&#x27;, &#x27;Lattitude&#x27;,       &#x27;Longtitude&#x27;, &#x27;Regionname&#x27;, &#x27;Propertycount&#x27;],      dtype=&#x27;object&#x27;)\n某些数据可能有缺失值，后续课程会解决缺失值。这里简单地删除有缺失的数据，通过 .dropna()：\nmelbourne_data = melbourne_data.dropna(axis=0)\n注意 .dropna() 不会在当前 DataFrame 上进行修改，而是会返回一个新的对象，所以需要赋值给新对象。\n获取 DataFrame 子集的方法：\n\n使用点 .\n使用一个列名列表\n\n选择预测目标通过点 . 来访问某个变量的数据。这些数据存储在一个 Series 中，它大致类似于只有单列数据的 DataFrame 。需要预测的变量为 Price ，定义为y：\ny = melbourne_data.Price\n\n选择特征“特征”定义为输入模型的数据列，并后续用于预测。使用列名列表来获取，并定义为 x：\nmelbourne_features = [&#x27;Rooms&#x27;, &#x27;Bathroom&#x27;, &#x27;Landsize&#x27;, &#x27;Lattitude&#x27; &#x27;Longtitude&#x27;]x = melbourne_data[melbourne_features]\n使用 .head() 方法查看头部几个样本：\nx.head()\n\n构建模型使用 scikit-learn 包来创建模型。代码中写作 sklearn。\n通过以下步骤来构建模型：\n\n定义：模型类型、模型参数\n拟合（训练）：从数据中学习模式\n预测：Just what it sounds like（原文🤔）\n评估：确定模型的准确度\n\n一个简单的例子：\nfrom sklearn.tree import DecisionTreeRegressor# Define model. Specify a number for random_state to ensure same results each runmelbourne_model = DecisionTreeRegressor(random_state=1)# Fit modelmelbourne_model.fit(X, y)\n\n设置 random_state 确保在每一个轮次中获取相同的结果。但是模型的性能和这个数字无关。\n现在使用训练好的模型来预测输入的前 5 个数据：\nmelbourne_model.predict(X.head())\n模型验证\nMeasure the performance of your model, so you can test and compare alternatives.\n\n什么是模型验证许多人在衡量预测准确性时犯了一个巨大的错误。他们用训练数据进行预测，并将这些预测与训练数据中的目标值进行比较。稍后您将看到这种方法的问题以及如何解决它，但让我们先考虑一下如何做这个。\n考虑最简单的平均绝对误差（Mean Absolute Error, MAE）：\nerror = actual - predicted\n\n使用 scikit-learn 计算 MAE：\nfrom sklearn.metrics import mean_absolute_errorpredicted_home_prices = melbourne_model.predict(X)mean_absolute_error(y, predicted_home_prices)\n\n“In-Sample”分数的问题前面提到的评价方式是一种“样本内”分数（in-sample）。是同统一数据来训练和预测。想象以下场景：\n\n在大型房地产市场中，门的颜色与房价无关。然而，在您用于构建模型的数据样本中，所有带有绿色门的房屋都非常昂贵。这个模型的工作是找到预测房价的模式，所以它会看到这个模式，它总是会预测绿色门的房屋的高价格。由于该模式是从训练数据中导出的，因此该模型在训练数据中会显得准确。但是，如果当模型看到新的数据时，这种模式不成立，那么在实际使用时，模型将非常不准确。\n\n由于模型的实用价值来自于对新数据的预测，因此我们在未用于构建模型的数据上衡量性能。要做到这一点，最直接的方法是从模型构建过程中排除一些数据，然后使用这些数据来测试模型对以前没有见过的数据的准确性。这些数据称为验证数据（validation data）。\nCoding it!scikit-learn 提供了 train_test_solit 方法来划分训练集和测试集。\nfrom sklearn.model_selection import train_test_split# split data into training and validation data, for both features and target# The split is based on a random number generator. Supplying a numeric value to# the random_state argument guarantees we get the same split every time we# run this script.train_X, val_X, train_y, val_y = train_test_split(X, y, random_state = 0, test_size=0.2)# Define modelmelbourne_model = DecisionTreeRegressor()# Fit modelmelbourne_model.fit(train_X, train_y)# get predicted prices on validation dataval_predictions = melbourne_model.predict(val_X)print(mean_absolute_error(val_y, val_predictions))\n\n通过设置 test_size 来更改测试集的比例。\nWow!经过测试，样本内数据的平均绝对误差约为500美元，而样本外超过25万美元！\n欠拟合和过拟合\nFine-tune your model for better performance.\n\n实验不同模型两个极端\n\n当我们把房子分成许多片叶子时，每片叶子上的房子也更少。房子很少的树叶会做出非常接近这些房子的实际价值的预测，但它们对新数据的预测可能非常不可靠（因为每次预测都只基于几所房子）。\n这是一种被称为过拟合的现象，即模型几乎完美地匹配训练数据，但在验证和其他新数据方面表现不佳。另一方面，如果我们把树画得很浅，它就不会把房子分成很明显的组。\n\n\n如果一棵树只把房子分成2个或4个，每一组仍然有各种各样的房子。对大多数机构来说，结果预测可能还很遥远，甚至在训练数据中也是如此（出于同样的原因，它在验证中也会很糟糕）。\n当一个模型无法捕捉数据中的重要区别和模式，因此即使在训练数据中也表现不佳，这被称为欠拟合。\n\n\n\n例子通过设置不同数量的决策树结点数量 max_leaf_nodes，计算出不同的精确率。\nfrom sklearn.metrics import mean_absolute_errorfrom sklearn.tree import DecisionTreeRegressordef get_mae(max_leaf_nodes, train_X, val_X, train_y, val_y):    model = DecisionTreeRegressor(max_leaf_nodes=max_leaf_nodes, random_state=0)    model.fit(train_X, train_y)    preds_val = model.predict(val_X)    mae = mean_absolute_error(val_y, preds_val)    return(mae)\n\n结论两种情况：\n\n过拟合：捕捉未来不会再出现的虚假模式，导致预测不那么准确\n欠拟合：无法捕捉相关的模式，同样导致预测不准确\n\n随机森林\nUsing a more sophisticated machine learning algorithm.\n\n引入决策树留给你一个艰难的决定。有很多叶子的深树会过拟合，因为每个预测都是来自叶子附近的少数房屋的历史数据。但是一棵叶子很少的浅树会表现得很差，因为它无法在原始数据中捕捉到尽可能多的区别。\n即使是今天最复杂的建模技术也面临着欠拟合和过拟合之间的紧张关系。但是，许多模型都有聪明的想法，可以带来更好的性能。我们将以随机森林为例。\n随机森林使用许多树，它通过平均每个组成树的预测来进行预测。它通常比单一决策树具有更好的预测准确性，并且在默认参数下工作得很好。\nfrom sklearn.ensemble import RandomForestRegressorfrom sklearn.metrics import mean_absolute_errorforest_model = RandomForestRegressor(random_state=1)forest_model.fit(train_X, train_y)melb_preds = forest_model.predict(val_X)print(mean_absolute_error(val_y, melb_preds))\n结论可能还有进一步改进的空间，但这已经比25万的最佳决策树误差有了很大的改进。有一些参数允许你改变随机森林的性能，就像我们改变单个决策树的最大深度一样。但随机森林模型的一个最佳特征是，即使没有这种调整，它们通常也能合理地工作。\n机器学习比赛\nEnter the world of machine learning competitions to keep improving and see your progress.\n\nIt’s your turn!\n","categories":["Kaggle courses"],"tags":["Kaggle","Pandas","Python"]},{"title":"【Kaggle Courses】1-编程介绍","url":"/blog/Kaggle-course/intro-to-programming/","content":"Get started with Python, if you have no coding experience. Click here for more information.\n\n\n计算和变量\nMake calculations, and define and modify variables.\n\n打印打印一条消息。\nprint(&#x27;hello&#x27;)\n计算打印计算结果。\nprint(1 + 2)\n注释使用 # 写注释。\n函数\nOrganize your code and avoid redundancy.\n\n一个简单的例子def add_three(input_var):    output_var = input_var + 3    return output_var\n函数包含两个部分: header 和 body.\n\nHeader: 定义函数名和参数。\nBody: 定义函数如何工作。\n\n变量作用域函数内部定义的变量无法在函数外访问。\n数据类型\nExplore integers, floats, booleans, and strings.\n\nint, float, boolean, string\n条件和条件声明\nModify how functions run, depending on the input.if, if-else, if-elif-else\n\n列表介绍\nOrganize your data so you can work with it efficiently.\n\n索引\n获取最后一个元素: [-1]\n获取倒数第二个元素: [-2]\n\n切片切片：获取列表的一个片段。\n\n获取前 x 个元素：[:x]\n获取后 y 个元素：[-y:]\n\n此处“元素”的英文为“entry”。\nl = [1, 2, 3, 4, 5]print(l[:2])print(l[-2:])\n[1, 2][4, 5]\n删除使用 .remove()\n添加使用 .add()\n","categories":["Kaggle courses"],"tags":["Kaggle","Python"]},{"title":"【Kaggle Courses】4-pandas","url":"/blog/Kaggle-course/pandas-kaggle/","content":"Solve short hands-on challenges to perfect your data manipulation skills. Click here for more information.\n\n创建、读和写\nYou can’t work with data if you can’t read it. Get started here.\n\n开始导入 pandas：\nimport pandas as pd\n创建数据Pandas 中的两个核心对象：DataFrame 和 Series。\nDataFrameDataFrame 是一个表。它包含一个单独条目（entry）的数组，每个条目都有一个特定的值。每个条目对应一行（或记录）和一列。例如：\npd.DataFrame(&#123;&#x27;Yes&#x27;: [50, 21], &#x27;No&#x27;: [131, 2]&#125;)\n在本例中，“0，No” 条目的值为 131 。“0，Yes” 条目的值为 50，以此类推。数据框条目不限于整数。例如，下面是一个值为字符串的DataFrame：\npd.DataFrame(&#123;&#x27;Bob&#x27;: [&#x27;I liked it.&#x27;, &#x27;It was awful.&#x27;], &#x27;Sue&#x27;: [&#x27;Pretty good.&#x27;, &#x27;Bland.&#x27;]&#125;)\n\n我们使用 pd.DataFrame() 构造函数来生成这些 DataFrame 对象。声明一个新对象的语法是一个字典，它的键是列名（本例中是Bob和Sue），它的值是一个条目列表。这是构造新 DataFrame 的标准方法。\n字典列表构造函数将值赋给列标签，但对行标签来说，默认是从 0 开始的升序计数。\nDataFrame 中使用的行标签列表称为索引。可以通过在构造函数中使用 index 形参给它赋值：\npd.DataFrame(&#123;&#x27;Bob&#x27;: [&#x27;I liked it.&#x27;, &#x27;It was awful.&#x27;],               &#x27;Sue&#x27;: [&#x27;Pretty good.&#x27;, &#x27;Bland.&#x27;]&#125;,             index=[&#x27;Product A&#x27;, &#x27;Product B&#x27;])\n\nSeries相比之下，序列是数据值的序列。如果 DataFrame 是一个表，那么 Series 就是一个列表。只需要一个列表就可以创建一个 Series 对象：\npd.Series([1, 2, 3, 4, 5])\n\n从本质上讲，Series 是 DataFrame 的一列。因此，可以像以前一样使用 index 参数将行标签分配给 Series。但是， Series 没有列名，它只有一个总称：\npd.Series([30, 35, 40], index=[&#x27;2015 Sales&#x27;, &#x27;2016 Sales&#x27;, &#x27;2017 Sales&#x27;], name=&#x27;Product A&#x27;)\n\n读取数据数据可以以许多不同的形式和格式中的任何一种进行存储。到目前为止，其中最基本的是 CSV 文件。当你打开一个 CSV 文件时，你会看到这样的东西：\nProduct A,Product B,Product C,30,21,9,35,34,1,41,11,11\nCSV 文件本质上是一个用逗号分隔的值表。因此得名：Comma-Separated Values，CSV。\n读取并查看 CSV 文件：\nimport pandas as pddf = pd.read_csv(&#x27;file.csv&#x27;)df.shapedf.head()\n\n索引、选择和赋值\nPro data scientists do this dozens of times a day. You can, too!\n\n原生访问器原生 Python 对象提供了索引数据的方法。Pandas包含了所有这些内容：\ndf = pd.read_csv(&#x27;file.csv&#x27;)# 访问 country 列（访问一个 Series ）df.countrydf[&#x27;country&#x27;]# 访问该列的某个对象df[&#x27;country&#x27;][0]\nPandas 中的索引Pandas 有自己的索引方式 loc 。Pandas 索引的工作方式有两种。\n基于索引的选择iloc 基于数值位置选择数据。例如访问第一行的数据：\ndf.iloc[0]\n\nloc 和 iloc 都是行优先，这意味着检索行稍微容易一些，而获取检索列稍微困难一些。例如访问第一列的数据：\ndf.iloc[:, 0]\n\n更多例子：\n# 访问第二行和第三行的第一列df.iloc[1 : 3, 0]# 也可以是一个列表df.iloc[[1, 2], 0]\n\n基于标签的选择iloc 在概念上比 loc 简单，因为它忽略数据集的索引。当使用 iloc 时，我们将数据集视为一个大矩阵（列表的列表），我们必须根据位置对其进行索引。\n相比之下，loc 使用索引中的信息来完成工作。由于数据集通常包含有意义的索引，因此使用loc通常更容易。例如，访问所有行的以下属性：\ndf.loc[:, [&#x27;taster_name&#x27;, &#x27;taster_twitter_handle&#x27;, &#x27;points&#x27;]]\n\nloc 还是 iloc ？\niloc 使用标准的索引策略，0:10 的结果是 0,...,9，而 loc 的结果是 0,...,10。\nloc 可以这样用：df.loc[&#39;a&#39;:&#39;d&#39;] ，表示索引标签 a 到 d 之间的所有列。（包括 d）\niloc 索引数值位置，loc 索引标签，且 loc 包括“结尾”。\n\n操作索引Pandas 默认使用数字作为索引，可以通过 set_index() 将指定列设置为索引：\ndf = df.set_index(&quot;title&quot;)\n\n注意，重新设置索引之后要进行赋值。即不会在原来的基础上进行修改，而是会返回一个新的 DataFrame 对象。\n条件选择例如，假设我们对意大利生产的好于平均水平的葡萄酒特别感兴趣。\n我们首先需要检查每一瓶酒是否来自意大利：\ndf.country == &#x27;Italy&#x27;\n\n这个操作会返回一个全是布尔变量的 Series 对象。表示该行的 country 属性是否为 Italy 。\n接下来可以通过 loc 来选择对应的行：\ndf.loc[df.country == &#x27;Italy&#x27;]\n可以使用 &amp; 或者 | 来携带多个条件：\ndf.loc[(df.country == &#x27;Italy&#x27;) &amp; (reviews.points &gt;= 90)]\n\n此外，pandas 还提供了一些内置的选择器：isin() 和 isnull()\nisin() 选择那些值在给定列表里的数据。例如选取包含意大利和法国的行：\ndf.loc[df.country.isin([&#x27;Italy&#x27;, &#x27;France&#x27;])]# 等价于df.loc[(df.country == &#x27;Italy&#x27;) | (df.country == &#x27;France&#x27;)]\n\nisnull() 选择那些包含空值的行：\ndf.loc[df.price.isnull()]\n赋值给一整列赋值：\n# 将整列都赋值为 everyonereviews[&#x27;critic&#x27;] = &#x27;everyone&#x27;# 也可以使用可迭代的对象（list、range等）reviews[&#x27;index_backwards&#x27;] = range(len(reviews), 0, -1)\n\n总结函数和映射\nExtract insights from your data.\n\n总结函数使用 describe() 方法获取对数据的高级描述：\n对不同的数据类型，会有不同的总结，例如对字符串：\nmean() 方法：查看某一列的平均值。\nunique() 方法：查看某一列的唯一值列表。（对应于 describe 输出的 unique 关键字）\ncount() 方法：查看某一列的唯一值列表以及其出现次数。\n映射（Maps）批量修改某些列。\n例如，想要将某一列减去其均值：\nreview_points_mean = reviews.points.mean()reviews.points.map(lambda p: p - review_points_mean)\n传递给 map() 的函数应该期望得到来自 Series 的单个值（在上面的示例中是一个点值，即 p），并返回该值的转换版本（即 p - review_points_mean）。map（）返回一个新的 Series ，其中所有的值都已被函数转换过。\n这里 lambda 表示匿名函数，其等价于以下函数：\ndef my_function(p):    return p - review_points_mean\n\n同样地， apply() 方法同样可以实现上述过程：\ndef remean_points(row):    row.points = row.points - review_points_mean    return rowreviews.apply(remean_points, axis=&#x27;columns&#x27;)\n\n此外，也可以直接使用操作符 + 、 - 等直接对 Series 对象进行操作，这比上述两个函数更高效，但是不支持更复杂的情况。\n分组和排序\nScale up your level of insight. The more complex the dataset, the more this matters\n\n分组分析以下代码等同于 value_counts() 方法：\nreviews.groupby(&#x27;points&#x27;).points.count()\n\n即按照 points 列进行分组，分组之后再对 point 列进行计数。\nreviews.groupby(&#x27;points&#x27;).price.min()\n上述代码按照 points 列进行分组，分组之后，在每个组里面计算最小值。\n生成的每个组可以视为 DataFrame 的一个片段，其中仅包含具有匹配值的数据。可以直接使用 apply() 方法访问这个 DataFrame，然后可以通过任何方式操作数据。例如，下面是从数据集中的每个酒厂中选择第一个被评论的葡萄酒名称的一种方法：\nreviews.groupby(&#x27;winery&#x27;).apply(lambda df: df.title.iloc[0])\n\n对于更细粒度的，还可以按多个列分组。举个例子，以下是我们如何按国家和省份挑选最好的葡萄酒：\nreviews.groupby([&#x27;country&#x27;, &#x27;province&#x27;]).apply(lambda df: df.loc[df.points.idxmax()])\n\n排序简单排序（默认升序）：\ncountries_reviewed.sort_values(by=&#x27;len&#x27;)\n\n按照多个列进行排序：\ncountries_reviewed.sort_values(by=[&#x27;country&#x27;, &#x27;len&#x27;])\n\n数据类型和缺失值\nDeal with the most common progress-blocking problems\n\n数据类型DataFrame 或Series 中每列的数据类型称为 dtype 。可以使用 dtype 属性获取特定列的类型。\nreviews.price.dtype\n\ndtypes 属性返回 DataFrame 中每一列的数据类型。\nreviews.dtypes\n\n注意，字符串的类型为 object 。\n可以使用 astype() 方法进行数据转换：\nreviews.points.astype(&#x27;float64&#x27;)\n\n缺失值使用 fillna() 方法来替换缺失值。通常可以设置为“unkonwn”字符串，便于后续更改。这种值通常被称作“哨兵”，还包括“Undisclosed”、“Invalid”等。\n此外可以使用 replace() 方法来替换设置的哨兵值。\n重命名和组合\nData comes in from many sources. Help it all make sense together\n\n重命名有时需要更改列明或索引名。\n# 将 points 列更名为 scorereviews.rename(columns=&#123;&#x27;points&#x27;: &#x27;score&#x27;&#125;)# 将第一行和第二行更名为 firstEntry 和 secondEntryreviews.rename(index=&#123;0: &#x27;firstEntry&#x27;, 1: &#x27;secondEntry&#x27;&#125;)\n\n组合组合来自多个 DataFrame 或 Series 的数据。\n例如，两个 CSV 文件有相同的列，最简单的方法是 conca() 。\ncanadian_youtube = pd.read_csv(&quot;../input/youtube-new/CAvideos.csv&quot;)british_youtube = pd.read_csv(&quot;../input/youtube-new/GBvideos.csv&quot;)pd.concat([canadian_youtube, british_youtube])\n\n例如，组合两个具有相同索引的 CSV 文件：\nleft = canadian_youtube.set_index([&#x27;title&#x27;, &#x27;trending_date&#x27;])right = british_youtube.set_index([&#x27;title&#x27;, &#x27;trending_date&#x27;])left.join(right, lsuffix=&#x27;_CAN&#x27;, rsuffix=&#x27;_UK&#x27;)\nlsuffix 和 rsuffix 参数用于区分两个相同的列。\n简单读写 CSV 文件读import pandas as pddf = pd.read_csv(&#x27;./file.csv&#x27;)\n写for i, row in df.iterrows():    path = row[&#x27;path&#x27;]    label = row[&#x27;label&#x27;]\n新建data = &#123;    &#x27;path&#x27;: [&#x27;path1&#x27;, &#x27;path2&#x27;],    &#x27;label&#x27;: [&#x27;label1&#x27;, &#x27;label2&#x27;]&#125;    new_df = pd.DateFrame(data)new_df.to_csv(&#x27;./new_file.csv&#x27;, index=False)\nloc 方法定位某一行path = df.loc[index][&#x27;path&#x27;]\n\n定位某列的指定值df = df.loc[df[&#x27;label&#x27;] == &#x27;Normal&#x27;]df = df.reset_index()","categories":["Kaggle courses"],"tags":["Kaggle","Pandas","Python"]},{"title":"【LLM】nanoGPT学习","url":"/blog/LLM/nanogpt/","content":"写在前面本文主要记录 nanoGPT 的学习过程，参考链接\n\nGPT in 60 Lines of NumPy：https://jaykmody.com/blog/gpt-from-scratch/60 行代码实现 gpt（上一篇的翻译）： https://zhuanlan.zhihu.com/p/679330102nanoGPT 实战： https://zhuanlan.zhihu.com/p/716442447nanoGPT 代码解读：https://zhuanlan.zhihu.com/p/677407971\n\nGPT 原理\nGPT(Generative Pre-trained Transformer)基于Transformer解码器自回归地预测下一个Token，从而进行了语言模型的建模。GPT的伪代码可以简单的表示为：\n\ndef gpt(inputs: list[int]) -&gt; list[list[float]]:\t&quot;&quot;&quot; GPT代码，实现预测下一个token\tinputs：List[int], shape为[n_seq]，输入文本序列的token id的列表\toutput：List[List[int]], shape为[n_seq, n_vocab]，预测输出的logits列表\t&quot;&quot;&quot;    output = # 需要实现的GPT内部计算逻辑     return output\n\n即输入一段token\n\n关于 token\ntoken 可以理解为一个句子中最小的组成部分。通常为一个词，一些情况下，可以进行简化，例如后续使用莎士比亚的作品集进行训练时，将字符作为 token。\n\ntoken 通过分词器来获取，对应一个词汇表。最开始输入到模型中的序列其实为一串数字，表示当前 token 在词汇表中的位置。例如：\n# 词汇表中的token索引表示该token的整数ID# 例如，&quot;robot&quot;的整数ID为1，因为vocab[1] = &quot;robot&quot;vocab = [&quot;must&quot;, &quot;robot&quot;, &quot;obey&quot;, &quot;the&quot;, &quot;orders&quot;, &quot;.&quot;]# 进行分词的分词器tokenizer（假设通过空格来进行分词）tokenizer = WhitespaceTokenizer(vocab)# encode()方法将str字符串转换为list[int]ids = tokenizer.encode(&quot;robot must obey orders&quot;) # ids = [1, 0, 2, 4]# 通过词汇表映射，可以看到实际的token是什么tokens = [tokenizer.vocab[i] for i in ids] # tokens = [&quot;robot&quot;, &quot;must&quot;, &quot;obey&quot;, &quot;orders&quot;]# decode()方法将list[int] 转换回strtext = tokenizer.decode(ids) # text = &quot;robot must obey orders&quot;\n\n同样，输出为一个二维数组，表示当前位置不同 token 的出现概率。output 是一个二维数组，其中 output[i][j] 表示文本序列的第 i 个位置的 token（inputs[i]）是词汇表的第 j 个 token（vocab[j]）的概率（实际为未归一化的logits得分）。例如：\ninputs = [1, 0, 2, 4]  # &quot;robot&quot; &quot;must&quot; &quot;obey&quot; &quot;orders&quot;vocab = [&quot;must&quot;, &quot;robot&quot;, &quot;obey&quot;, &quot;the&quot;, &quot;orders&quot;, &quot;.&quot;]output = gpt(inputs)# output[0] = [0.75, 0.1, 0.15, 0.0, 0.0, 0.0]# 给定 &quot;robot&quot;，模型预测 &quot;must&quot; 的概率最高# output[1] = [0.0, 0.0, 0.8, 0.1, 0.0, 0.1]# 给定序列 [&quot;robot&quot;, &quot;must&quot;]，模型预测 &quot;obey&quot; 的概率最高# output[-1] = [0.0, 0.0, 0.1, 0.0, 0.85, 0.05]# 给定整个序列[&quot;robot&quot;, &quot;must&quot;, &quot;obey&quot;]，模型预测 &quot;orders&quot; 的概率最高next_token_id = np.argmax(output[-1])  # next_token_id = 4next_token = vocab[next_token_id]      # next_token = &quot;orders&quot;\n在推理时（生成文本），首先将 prompt 输入 GPT，然后迭代地将上一轮的输出放到当前的末尾，重复生成。例如：\ndef generate(inputs, n_tokens_to_generate):\t&quot;&quot;&quot; GPT生成代码\tinputs: list[int], 输入文本的token ids列表\tn_tokens_to_generate：int, 需要生成的token数量\t&quot;&quot;&quot;    # 自回归式解码循环    for _ in range(n_tokens_to_generate):         output = gpt(inputs)            # 模型前向推理，输出预测词表大小的logits列表        next_id = np.argmax(output[-1]) # 贪心采样        inputs.append(int(next_id))     # 将预测添加回输入    return inputs[len(inputs) - n_tokens_to_generate :]  # 只返回生成的ids# 随便举例input_ids = [1, 0, 2]                          # [&quot;robot&quot;, &quot;must&quot;, &quot;obey&quot;]output_ids = generate(input_ids, 1)            #  output_ids = [1, 0, 2, 4]output_tokens = [vocab[i] for i in output_ids] # [&quot;robot&quot;, &quot;must&quot;, &quot;obey&quot;, &quot;orders&quot;]\n\n代码首先，最外层调用的是 GPT 类。调用方法为：\nlogits, loss = model(X, Y)\n其中 X，Y 表示输入以及其对应的标签，注意这里已经为 int 类型的数组了（表示 token 在词汇表中的位置）。\nGPT 类整体结构def forward(self, idx, targets=None):    device = idx.device    b, t = idx.size()    assert t &lt;= self.config.block_size, f&quot;Cannot forward sequence of length &#123;t&#125;, block size is only &#123;self.config.block_size&#125;&quot;    pos = torch.arange(0, t, dtype=torch.long, device=device)    tok_emb = self.transformer.wte(idx)     pos_emb = self.transformer.wpe(pos)     x = self.transformer.drop(tok_emb + pos_emb)    for block in self.transformer.h:        x = block(x)    x = self.transformer.ln_f(x)    if targets is not None:        logits = self.lm_head(x)        loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)    else:        logits = self.lm_head(x[:, [-1], :]) # note: using list [-1] to preserve the time dim        loss = None    return logits, loss\n\n输入 idx 类型为 list[int]，表示输入 token 在词汇表中的索引，并且有 batch 维度。此处有一个断言，即要求序列的长度要小于块长度，即 block_size 表示模型能处理的最大长度。\n新建一个位置数组 pso，用于计算位置编码。\n接下来为核心代码 self.transformer，实现如下self.transformer = nn.ModuleDict(dict(    wte = nn.Embedding(config.vocab_size, config.n_embd),    wpe = nn.Embedding(config.block_size, config.n_embd),    drop = nn.Dropout(config.dropout),    h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),    ln_f = LayerNorm(config.n_embd, bias=config.bias),))\n其包含 5 个部分：token 编码（word token embedding, wte）、位置编码（word position embedding, wpe）、dropout、注意力块（block）和层归一化。\n整体处理流程为：\ntoken 编码 + 位置编码，并相加\n依次通过注意力层\n经过最终的映射层（将注意力的输出映射到词汇表维度）\n最后进行判断是否计算 loss\n\n\n\ntoken 编码和位置编码\ntoken 编码：wte 是一个 [n_vocab, n_embd] 大小的可学习参数矩阵，它充当一个 token 嵌入查找表，其中矩阵的第 i 对应于词汇表中第 i 个 token 的 embedding。\nwte[idx] 使用 Token Ids 列表索引来检索与输入中每个token对应的向量。\n\n\n位置编码：表示序列的先后信息，同样是一个 [n_block, n_embd] 大小的可学习参数矩阵。\n\nBlock 类\nBlock 类的实现如下：class Block(nn.Module):    def __init__(self, config):        super().__init__()        self.ln_1 = LayerNorm(config.n_embd, bias=config.bias)        self.attn = CausalSelfAttention(config)        self.ln_2 = LayerNorm(config.n_embd, bias=config.bias)        self.mlp = MLP(config)    def forward(self, x):        x = x + self.attn(self.ln_1(x))        x = x + self.mlp(self.ln_2(x))        return x\n其主要包含两个层归一化、MLP和注意力层。\n\nCausalSelfAttention 类实现注意力机制的核心类。\ndef forward(self, x):    B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)    # calculate query, key, values for all heads in batch and move head forward to be the batch dim    q, k, v  = self.c_attn(x).split(self.n_embd, dim=2)    k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)    q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)    v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)    # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -&gt; (B, nh, T, T)    if self.flash:        # efficient attention using Flash Attention CUDA kernels        y = torch.nn.functional.scaled_dot_product_attention(q, k, v, attn_mask=None, dropout_p=self.dropout if self.training else 0, is_causal=True)    else:        # manual implementation of attention        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float(&#x27;-inf&#x27;))        att = F.softmax(att, dim=-1)        att = self.attn_dropout(att)        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -&gt; (B, nh, T, hs)    y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side    # output projection    y = self.resid_dropout(self.c_proj(y))    return y\n\nself.c_attn(x) 表示为注意力机制的映射层，并将 Q、K、V 三个映射层合并为一个，减少计算量。计算出映射矩阵后再进行划分。\nself.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd, bias=config.bias)\n\n接下来根据 head 的数量对映射矩阵进行划分。然后就是计算注意力。\n\n注意，为了实现因果机制，即模型只能看到当前 token 之前的 token，需要将计算出的 attn 矩阵 mask 一部分。\n# 输入是 [&quot;not&quot;, &quot;all&quot;, &quot;heroes&quot;, &quot;wear&quot;, &quot;capes&quot;] # 原始自注意力        not    all   heroes  wear  capes   not 0.116  0.159  0.055  0.226  0.443   all 0.180  0.397  0.142  0.106  0.175heroes 0.156  0.453  0.028  0.129  0.234  wear 0.499  0.055  0.133  0.017  0.295 capes 0.089  0.290  0.240  0.228  0.153 # 因果自注意力 （行为j, 列为i） # 为防止输入的所有查询都能预测未来，需要将所有j&gt;i位置设置为0 ：        not    all   heroes  wear  capes   not 0.116  0.     0.     0.     0.   all 0.180  0.397  0.     0.     0.heroes 0.156  0.453  0.028  0.     0.  wear 0.499  0.055  0.133  0.017  0. capes 0.089  0.290  0.240  0.228  0.153 # 在应用 softmax 之前，我们需要修改我们的注意力矩阵，得到掩码自注意力 # 即，在softmax之前将要屏蔽项的注意力得分设置为 −∞（归一化系数为0） # mask掩码矩阵 0 -1e10 -1e10 -1e10 -1e10 0   0   -1e10 -1e10 -1e10 0   0     0   -1e10 -1e10 0   0     0     0   -1e10 0   0     0     0     0 使用 -1e10 而不是 -np.inf ，因为 -np.inf 可能会导致 nans\n\n至此，整个 GPT 的结构拆解完毕。\n","categories":["LLM"],"tags":["LLM"]},{"title":"【Smol Course】1-指令调优","url":"/blog/LLM/smol1/","content":"Chat templateMessage and model以下代码定义了一条消息，包括用户和大模型两个角色。\nmessages = [    &#123;        &quot;role&quot;: &quot;user&quot;,         &quot;content&quot;: &quot;Hello, how are you?&quot;&#125;,    &#123;        &quot;role&quot;: &quot;assistant&quot;,        &quot;content&quot;: &quot;I&#x27;m doing well, thank you! How can I assist you today?&quot;,    &#125;,]\n模型包括两个部分：model（decoder）和 tokenizer。\nfrom transformers import AutoModelForCausalLM, AutoTokenizerfrom trl import setup_chat_formatimport torchdevice = (    &quot;cuda&quot;    if torch.cuda.is_available()    else &quot;mps&quot; if torch.backends.mps.is_available() else &quot;cpu&quot;)model_name = &quot;D:\\study\\smol-course\\data\\SmolLM2-135M&quot;model = AutoModelForCausalLM.from_pretrained(    pretrained_model_name_or_path=model_name).to(device)tokenizer = AutoTokenizer.from_pretrained(pretrained_model_name_or_path=model_name)model, tokenizer = setup_chat_format(model=model, tokenizer=tokenizer)\n\n注意这里的 setup_chat_format 方法，通过添加特殊的 token 来设置模型的聊天模板。\nApply chat template使用 tokenizer 的 apply_chat_template 方法将定义的 message（list）转换为带特殊 token 的字符串：\ninput_text = tokenizer.apply_chat_template(messages, tokenize=False)print(&quot;Conversation with template:\\n&quot;, input_text)\n\n结果为：\n\n&lt;|im_start|&gt;userHello, how are you?&lt;|im_end|&gt;&lt;|im_start|&gt;assistantI’m doing well, thank you! How can I assist you today?&lt;|im_end|&gt;  \n\n如果将 tokenize 参数设置为 true，则会将 token 映射为 token 表中的 id。可以使用 tokenizer 的 decode 方法将 id 转换为 token。\ninput_text = tokenizer.apply_chat_template(    messages, tokenize=True, add_generation_prompt=True)print(&quot;Conversation decoded:&quot;, tokenizer.decode(token_ids=input_text))\n\n此外，apply_chat_template 还有一个参数 为 add_generation_prompt，作用是添加下一条消息的开头，即下面结果的最后一行 &lt;|im_start|&gt;assistant 。 \n\nConversation decoded: &lt;|im_start|&gt;userHello, how are you?&lt;|im_end|&gt;&lt;|im_start|&gt;assistantI’m doing well, thank you! How can I assist you today?&lt;|im_end|&gt;&lt;|im_start|&gt;assistant  \n\nProcess datatset for SFT为现有的数据集添加聊天模板。\n案例 1首先加载数据集并打印\nfrom datasets import load_datasetds = load_dataset(&quot;HuggingFaceTB/smoltalk&quot;, &quot;everyday-conversations&quot;, cache_dir=&quot;D:\\study\\smol-course\\data&quot;)print(ds)\n\n结果为如下，包含两个部分，分别为测试集和训练集。\n\nDatasetDict({\n     train: Dataset({\n         features: ['full_topic', 'messages'],\n         num_rows: 2260\n     })\n     test: Dataset({\n         features: ['full_topic', 'messages'],\n         num_rows: 119\n     })\n})\n\n\n这里的 message 就是一个包含了用户和大模型之间对话的 list，内容如下，可以直接应用聊天模板。\n\n[{‘content’: ‘Hi there’, ‘role’: ‘user’}, {‘content’: ‘Hello! How can I help you today?’, ‘role’: ‘assistant’}, {‘content’: “I’m looking for a beach resort for my next vacation. Can you recommend some popular ones?”, ‘role’: ‘user’}, {‘content’: “Some popular beach resorts include Maui in Hawaii, the Maldives, and the Bahamas. They’re known for their beautiful beaches and crystal-clear waters.”, ‘role’: ‘assistant’}, {‘content’: ‘That sounds great. Are there any resorts in the Caribbean that are good for families?’, ‘role’: ‘user’}, {‘content’: ‘Yes, the Turks and Caicos Islands and Barbados are excellent choices for family-friendly resorts in the Caribbean. They offer a range of activities and amenities suitable for all ages.’, ‘role’: ‘assistant’}, {‘content’: “Okay, I’ll look into those. Thanks for the recommendations!”, ‘role’: ‘user’}, {‘content’: “You’re welcome. I hope you find the perfect resort for your vacation.”, ‘role’: ‘assistant’}]\n\n应用聊天模板的代码为：\ndef process_dataset(sample):    # TODO: 🐢 Convert the sample into a chat format    # use the tokenizer&#x27;s method to apply the chat template    sample = tokenizer.apply_chat_template(sample[&quot;messages&quot;], tokenize=False)        return &#123;&quot;chat&quot;: sample&#125;ds = ds.map(process_dataset)print(ds)\n\n上述代码定义一个 process_dataset 函数，用于处理数据集。map 方法对数据集中的每个样本都执行给定的函数。此外，map 是更新式映射，希望返回一个字典，添加到原有的数据集字典中。上述代码的结果为：\nDatasetDict({\n    train: Dataset({\n        features: ['full_topic', 'messages', 'chat'],\n        num_rows: 2260\n    })\n    test: Dataset({\n        features: ['full_topic', 'messages', 'chat'],\n        num_rows: 119\n    })\n})\n\n可以看到，原有的数据集字典中新增了一个字段 chat，内容为添加了聊天模板的字符串。\n案例 2本数据集包含了一个问题和相应的回答，所以在 process_dataset 函数中要先定义一个 message，然后再将 message 转换为带头聊天模板的字符串。\nds = load_dataset(&quot;openai/gsm8k&quot;, &quot;main&quot;, cache_dir=&quot;D:\\study\\smol-course\\data&quot;)print(ds)def process_dataset(sample):    # TODO: 🐕 Convert the sample into a chat format    # 1. create a message format with the role and content    message = [        &#123;&#x27;role&#x27;: &#x27;user&#x27;, &#x27;content&#x27;: sample[&#x27;question&#x27;]&#125;,        &#123;&#x27;role&#x27;: &#x27;assistant&#x27;, &#x27;content&#x27;: sample[&#x27;answer&#x27;]&#125;    ]    # 2. apply the chat template to the samples using the tokenizer&#x27;s method    sample = tokenizer.apply_chat_template(message, tokenize=False)    return &#123;&quot;chat&quot;: sample&#125;ds = ds.map(process_dataset)print(ds)\n\n结果为：\nDatasetDict({\n    train: Dataset({\n        features: ['question', 'answer'],\n        num_rows: 7473\n    })\n    test: Dataset({\n        features: ['question', 'answer'],\n        num_rows: 1319\n    })\n})\nDatasetDict({\n    train: Dataset({\n        features: ['question', 'answer', 'chat'],\n        num_rows: 7473\n    })\n    test: Dataset({\n        features: ['question', 'answer', 'chat'],\n        num_rows: 1319\n    })\n})\n\n\nSupervised Fine-tuning with SFTTrainerPreparation包含以下部分：\n\ndevice\nmodel\ntokenizer\n设置聊天模板\n\n# Import necessary librariesfrom transformers import AutoModelForCausalLM, AutoTokenizerfrom datasets import load_datasetfrom trl import SFTConfig, SFTTrainer, setup_chat_formatimport torchdevice = (    &quot;cuda&quot;    if torch.cuda.is_available()    else &quot;mps&quot; if torch.backends.mps.is_available() else &quot;cpu&quot;)# Load the model and tokenizermodel_name = &quot;D:\\study\\smol-course\\data\\SmolLM2-135M&quot;model = AutoModelForCausalLM.from_pretrained(    pretrained_model_name_or_path=model_name).to(device)tokenizer = AutoTokenizer.from_pretrained(pretrained_model_name_or_path=model_name)# Set up the chat formatmodel, tokenizer = setup_chat_format(model=model, tokenizer=tokenizer)\n\nGenerate with base model\n构建 message，然后使用 tokenizer 的 apply_chat_template 方法先将形式为字典的 message 转换为带特殊符号的字符串。\nprompt = &quot;Write me a haiku about programming&quot;# Format with templatemessages = [&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt&#125;]formatted_prompt = tokenizer.apply_chat_template(messages, tokenize=False)# &lt;|im_start|&gt;userWrite me a haiku about programming&lt;|im_end|&gt;\n\n然后再进行 tokenize 处理，tokenizer 返回字典，包括 token 的编码以及一个 mask，用于表示哪些位置是 padding\n\n\ninputs = tokenizer(formatted_prompt, return_tensors=&quot;pt&quot;).to(device)# inputs# &#123;#   &#x27;input_ids&#x27;: tensor([[101, ..., 102]]), token 的编号#   &#x27;attention_mask&#x27;: tensor([[1, 1, ..., 1]]) 有效 token 掩码（当输入长度不足最大长度时，tokenizer 会自动补齐（padding），然后用 attention_mask 避免模型在计算 self-attention 时把这些 padding 位置也考虑进来）# &#125;\n\n生成回答：model.generate 需要多个参数，** 就是自动帮你把字典拆开一个个传进去。\nskip_special_tokens&#x3D;True 表示 decode 时忽略 chat template 中的特殊字符\n生成的 outputs 为一个 list，需要取第 0 个元素（why？），同样为 token 的 编号，通过 decode 方法映射到文本。outputs = model.generate(**inputs, max_new_tokens=100)print(tokenizer.decode(outputs[0], skip_special_tokens=True))\n\n\n\nDataset给定的数据集中已经有 dict 格式的 message，只需要对每条 message 做处理，将其生成为一个带特殊符号的字符串即可。注意最后的结果是多了一个 chat 字段。\ndef process_dataset(sample):    sample = tokenizer.apply_chat_template(sample[&quot;messages&quot;], tokenize=False)        return &#123;&quot;chat&quot;: sample&#125;print(ds[&#x27;train&#x27;][0])&quot;&quot;&quot;&#123;&#x27;full_topic&#x27;: &#x27;Travel/Vacation destinations/Beach resorts&#x27;, &#x27;messages&#x27;: ...&#125;&quot;&quot;&quot;ds = ds.map(process_dataset)print(ds[&#x27;train&#x27;][0])# 多了一个字段 chat&quot;&quot;&quot;&#123;&#x27;full_topic&#x27;: &#x27;Travel/Vacation destinations/Beach resorts&#x27;, &#x27;messages&#x27;: ..., &#x27;chat&#x27;: &quot;...&quot;&#125;&quot;&quot;&quot;\n\nTrain model设置 SFTConfig 和 SFTTrainer。注意，尽量将所有的参数都写在 SFTConfig 中。\n# Configure the SFTTrainersft_config = SFTConfig(    dataset_text_field=&quot;chat&quot;, # 设置作为数据集的字段    max_seq_length=512, # 最大的序列长度    output_dir=&quot;./sft_output&quot;,    max_steps=1000,  # 最大训练步数    per_device_train_batch_size=4,  # batch    learning_rate=5e-5,  # 学习率    logging_steps=10,  # 每 10 步计算一次训练的 log    save_steps=100,  # 每 100 步保存一次    eval_strategy=&quot;steps&quot;,  # 评估周期的单位    eval_steps=50,  # 每 50 步评估一次    use_mps_device=(        True if device == &quot;mps&quot; else False    ),  # Use MPS for mixed precision training    hub_model_id=finetune_name,  # 设置本次训练的名字)# Initialize the SFTTrainertrainer = SFTTrainer(    model=model,    args=sft_config,    train_dataset=ds[&quot;train&quot;],    tokenizer=tokenizer,    eval_dataset=ds[&quot;test&quot;],)\n\n训练并保存模型\n# Train the modeltrainer.train()# Save the modeltrainer.save_model(f&quot;./&#123;finetune_name&#125;&quot;)\n\nGenerate with trained model代码和前面的相似\nmodel_path = &quot;D:/study/smol-course/1_instruction_tuning/notebooks/SmolLM2-FT-MyDataset&quot;# Load the model and tokenizermodel = AutoModelForCausalLM.from_pretrained(    pretrained_model_name_or_path=model_path).to(device)tokenizer = AutoTokenizer.from_pretrained(pretrained_model_name_or_path=model_path)# Set up the chat format# model, tokenizer = setup_chat_format(model=model, tokenizer=tokenizer)prompt = &quot;Write a haiku about programming&quot;# Format with templatemessages = [&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt&#125;]formatted_prompt = tokenizer.apply_chat_template(messages, tokenize=False)# Generate responseinputs = tokenizer(formatted_prompt, return_tensors=&quot;pt&quot;).to(device)outputs = model.generate(**inputs, max_new_tokens=100)print(&quot;After training:&quot;)print(tokenizer.decode(outputs[0], skip_special_tokens=True))\n\n注意，训练后的模型就不需要 setup_chat_format 了。因为在训练之前已经设置过，并保存到了相应的 json 文件中。验证如下：\nori_tokenizer = AutoTokenizer.from_pretrained(pretrained_model_name_or_path=&quot;D:\\study\\smol-course\\data\\SmolLM2-135M&quot;)print(&quot;before training: &quot;, ori_tokenizer.chat_template)# Noneprint(&quot;after training: &quot;, tokenizer.chat_template)# &#123;% for message in messages %&#125;&#123;&#123;&#x27;&lt;|im_start|&gt;&#x27; + message[&#x27;role&#x27;] + &#x27;# &#x27; + message[&#x27;content&#x27;] + &#x27;&lt;|im_end|&gt;&#x27; + &#x27;# &#x27;&#125;&#125;&#123;% endfor %&#125;&#123;% if add_generation_prompt %&#125;&#123;&#123; &#x27;&lt;|im_start|&gt;assistant# &#x27; &#125;&#125;&#123;% endif %&#125;","categories":["LLM"],"tags":["trl","smol"]},{"title":"【Smol Course】2-偏好对齐","url":"/blog/LLM/smol2/","content":"Preference Alignment监督微调有助于模型学习任务，但偏好对齐鼓励输出符合人类的期望和价值观。\n\nDirect Preference Optimization (DPO)：直接偏好优化（DPO）通过使用偏好数据直接优化模型来简化偏好对齐。这种方法消除了对单独的奖励模型和复杂的强化学习的需要，使其比传统的基于人类反馈的强化学习（RLHF）更加稳定和高效。\nOdds Ratio Preference Optimization (ORPO)：ORPO在单个进程中引入了指令调优和偏好对齐的组合方法。它通过在 token 级别上将负对数似然损失与比值比项结合起来，修改了标准语言建模目标。该方法具有统一的单阶段训练过程、参考无模型架构和提高计算效率的特点。\n\nDPODPO 将偏好对齐重新定义为人类偏好数据的分类问题。传统的 RLHF 方法需要训练一个单独的奖励模型，并使用复杂的强化学习算法（如 PPO）来校准模型输出。DPO 通过定义一个损失函数来简化这一过程，该损失函数可以根据首选输出和非首选输出直接优化模型的策略。\nHow DPO worksDPO 过程需要监督微调（SFT）来使模型适应目标域。这为通过在标准指令遵循数据集上进行训练来进行偏好学习奠定了基础。该模型在保持其一般能力的同时学习基本任务的完成。\n接下来是偏好学习，其中模型在成对的输出上进行训练——一个是首选的，一个是非首选的。偏好对帮助模型理解哪种反应更符合人类的价值观和期望。\nDPO 的核心创新在于其直接优化方法。DPO 不是训练单独的奖励模型，而是使用二元交叉熵损失来直接更新基于偏好数据的模型权重。这种简化的过程使训练更加稳定和高效，同时达到与传统 RLHF 相当或更好的结果。\nDatasetDPO 的数据集通常是通过将响应对注释为首选或非首选来创建的。通常包含 prompt、chosen 和 selected 三部分。\nPrompt 包含用于生成 selected 和 Rejected 响应的提示。selected 和 Rejected 分别包含首选和非首选的响应。\nImplementation with TRL简单实现如下：\nfrom trl import DPOConfig, DPOTrainer# Define argumentstraining_args = DPOConfig(    ...)# Initialize trainertrainer = DPOTrainer(    model,    train_dataset=dataset,    tokenizer=tokenizer,    ...)# Train modeltrainer.train()\n\nPractice导入包import torchimport osfrom transformers import AutoModelForCausalLM, AutoTokenizerfrom datasets import load_datasetfrom trl import DPOTrainer, DPOConfig\n\n数据集设置 cache_dir 字段即可将其下载到指定目录。后续可以直接加载使用。\ndataset = load_dataset(&quot;argilla/ultrafeedback-binarized-preferences&quot;, split=&quot;train&quot;, cache_dir=&quot;D:\\study\\smol-course\\data&quot;)\n\n查看数据集，核心为 instruction、chosen_response 和 rejected_response。\n\nDataset({\n    features: ['source', 'instruction', 'chosen_response', 'rejected_response', 'chosen_avg_rating', 'rejected_avg_rating', 'chosen_model'],\n    num_rows: 63619\n})\n\n\n但是，chosen_response 和 rejected_response 只有回答，没有形成对话列表。所以需要定义处理数据集的函数：\ndef process_dataset(example):    chosen = [        &#123;            &#x27;role&#x27;: &#x27;user&#x27;,            &#x27;content&#x27;: example[&#x27;instruction&#x27;]        &#125;,        &#123;            &#x27;role&#x27;: &#x27;assistant&#x27;,            &#x27;content&#x27;: example[&#x27;chosen_response&#x27;]        &#125;    ]    rejected = [        &#123;            &#x27;role&#x27;: &#x27;user&#x27;,            &#x27;content&#x27;: example[&#x27;instruction&#x27;]        &#125;,        &#123;            &#x27;role&#x27;: &#x27;assistant&#x27;,            &#x27;content&#x27;: example[&#x27;rejected_response&#x27;]        &#125;    ]    return &#123;&#x27;chosen&#x27;: chosen, &#x27;rejected&#x27;: rejected, &#x27;prompt&#x27;: example[&quot;instruction&quot;]&#125;dataset = dataset.map(process_dataset)\n\n加载模型model_name = &quot;HuggingFaceTB/SmolLM2-135M-Instruct&quot;device = (    &quot;cuda&quot;    if torch.cuda.is_available()    else &quot;mps&quot; if torch.backends.mps.is_available() else &quot;cpu&quot;)# Model to fine-tunemodel = AutoModelForCausalLM.from_pretrained(    pretrained_model_name_or_path=model_name,    torch_dtype=torch.float32,).to(device)model.config.use_cache = Falsetokenizer = AutoTokenizer.from_pretrained(model_name)tokenizer.pad_token = tokenizer.eos_tokenmodel, tokenizer = setup_chat_format(model=model, tokenizer=tokenizer)# Set our name for the finetune to be saved &amp;/ uploaded tofinetune_name = &quot;SmolLM2-FT-DPO&quot;finetune_tags = [&quot;smol-course&quot;, &quot;module_1&quot;]\n\n注意：\n\nmodel.config.use_cache &#x3D; False：禁用 KV-cache（Key&#x2F;Value Cache）。通常在训练&#x2F;微调时禁用缓存（不然梯度计算会出错）；而在推理时开启以提升生成速度。\ntokenizer.pad_token &#x3D; tokenizer.eos_token：将 pad_token 设置为 eos_token（结束符）。原因：有些模型（如 GPT）没有专门定义 pad token，训练时又需要对序列进行 padding，这种情况下通常将 pad token 和 eos token 设为同一个。否则训练时可能会出现缺失 pad_token 的错误。\n这里需要设置聊天模板：model, tokenizer &#x3D; setup_chat_format(model&#x3D;model, tokenizer&#x3D;tokenizer)\n\n训练DPOConfig 参数\n# Training argumentstraining_args = DPOConfig(    # Training batch size per GPU    per_device_train_batch_size=4,    # Number of updates steps to accumulate before performing a backward/update pass    # Effective batch size = per_device_train_batch_size * gradient_accumulation_steps    gradient_accumulation_steps=4,    # Saves memory by not storing activations during forward pass    # Instead recomputes them during backward pass    gradient_checkpointing=True,    # Base learning rate for training    learning_rate=5e-5,    # Learning rate schedule - &#x27;cosine&#x27; gradually decreases LR following cosine curve    lr_scheduler_type=&quot;cosine&quot;,    # Total number of training steps    max_steps=200,    # Disables model checkpointing during training    save_strategy=&quot;no&quot;,    # How often to log training metrics    logging_steps=1,    # Directory to save model outputs    output_dir=&quot;smol_dpo_output&quot;,    # Number of steps for learning rate warmup    warmup_steps=100,    # Use bfloat16 precision for faster training    bf16=True,    # Disable wandb/tensorboard logging    report_to=&quot;none&quot;,    # Keep all columns in dataset even if not used    remove_unused_columns=False,    # Enable MPS (Metal Performance Shaders) for Mac devices    use_mps_device=device == &quot;mps&quot;,    # Model ID for HuggingFace Hub uploads    hub_model_id=finetune_name,    # DPO-specific temperature parameter that controls the strength of the preference model    # Lower values (like 0.1) make the model more conservative in following preferences    beta=0.1,    # Maximum length of the input prompt in tokens    max_prompt_length=1024,    # Maximum combined length of prompt + response in tokens    max_length=1536,)\n\n\nper_device_train_batch_size&#x3D;4：每个设备（GPU&#x2F;MPS）上的微调批大小是 4。若你使用多个 GPU 或 MPS，则总 batch size 会乘以设备数。\ngradient_accumulation_steps&#x3D;4：累积 4 个 mini-batch 的梯度再做一次反向传播。这样可以模拟 4×4&#x3D;16 的有效 batch size，节省显存。\ngradient_checkpointing&#x3D;True：启用梯度检查点技术：节省内存，通过在反向传播时重算中间激活来换取少量计算开销。\nlearning_rate&#x3D;5e-5：初始学习率。对于 LoRA + 微调一般推荐 1e-5 ~ 5e-5。\nlr_scheduler_type&#x3D;”cosine”：使用余弦退火学习率策略（cosine schedule）：初期缓慢增大，后期缓慢降低（类似 U 形曲线）。\nmax_steps&#x3D;200：总共进行 200 个训练 step。适合小规模调试或快速实验。\nsave_strategy&#x3D;”no”：不保存中间模型 checkpoint（节省空间，适合调试）。\nlogging_steps&#x3D;1：每 1 步打印一次日志（非常频繁，便于观察）。\noutput_dir&#x3D;”smol_dpo_output”：模型微调输出目录。\nwarmup_steps&#x3D;100：前 100 个 step 使用 warmup 策略逐渐提高学习率。可避免训练初期模型震荡。\nbf16&#x3D;True：使用 bfloat16 精度训练，适用于支持的设备（如 A100&#x2F;H100）。比 fp16 更稳定，适合 DPO。\nreport_to&#x3D;”none”：不启用日志追踪工具（如 WandB、TensorBoard）。\nremove_unused_columns&#x3D;False：保留所有输入字段，必要设置，因为 DPO 使用自定义字段（如 prompt, chosen, rejected）。\nuse_mps_device&#x3D;device &#x3D;&#x3D; “mps”：如果在 Mac 上使用 MPS 加速则设为 True。\nhub_model_id&#x3D;finetune_name：训练完成后模型上传到 Hugging Face Hub 的 ID 名（如 “my-org&#x2F;my-dpo-model”）。\nbeta&#x3D;0.1\tDPO 特有参数：控制 DPO loss 中 policy 与 reference 的对比强度。越小（如 0.1），偏好控制越严格（保守）；越大（如 1.0），更自由。\nmax_prompt_length&#x3D;1024：输入的 prompt 最大长度（token 数）。超过则截断。\nmax_length&#x3D;1536：prompt + 回复（chosen&#x2F;rejected）拼接后的最大总长度。\n\nDPOTrainer 参数：\ntrainer = DPOTrainer(    # The model to be trained    model=model,    # Training configuration from above    args=training_args,    # Dataset containing preferred/rejected response pairs    train_dataset=dataset,    # Tokenizer for processing inputs    processing_class=tokenizer,    # DPO-specific temperature parameter that controls the strength of the preference model    # Lower values (like 0.1) make the model more conservative in following preferences    # beta=0.1,    # Maximum length of the input prompt in tokens    # max_prompt_length=1024,    # Maximum combined length of prompt + response in tokens    # max_length=1536,)\n\nref_model：如果没有参考模型，则默认和 model 相同\nargs：将 DPOConfig 传入\ntrain_dataset：训练集。必须包含 prompt, chosen, rejected 三列\nbeta：控制 loss 中 π(chosen)&#x2F;π(rejected) 的敏感程度。\nbeta &#x3D; 0.1：趋于保守（更相信参考模型）\nbeta &#x3D; 1.0：更自由（训练模型可偏离参考）\n\n\n\nORPOORPO （Odds Ratio Preference Optimization）是一种新颖的微调技术，它将微调和偏好对齐结合到一个统一的过程中。与 RLHF 或 DPO 等传统方法相比，这种组合方法在效率和性能方面具有优势。\n与 DPO 等方法的对齐通常涉及两个单独的步骤：监督微调以使模型适应领域和格式，然后进行偏好对齐以与人类偏好保持一致。虽然 SFT 有效地使模型适应目标域，但它可能无意中增加产生期望和不期望响应的概率。ORPO 通过将这两个步骤集成到一个流程中来解决这一限制。对比如下：\n\n如何工作训练过程利用了一个类似于在 DPO 中使用的偏好数据集，其中每个训练示例包含一个输入提示以及两个响应：一个是首选的，另一个是拒绝的。与其他需要单独阶段和参考模型的校准方法不同，ORPO 将偏好校准直接集成到监督微调过程中。这种单片方法使其无需参考模型，计算效率更高，并且使用更少的 flop 来提高内存效率。\nORPO 通过结合两个主要组件创建了一个新目标：\n\nSFT 损失：语言建模中使用的标准负对数似然损失，它最大限度地提高了生成参考令牌的概率。这有助于维护模型的通用语言功能。\nodd rate 损失：一个新的组件，惩罚不希望的反应，而奖励首选的。这个损失函数使用比值比在令牌级别上有效地对比受欢迎和不受欢迎的响应。\n\n","categories":["LLM"],"tags":["trl","smol"]},{"title":"【Kaggle Courses】2-python","url":"/blog/Kaggle-course/python-kaggle/","content":"coming soon…\n","tags":["Kaggle","Python"]},{"title":"【Smol Course】4-评估","url":"/blog/LLM/smol4/","content":"Evaluation全面的评估策略检查模型性能的多个方面。我们评估特定于任务的功能，如问题回答和总结，以了解模型如何处理不同类型的问题。我们通过连贯性和事实准确性等因素来衡量输出质量。安全评估有助于识别潜在的有害输出或偏见。最后，领域专业知识测试验证模型在目标领域中的专业知识。\n\nAutomatic Benchmarks：学习使用标准化的基准和指标来评估你的模型。我们将探索常见的基准，如MMLU和TruthfulQA，了解关键的评估指标和设置，并介绍可重复评估的最佳实践。\nCustom Domain Evaluation：了解如何创建适合您特定用例的评估管道。我们将逐步完成设计自定义评估任务，实现专门的度量，并构建符合您需求的评估数据集。\nDomain Evaluation Project：构建特定于领域的评估管道的完整示例。您将学习如何生成评估数据集、使用 Argilla 进行数据注释、创建标准化数据集以及使用 LightEval 评估模型。\n\nAutomatic Benchmarks自动基准测试通常由带有预定义任务和评估指标的精心策划的数据集组成。这些基准旨在评估模型能力的各个方面，从基本的语言理解到复杂的推理。使用自动基准测试的关键优势在于它们的标准化——它们允许跨不同模型进行一致的比较，并提供可重复的结果。\nUsing LightEval for BenchmarkingLightEval 任务用一种特定的格式定义：\n&#123;suite&#125;|&#123;task&#125;|&#123;num_few_shot&#125;|&#123;auto_reduce&#125;\n\nsuite: The benchmark suite (e.g., ‘mmlu’, ‘truthfulqa’)\ntask: Specific task within the suite (e.g., ‘abstract_algebra’)\nnum_few_shot: Number of examples to include in prompt (0 for zero-shot)\nauto_reduce: Whether to automatically reduce few-shot examples if prompt is too long (0 or 1)\n\nExample\n定义评估任务（MMLU 子任务）\n设置 pipeline 参数\n创建评估追踪器\n加载模型 + 构建 pipeline\n\nPipeline 是 LightEval 的核心组件，负责：\n\n将任务、模型、评估记录器统一起来\n自动加载数据集、执行推理、记录结果\n\nfrom lighteval.tasks import Task, Pipelinefrom transformers import AutoModelForCausalLM# Define tasks to evaluatedomain_tasks = [    &quot;mmlu|anatomy|0|0&quot;,    &quot;mmlu|high_school_biology|0|0&quot;,     &quot;mmlu|high_school_chemistry|0|0&quot;,    &quot;mmlu|professional_medicine|0|0&quot;]# Configure pipeline parameterspipeline_params = &#123;    &quot;max_samples&quot;: 40,  # Number of samples to evaluate 每个任务最多评估 40 条样本    &quot;batch_size&quot;: 1,    # Batch size for inference 推理批次大小为 1（节省显存）    &quot;num_workers&quot;: 4    # Number of worker processes 多进程加载数据或处理任务&#125;# Create evaluation tracker# 创建评估追踪器，保存推理过程中的答案（generations）evaluation_tracker = EvaluationTracker(    output_path=&quot;./results&quot;,    save_generations=True)# Load model and create pipelinemodel = AutoModelForCausalLM.from_pretrained(&quot;your-model-name&quot;)pipeline = Pipeline(    tasks=domain_tasks,    pipeline_parameters=pipeline_params,    evaluation_tracker=evaluation_tracker,    model=model)# Run evaluationpipeline.evaluate()# Get and display resultsresults = pipeline.get_results()pipeline.show_results()\n\nCustom Domain Evaluation虽然标准基准提供了有价值的见解，但许多应用程序需要针对特定领域或用例定制的专门评估方法。本指南将帮助您创建自定义评估管道，以准确地评估您的模型在目标领域中的性能。\nImplementation with LightEvalLightEval 为实现自定义评估提供了一个灵活的框架。下面是如何创建自定义任务：\nfrom lighteval.tasks import Task, Docfrom lighteval.metrics import SampleLevelMetric, MetricCategory, MetricUseCaseclass CustomEvalTask(Task):    def __init__(self):        super().__init__(            name=&quot;custom_task&quot;,            version=&quot;0.0.1&quot;,            metrics=[&quot;accuracy&quot;, &quot;f1&quot;],  # Your chosen metrics            description=&quot;Description of your custom evaluation task&quot;        )        def get_prompt(self, sample):        # Format your input into a prompt        return f&quot;Question: &#123;sample[&#x27;question&#x27;]&#125;\\nAnswer:&quot;        def process_response(self, response, ref):        # Process model output and compare to reference        return response.strip() == ref.strip()\n\n\nTask: LightEval 中评估任务的基类。所有评估任务都必须继承自它。\nDoc: （虽然未使用）通常表示评估中的一个样本结构。\nprompt 构造逻辑：方法接收一个样本（字典 sample），从中提取字段（如 “question”）来构建 prompt。\n模型输出的处理和比较方法：\nresponse: 模型生成的回答（字符串）\nref: 标准答案（reference）\n返回 True&#x2F;False 表示该样本是否正确\n\n\n\nCustom Metrics特定于领域的任务通常需要专门的度量标准。LightEval 提供了一个灵活的框架，用于创建捕获领域相关性能方面的自定义指标：\nfrom aenum import extend_enumfrom lighteval.metrics import Metrics, SampleLevelMetric, SampleLevelMetricGroupingimport numpy as np# Define a sample-level metric functiondef custom_metric(predictions: list[str], formatted_doc: Doc, **kwargs) -&gt; dict:    &quot;&quot;&quot;Example metric that returns multiple scores per sample&quot;&quot;&quot;    response = predictions[0]    return &#123;        &quot;accuracy&quot;: response == formatted_doc.choices[formatted_doc.gold_index],        &quot;length_match&quot;: len(response) == len(formatted_doc.reference)    &#125;# Create a metric that returns multiple values per samplecustom_metric_group = SampleLevelMetricGrouping(    metric_name=[&quot;accuracy&quot;, &quot;length_match&quot;],  # Names of sub-metrics    higher_is_better=&#123;  # Whether higher values are better for each metric        &quot;accuracy&quot;: True,        &quot;length_match&quot;: True    &#125;,    category=MetricCategory.CUSTOM,    use_case=MetricUseCase.SCORING,    sample_level_fn=custom_metric,    corpus_level_fn=&#123;  # How to aggregate each metric        &quot;accuracy&quot;: np.mean,        &quot;length_match&quot;: np.mean    &#125;)# Register the metric with LightEvalextend_enum(Metrics, &quot;custom_metric_name&quot;, custom_metric_group)\n\n\n自定义评估函数 custom_metric，这个函数对每一个样本返回多个评价指标\npredictions: 模型的输出列表（通常只有一个预测值）\nformatted_doc: Doc 对象，包含标准参考信息\n返回值是一个字典，包含多个指标（例如 accuracy 和 length_match）\n\n\n将该函数包装为 SampleLevelMetricGrouping\nmetric_name: 包含该分组下的所有子指标名\nhigher_is_better: 定义每个指标的“最优方向”\nsample_level_fn: 样本级评估函数\ncorpus_level_fn: 总体评估如何聚合（这里使用 np.mean）\n\n\n注册自定义指标到 LightEval 内部枚举系统中\n给 Metrics 注册了新的枚举项 “custom_metric_name”，它将与任务绑定。\n\n\n\n只有单个指标的情况：\ndef simple_metric(predictions: list[str], formatted_doc: Doc, **kwargs) -&gt; bool:    &quot;&quot;&quot;Example metric that returns a single score per sample&quot;&quot;&quot;    response = predictions[0]    return response == formatted_doc.choices[formatted_doc.gold_index]simple_metric_obj = SampleLevelMetric(    metric_name=&quot;simple_accuracy&quot;,    higher_is_better=True,    category=MetricCategory.CUSTOM,    use_case=MetricUseCase.SCORING,    sample_level_fn=simple_metric,    corpus_level_fn=np.mean  # How to aggregate across samples)extend_enum(Metrics, &quot;simple_metric&quot;, simple_metric_obj)\n\n然后，可以通过在任务配置中引用自定义指标来在评估任务中使用它们。度量将在所有样本中自动计算，并根据您指定的功能进行汇总。\n","categories":["LLM"],"tags":["trl","smol"]},{"title":"【Smol Course】5-视觉语言模型","url":"/blog/LLM/smol5/","content":"VLM Usage视觉语言模型（vlm）弥合了图像和文本之间的差距，实现了高级任务，如生成图像字幕，基于视觉回答问题，或理解文本和视觉数据之间的关系。它们的架构旨在无缝地处理这两种模式。\nChat Format许多 vlm 的结构以类似聊天机器人的方式进行交互，从而增强了可用性。该格式包括：\n\n为模型设置角色或上下文的系统消息，例如“您是分析可视化数据的助手”。\n结合文本输入和相关图像的用户查询。\n辅助响应提供来自多模态分析的文本输出。\n\n这种会话结构是直观的，符合用户的期望，特别是对于交互式应用程序，如客户服务或教育工具。下面是一个格式化输入的示例\n[    &#123;        &quot;role&quot;: &quot;system&quot;,        &quot;content&quot;: [&#123;&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: &quot;You are a Vision Language Model specialized in interpreting visual data from chart images...&quot;&#125;]    &#125;,    &#123;        &quot;role&quot;: &quot;user&quot;,        &quot;content&quot;: [            &#123;&quot;type&quot;: &quot;image&quot;, &quot;image&quot;: &quot;&lt;image_data&gt;&quot;&#125;,            &#123;&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: &quot;What is the highest value in the bar chart?&quot;&#125;        ]    &#125;,    &#123;        &quot;role&quot;: &quot;assistant&quot;,        &quot;content&quot;: [&#123;&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: &quot;42&quot;&#125;]    &#125;]\n\nvlm 还可以通过调整输入结构来适应顺序或并行视觉输入，从而处理多个图像甚至视频。对于视频，帧可以作为单独的图像进行提取和处理，同时保持时间顺序。\nPractice加载模型\nimport torch, PILfrom transformers import AutoProcessor, AutoModelForVision2Seq, BitsAndBytesConfigfrom transformers.image_utils import load_imagedevice = (    &quot;cuda&quot;    if torch.cuda.is_available()    else &quot;mps&quot; if torch.backends.mps.is_available() else &quot;cpu&quot;)model_name = &quot;HuggingFaceTB/SmolVLM-Instruct&quot;model = AutoModelForVision2Seq.from_pretrained(    model_name,    cache_dir=&quot;D:\\study\\smol-course\\data\\SmolVLM-Instruct&quot;).to(device)processor = AutoProcessor.from_pretrained(&quot;HuggingFaceTB/SmolVLM-Instruct&quot;, cache_dir=&quot;D:\\study\\smol-course\\data\\SmolVLM-Instruct&quot;)print(processor.image_processor.size)\n\nAutoProcessor.from_pretrained 自动加载该模型所需的图像预处理器和文本分词器，封装为一个 processor 对象，后续可直接用它将输入图像 + 问题处理成模型所需的格式。\n处理单张图像# Load  one imageimage1 = load_image(image_url1)# Create input messagesmessages = [    &#123;        &quot;role&quot;: &quot;user&quot;,        &quot;content&quot;: [            &#123;&quot;type&quot;: &quot;image&quot;&#125;,            &#123;&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: &quot;Can you describe the image?&quot;&#125;        ]    &#125;,]# Prepare inputsprompt = processor.apply_chat_template(messages, add_generation_prompt=True)inputs = processor(text=prompt, images=[image1], return_tensors=&quot;pt&quot;)inputs = inputs.to(device)# Generate outputsgenerated_ids = model.generate(**inputs, max_new_tokens=500)generated_texts = processor.batch_decode(    generated_ids,    skip_special_tokens=True,)print(generated_texts)\n\n注意：\n\n图像数据 并不是放在 messages 里，而是通过 processor(…, images&#x3D;[image1]) 传进去的，messages 只是 告诉模型“这里应该有一张图”，实际的图像张量（token）由 processor 自动插入并对齐。\nprocessor.apply_chat_template 本质上是将 messages 转换为：&lt;|user|&gt; \\&lt;image&gt; Can you describe the image? &lt;|assistant|&gt;\n&lt;image&gt; 是一个 特殊 token 占位符，不是图像数据，而是告诉模型“这里会插入图像的视觉 token”\n接下来在 processor(text&#x3D;prompt, images&#x3D;[image1], return_tensors&#x3D;”pt”) 中：\nimages&#x3D;[image1]：真正传入图像数据的位置\nprocessor 会自动将 image1：\nresize、normalize\n转为 tensor\n并对齐到 prompt 中的 &lt;image&gt; token 位置\n\n\n\n\n\n\n\n处理多张图像将 message 更改为：\nmessages = [    &#123;        &quot;role&quot;: &quot;user&quot;,        &quot;content&quot;: [            &#123;&quot;type&quot;: &quot;image&quot;&#125;,            &#123;&quot;type&quot;: &quot;image&quot;&#125;,            &#123;&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: &quot;What event do they both represent?&quot;&#125;        ]    &#125;,]\n添加了一个 iamge 占位符，相应的，在调用 processor 时，也要传入两个 image 对象：\nprompt = processor.apply_chat_template(messages, add_generation_prompt=True)inputs = processor(text=prompt, images=[image1, image2], return_tensors=&quot;pt&quot;)inputs = inputs.to(device)\n\n处理视频抽取视频关键帧，将其作为多张图像来传递给模型。首先定义抽帧和缩放函数：\nfrom IPython.display import Videoimport cv2import numpy as npdef extract_frames(video_path, max_frames=50, target_size=None):    cap = cv2.VideoCapture(video_path)    if not cap.isOpened():        raise ValueError(f&quot;Could not open video: &#123;video_path&#125;&quot;)        total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))    frame_indices = np.linspace(0, total_frames - 1, max_frames, dtype=int)    frames = []    for idx in frame_indices:        cap.set(cv2.CAP_PROP_POS_FRAMES, idx)        ret, frame = cap.read()        if ret:            frame = PIL.Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))            if target_size:                frames.append(resize_and_crop(frame, target_size))            else:                frames.append(frame)    cap.release()    return framesdef resize_and_crop(image, target_size):    width, height = image.size    scale = target_size / min(width, height)    image = image.resize((int(width * scale), int(height * scale)), PIL.Image.Resampling.LANCZOS)    left = (image.width - target_size) // 2    top = (image.height - target_size) // 2    return image.crop((left, top, left + target_size, top + target_size))\n\nextract_frames 将视频抽帧后，使用 opencv 来进行读取，并且转换为 numpy 数组。 \nresize_and_crop 根据需要将视频帧进行裁剪\n\n接下来定义了一个 generate_response 函数，用于生成回答。\ndef generate_response(model, processor, frames, question):    image_tokens = [&#123;&quot;type&quot;: &quot;image&quot;&#125; for _ in frames]    messages = [        &#123;            &quot;role&quot;: &quot;user&quot;,            &quot;content&quot;: [                &#123;                    &quot;type&quot;: &quot;text&quot;,                     &quot;text&quot;: &quot;Following are the frames of a video in temporal order.&quot;                &#125;,                     *image_tokens,                 &#123;                    &quot;type&quot;: &quot;text&quot;,                    &quot;text&quot;: question                &#125;            ]        &#125;    ]    inputs = processor(        text=processor.apply_chat_template(messages, add_generation_prompt=True),        images=frames,        return_tensors=&quot;pt&quot;    ).to(model.device)    outputs = model.generate(        **inputs, max_new_tokens=100, num_beams=5, temperature=0.7, do_sample=True, use_cache=True    )    return processor.decode(outputs[0], skip_special_tokens=True)\n\n注意： \n\nmessage 里面的 image_tokens，重复了 len(frames) 次，即将视频帧作为多张图像传入。\ngenerate 的参数：\n\nQwenVL 处理视频Qwen 支持多种方法传入视频：\n# Messages containing a images list as a video and a text querymessages = [    &#123;        &quot;role&quot;: &quot;user&quot;,        &quot;content&quot;: [            &#123;                &quot;type&quot;: &quot;video&quot;,                &quot;video&quot;: [                    &quot;file:///path/to/frame1.jpg&quot;,                    &quot;file:///path/to/frame2.jpg&quot;,                    &quot;file:///path/to/frame3.jpg&quot;,                    &quot;file:///path/to/frame4.jpg&quot;,                ],            &#125;,            &#123;&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: &quot;Describe this video.&quot;&#125;,        ],    &#125;]# Messages containing a local video path and a text querymessages = [    &#123;        &quot;role&quot;: &quot;user&quot;,        &quot;content&quot;: [            &#123;                &quot;type&quot;: &quot;video&quot;,                &quot;video&quot;: &quot;file:///path/to/video1.mp4&quot;,                &quot;max_pixels&quot;: 360 * 420,                &quot;fps&quot;: 1.0,            &#125;,            &#123;&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: &quot;Describe this video.&quot;&#125;,        ],    &#125;]# Messages containing a video url and a text querymessages = [    &#123;        &quot;role&quot;: &quot;user&quot;,        &quot;content&quot;: [            &#123;                &quot;type&quot;: &quot;video&quot;,                &quot;video&quot;: &quot;https://qianwen-res.oss-cn-beijing.aliyuncs.com/Qwen2-VL/space_woaudio.mp4&quot;,            &#125;,            &#123;&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: &quot;Describe this video.&quot;&#125;,        ],    &#125;]\n\n核心处理方法为 process_vision_info：\n\n下载&#x2F;读取本地视频或图片帧\n自动抽帧（基于 message 中给的信息（如果有，例如上述的第二种情况））\n标准化图片尺寸（基于 message 中给的信息（如果有，例如上述的第二种情况））\n返回三类信息：\nimage_inputs: 图像列表（如果有）\nvideo_inputs: 视频帧图像列表（tensor 格式）\nvideo_kwargs: 与视频处理相关的参数（如帧时间戳、维度等）\n\n\n\nimage_inputs, video_inputs, video_kwargs = process_vision_info(messages, return_video_kwargs=True)\n\nVLM Fine-TuningEfficient Fine-TuningQuantization量化降低了模型权重和激活的精度，显著降低了内存使用并加快了计算速度。例如，从 float32 切换到 bfloat16 可以在保持性能的同时减少每个参数的内存需求。对于更激进的压缩，可以使用 8 位和 4 位量化，进一步减少内存使用，但代价是一定的准确性。这些技术可以应用于模型和优化器设置，从而在有限的资源下对硬件进行有效的训练。\nPEFT &amp; LoRALoRA （Low-Rank Adaptation）专注于学习紧凑的秩分解矩阵，同时保持原始模型权值不变。这大大减少了可训练参数的数量，显著减少了资源需求。当LoRA与PEFT集成时，只需调整一小部分可训练的参数子集，就可以对大型模型进行微调。这种方法对于特定于任务的调整特别有效，在保持性能的同时将数十亿个可训练参数减少到数百万个。\nBatch Size Optimization为了优化批大小以进行微调，可以从一个较大的值开始，并在发生内存不足（OOM）错误时减小它。通过增加 gradient_accumulation_steps 进行补偿，有效地维护多个更新的总批大小。此外，启用 gradient_checkpointing，通过在反向传递期间重新计算中间状态来降低内存使用，以减少计算时间来减少激活内存需求。这些策略最大限度地提高了硬件利用率，并有助于克服内存限制。\n简单来说，batch size 过大会导致 OOM（Out-Of-Memory），可以使用以下策略：\n\n设置如下：\nfrom transformers import TrainingArgumentstraining_args = TrainingArguments(    output_dir=&quot;./fine_tuned_model&quot;,  # Directory for model checkpoints    per_device_train_batch_size=4,   # Batch size per device (GPU/TPU)    num_train_epochs=3,              # Total training epochs    learning_rate=5e-5,              # Learning rate    save_steps=1000,                 # Save checkpoint every 1000 steps    bf16=True,                       # Use mixed precision for training    gradient_checkpointing=True,     # Enable to reduce activation memory usage    gradient_accumulation_steps=16,  # Accumulate gradients over 16 steps    logging_steps=50                 # Log metrics every 50 steps)\n\nSupervised Fine-Tuning监督微调（SFT）通过利用包含成对输入（如图像和相应文本）的标记数据集，使预训练的视觉语言模型（VLM）适应特定任务。该方法增强了模型执行特定领域或特定任务功能的能力，例如可视化问题回答、图像字幕或图表解释。\nPreference Optimization偏好优化，特别是直接偏好优化（DPO），训练视觉语言模型（VLM）与人类偏好保持一致。该模型不是严格遵循预定义的指令，而是学会优先考虑人类主观上喜欢的输出。这种方法对于涉及创造性判断、细致推理或不同可接受答案的任务特别有用。\nPractice with SFT加载模型\nmodel_name = &quot;HuggingFaceTB/SmolVLM-Instruct&quot;model = AutoModelForVision2Seq.from_pretrained(    model_name,    quantization_config=quantization_config,    torch_dtype=torch.bfloat16,).to(device)processor = AutoProcessor.from_pretrained(&quot;HuggingFaceTB/SmolVLM-Instruct&quot;)\n\n设置 LoRA。注意这里使用的是 get_peft_model 方法。前面的代码在加载模型时就添加了 peft 参数，但是更推荐下面这种方法，即先加载模型，然后再将可训练的参数结合到模型中。\nfrom peft import LoraConfig, get_peft_model# Configure LoRApeft_config = LoraConfig(    lora_alpha=16,    lora_dropout=0.05,    r=8,    bias=&quot;none&quot;,    target_modules=[&quot;q_proj&quot;, &quot;v_proj&quot;],    task_type=&quot;CAUSAL_LM&quot;,)# Apply PEFT model adaptationpeft_model = get_peft_model(model, peft_config)# Print trainable parameterspeft_model.print_trainable_parameters()\n\n定义 collate_fn 函数用于预处理数据，目的是将一个批次（batch）的图文对话样本，整理为模型可以直接使用的张量输入格式。\n\nexamples 是一个 batch 的原始样本列表。\n对于 batch 中的每个样本，都构建一个 message 字典。\n对构造好的 message 添加聊天模板，然后存放在 text_inputs 中\n对当前图像进行预处理，在这个例子中，加载的数据集结构如下，image 字段已经是一个 PIL 对象。将处理好的 image 保存到 image_inputs 中。print(ds)DatasetDict(&#123;    train: Dataset(&#123;        features: [&#x27;image&#x27;, &#x27;query&#x27;, &#x27;label&#x27;, &#x27;human_or_machine&#x27;],        num_rows: 28299    &#125;)    val: Dataset(&#123;        features: [&#x27;image&#x27;, &#x27;query&#x27;, &#x27;label&#x27;, &#x27;human_or_machine&#x27;],        num_rows: 1920    &#125;)    test: Dataset(&#123;        features: [&#x27;image&#x27;, &#x27;query&#x27;, &#x27;label&#x27;, &#x27;human_or_machine&#x27;],        num_rows: 2500    &#125;)&#125;)print(type(ds[&#x27;train&#x27;][0][&#x27;image&#x27;]))&lt;class &#x27;PIL.PngImagePlugin.PngImageFile&#x27;&gt;\n将文本 prompt + 图像输入送入 processor，返回的 batch 为一个 list，其中的一个元素包含：\ninput_ids（文本 token ids）\npixel_values（图像 tensor）\nattention_mask （mask）\n\n\n构造 labels 字段,把 padding token 的位置置为 -100，告诉 loss 不计算这些位置\n将 image token 位置同样也设置为 -100，图像在文本中是通过一个特殊 token（如 &lt;image&gt;）占位的，但这个 token 不是模型要预测的目标，所以也将其设为 -100 以屏蔽 loss\n最终返回构造好的样本:\ninput_ids\nattention_mask\npixel_values\nlabels\n\n\n\ndef collate_fn(examples):    # System message template for the VLM    system_message = &quot;&quot;&quot;You are a Vision Language Model specialized in interpreting visual data from chart images.    Your task is to analyze the provided chart image and respond to queries with concise answers, usually a single word, number, or short phrase.    The charts include a variety of types (e.g., line charts, bar charts) and contain colors, labels, and text.    Focus on delivering accurate, succinct answers based on the visual information. Avoid additional explanation unless absolutely necessary.&quot;&quot;&quot;    # Initialize lists for text and image inputs    text_inputs = []    image_inputs = []    # Process all examples in one loop    for example in examples:        # Format the chat structure for the processor        formatted_example = &#123;            &quot;messages&quot;: [                &#123;                    &quot;role&quot;: &quot;system&quot;,                    &quot;content&quot;: [&#123;&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: system_message&#125;],                &#125;,                &#123;                    &quot;role&quot;: &quot;user&quot;,                    &quot;content&quot;: [                        &#123;                            &quot;type&quot;: &quot;image&quot;,                        &#125;,                        &#123;                            &quot;type&quot;: &quot;text&quot;,                            &quot;text&quot;: example[&quot;query&quot;],                        &#125;,                    ],                &#125;,            ]        &#125;        # Apply chat template and strip extra spaces        text_inputs.append(processor.apply_chat_template(formatted_example[&quot;messages&quot;], tokenize=False).strip())                # Ensure images are in RGB mode        image = example[&quot;image&quot;]        if image.mode != &#x27;RGB&#x27;:            image = image.convert(&#x27;RGB&#x27;)        image_inputs.append( [image] )    # Tokenize the texts and process the images    batch = processor(        text=text_inputs,        images=image_inputs,        return_tensors=&quot;pt&quot;,        padding=True    )    # Clone input IDs for labels    labels = batch[&quot;input_ids&quot;].clone()    labels[labels == processor.tokenizer.pad_token_id] = -100  # Mask padding tokens in labels    # Ensure image_token is converted to string if it is an AddedToken    # In some processor, processor.image_token return a list for each image.    # TODO: AutoProcessor.from_pretrained(&quot;HuggingFaceTB/SmolVLM-Instruct&quot;) only have one ?    image_token_id = processor.tokenizer.convert_tokens_to_ids(str(processor.image_token))    # Mask image token IDs in the labels    labels[labels == image_token_id] = -100    # Add labels back to the batch    batch[&quot;labels&quot;] = labels    return batch\n\n最后配置参数。注意在 SFTConfig 中：\n\ndataset_text_field&#x3D;””：指定数据集中用作文本输入的字段，这里留空（因使用自定义 collate_fn）\nskip_prepare_dataset&#x3D;True：告诉 trl 不需要自动预处理数据集，我们手动处理\nremove_unused_columns&#x3D;False：保留所有字段，否则只会保留 tokenizer 用到的字段，会丢图像等信息\n\nSFTTrainer 中，设置 data_collator&#x3D;collate_fn，表示自定义的批处理函数，用于图文混合数据\nfrom trl import SFTConfig, SFTTrainer# Configure the Trainertraining_args = SFTConfig(    output_dir=&quot;sft_output&quot;,  # Directory to save the model    num_train_epochs=3,                     # number of training epochs    per_device_train_batch_size=1,          # batch size per device during training    gradient_accumulation_steps=16,         # number of steps before performing a backward/update pass    gradient_checkpointing=True,            # use gradient checkpointing to save memory    optim=&quot;adamw_torch_fused&quot;,              # use fused adamw optimizer    logging_steps=5,                        # log every 10 steps    save_strategy=&quot;epoch&quot;,                  # save checkpoint every epoch    learning_rate=2e-4,                     # learning rate, based on QLoRA paper    bf16=True,                              # use bfloat16 precision    tf32=True,                              # use tf32 precision    max_grad_norm=0.3,                      # max gradient norm based on QLoRA paper    warmup_ratio=0.03,                      # warmup ratio based on QLoRA paper    lr_scheduler_type=&quot;constant&quot;,           # use constant learning rate scheduler    push_to_hub=True,                       # push model to hub    gradient_checkpointing_kwargs = &#123;&quot;use_reentrant&quot;: False&#125;, # use reentrant checkpointing    # dataloader_num_workers=16,     dataset_text_field=&quot;&quot;, # need a dummy field for collator    dataset_kwargs = &#123;&quot;skip_prepare_dataset&quot;: True&#125;, # important for collator    remove_unused_columns = False                    # necessary else features except label will be removed)# Initialize the Trainertrainer = SFTTrainer(    model=model,    args=training_args,    train_dataset=ds[&quot;train&quot;],    eval_dataset=ds[&quot;test&quot;],    data_collator=collate_fn,    peft_config=peft_config,    tokenizer=processor.tokenizer,)\n","categories":["LLM"],"tags":["trl","smol"]},{"title":"【Smol Course】3-参数高效微调","url":"/blog/LLM/smol3/","content":"Parameter-Efficient Fine-Tuning (PEFT)随着语言模型变得越来越大，传统的微调变得越来越具有挑战性。即使是 1.7B 参数模型的全面微调也需要大量的 GPU 内存，使存储单独的模型副本变得昂贵，并且有可能灾难性地忘记模型的原始功能。参数有效微调（PEFT）方法通过仅修改模型参数的一小部分而保持大部分模型不变来解决这些挑战。\n传统的微调在训练过程中更新所有的模型参数，这对于大型模型来说是不切实际的。PEFT 方法引入了使用较少可训练参数（通常小于原始模型大小的 1%）来调整模型的方法。可训练参数的大幅减少使：\n\n在 GPU 内存有限的消费者硬件上进行微调\n有效地存储多个特定于任务的适应性\n在低数据场景下更好的泛化\n更快的训练和迭代周期\n\nLoRA (Low-Rank Adaptation)LoRA 已成为最广泛采用的 PEFT 方法。它的工作原理是将小秩分解矩阵添加到注意力权重中，通常会将可训练参数减少约 90%。在推理期间，这些适配器权重可以与基本模型合并，从而不会产生额外的延迟开销。LoRA 对于使大型语言模型适应特定的任务或领域，同时保持资源需求可管理特别有用。\nLoading LoRA Adapters可以使用 load_adapter() 将适配器加载到预训练的模型中，这对于尝试未合并权重的不同适配器非常有用。使用 set_adapter() 函数设置活动适配器权重。要返回基本模型，可以使用 unload() 卸载所有的 LoRA 模块。这使得在不同的任务特定权重之间切换变得很容易。\nfrom transformers import AutoModelForCausalLMfrom peft import PeftModelbase_model = AutoModelForCausalLM.from_pretrained(&quot;&lt;base_model_name&gt;&quot;)peft_model_id = &quot;&lt;peft_adapter_id&gt;&quot;model = PeftModel.from_pretrained(base_model, peft_model_id)\n\nMerging LoRA Adapters在使用 LoRA 进行训练之后，您可能希望将适配器权重合并回基本模型中，以便于部署。这将创建具有组合权重的单个模型，从而消除了在推理期间单独加载适配器的需要。\n合并过程需要注意内存管理和精度。由于您需要同时加载基本模型和适配器权重，因此请确保有足够的 GPU&#x2F;CPU 内存可用。在 transformer 中使用 device_map&#x3D;”auto” 将有助于自动内存管理。在整个过程中保持一致的精度（例如，float16），匹配训练期间使用的精度，并以相同的格式保存合并模型以供部署。在部署之前，始终通过将其输出和性能指标与基于适配器的版本进行比较来验证合并模型。\nimport torchfrom transformers import AutoModelForCausalLMfrom peft import PeftModel# 1. Load the base modelbase_model = AutoModelForCausalLM.from_pretrained(    &quot;base_model_name&quot;,    torch_dtype=torch.float16,    device_map=&quot;auto&quot;)# 2. Load the PEFT model with adapterpeft_model = PeftModel.from_pretrained(    base_model,    &quot;path/to/adapter&quot;,    torch_dtype=torch.float16)# 3. Merge adapter weights with base modeltry:    merged_model = peft_model.merge_and_unload()except RuntimeError as e:    print(f&quot;Merging failed: &#123;e&#125;&quot;)    # Implement fallback strategy or memory optimization# 4. Save the merged modelmerged_model.save_pretrained(&quot;path/to/save/merged_model&quot;)\n\n注意，PEFT 保存的模型只保存 adapter（如 LoRA 权重）部分，但是，AutoPeftModelForCausalLM 会：\n\n自动加载 base model（如 LLaMA、Qwen、GPT-NeoX）：通过在 adapter config 中保存的 base model 路径（或你传的路径）；\n然后在此基础上加载 adapter 权重；\n得到一个完整的、可运行的 PEFT 模型。\n换句话说，传入的 args.output_dir 实际上是包含：\nadapter 权重\nadapter 配置\n一个可解析的 base_model_name_or_path 字段（指向原始模型）\n\n\n\nUsing TRL with PEFTfrom peft import LoraConfigfrom transformers import AutoModelForCausalLM# Load model with PEFT configlora_config = LoraConfig(    r=16,    lora_alpha=32,    lora_dropout=0.05,    bias=&quot;none&quot;,    task_type=&quot;CAUSAL_LM&quot;)# Load model on specific devicemodel = AutoModelForCausalLM.from_pretrained(    &quot;your-model-name&quot;,    load_in_8bit=True,  # Optional: use 8-bit precision    device_map=&quot;auto&quot;,    peft_config=lora_config)\n\nPracticeParameters定义 PEFT 参数\nfrom peft import LoraConfig# TODO: Configure LoRA parameters# r: rank dimension for LoRA update matrices (smaller = more compression)rank_dimension = 6# lora_alpha: scaling factor for LoRA layers (higher = stronger adaptation)lora_alpha = 8# lora_dropout: dropout probability for LoRA layers (helps prevent overfitting)lora_dropout = 0.05peft_config = LoraConfig(    r=rank_dimension,  # Rank dimension - typically between 4-32    lora_alpha=lora_alpha,  # LoRA scaling factor - typically 2x rank    lora_dropout=lora_dropout,  # Dropout probability for LoRA layers    bias=&quot;none&quot;,  # Bias type for LoRA. the corresponding biases will be updated during training.    target_modules=&quot;all-linear&quot;,  # Which modules to apply LoRA to    task_type=&quot;CAUSAL_LM&quot;,  # Task type for model architecture)\n\n将 PEFT 参数添加到 SFTTrainer 中。\nmax_seq_length = 1512  # max sequence length for model and packing of the dataset# Create SFTTrainer with LoRA configurationtrainer = SFTTrainer(    model=model,    args=args,    train_dataset=dataset[&quot;train&quot;],    peft_config=peft_config,  # LoRA configuration    max_seq_length=max_seq_length,  # Maximum sequence length    tokenizer=tokenizer,    packing=True,  # Enable input packing for efficiency    dataset_kwargs=&#123;        &quot;add_special_tokens&quot;: False,  # Special tokens handled by template        &quot;append_concat_token&quot;: False,  # No additional separator needed    &#125;,)\n\nLoad adapters from the Hub\n首先加载的是 PeftConfig\n然后基于 PeftConfig 加载 base model\n最后加载带 LoRA 的模型\n\nimport torchimport transformersfrom datasets import load_datasetfrom peft import LoraConfig, get_peft_modelfrom peft import PeftModel, PeftConfigfrom transformers import AutoModelForCausalLM, AutoTokenizerpeft_model_id = &quot;ybelkada/opt-6.7b-lora&quot;config = PeftConfig.from_pretrained(peft_model_id)model = AutoModelForCausalLM.from_pretrained(    config.base_model_name_or_path,    return_dict=True,    load_in_8bit=True,    device_map=&quot;auto&quot;,)tokenizer = AutoTokenizer.from_pretrained(config.base_model_name_or_path)# Load the Lora modelmodel = PeftModel.from_pretrained(model, peft_model_id)\n\nPrompt Tuning提示调优是一种参数高效的方法，它修改输入表示，而不是模型权重。与更新所有模型参数的传统微调不同，提示调优在保持基本模型不变的同时添加并优化了一小组可训练的令牌。提示调优将可训练的连续向量（软提示）添加到输入文本中。\n这些软提示是模型嵌入空间中的连续向量，在训练过程中得到优化。与使用自然语言标记的传统离散提示不同，软提示没有固有的含义，而是通过梯度下降学习从冻结模型中引出所需的行为。该技术对于多任务场景特别有效，因为每个任务只需要存储一个小的提示向量（通常是几百个参数），而不是一个完整的模型副本。这种方法不仅保持了最小的内存占用，而且还支持快速的任务切换。\n在训练过程中，只更新提示参数，而基本模型保持冻结。这种集中的方法使用标准的训练目标，但需要仔细注意提示符号的学习率和梯度行为。\nImplementation with PEFTfrom peft import PromptTuningConfig, TaskType, get_peft_modelfrom transformers import AutoModelForCausalLM, AutoTokenizer# Load base modelmodel = AutoModelForCausalLM.from_pretrained(&quot;your-base-model&quot;)tokenizer = AutoTokenizer.from_pretrained(&quot;your-base-model&quot;)# Configure prompt tuningpeft_config = PromptTuningConfig(    task_type=TaskType.CAUSAL_LM,    num_virtual_tokens=8,  # Number of trainable tokens    prompt_tuning_init=&quot;TEXT&quot;,  # Initialize from text    prompt_tuning_init_text=&quot;Classify if this text is positive or negative:&quot;,    tokenizer_name_or_path=&quot;your-base-model&quot;,)# Create prompt-tunable modelmodel = get_peft_model(model, peft_config)\n\nComparison\n\n\nMethod\nParameters\nMemory\nTask Switching\n\n\n\nPrompt Tuning\nVery Low\nMinimal\nEasy\n\n\nLoRA\nLow\nLow\nRequires Loading\n\n\nFull Fine-tuning\nHigh\nHigh\nNew Model Copy\n\n\n提示调优在以下几个场景中表现出色：\n\n多任务部署\n资源受限的环境\n快速任务适应\n隐私的应用程序\n\n","categories":["LLM"],"tags":["trl","smol"]},{"title":"【Smol Course】7-推理","url":"/blog/LLM/smol7/","content":"Inference推理是使用经过训练的语言模型来生成预测或响应的过程。虽然推理可能看起来很简单，但大规模有效地部署模型需要仔细考虑各种因素，如性能、成本和可靠性。大型语言模型（llm）由于其大小和计算需求而提出了独特的挑战。\nLLM 推理可以分为两种主要方法：\n\n用于开发和测试的基于管道的简单推理，\n用于生产部署的优化服务解决方案。\n\n我们将介绍这两种方法，从简单的管道方法开始，然后转向生产就绪的解决方案。\nBasic Inference with Transformers Pipeline🤗 transformer 中的 pipeline 抽象提供了一种简单的方法，可以对来自 huggingface 的任何模型运行推理。它处理所有的预处理和后处理步骤，使得无需深入了解其体系结构或需求就可以轻松使用模型。\n三个关键阶段：\n\nPreprocessing\nModel Inference\nPostprocessing\n\n基础用法from transformers import pipeline# Create a pipeline with a specific modelgenerator = pipeline(    &quot;text-generation&quot;,    model=&quot;HuggingFaceTB/SmolLM2-1.7B-Instruct&quot;,    torch_dtype=&quot;auto&quot;,    device_map=&quot;auto&quot;)# Generate textresponse = generator(    &quot;Write a short poem about coding:&quot;,    max_new_tokens=100,    do_sample=True,    temperature=0.7)print(response[0][&#x27;generated_text&#x27;])\n\n详细的参数说明\nresponse = generator(    &quot;Translate this to French:&quot;,    max_new_tokens=100,     # 生成文本的最大长度    do_sample=True,         # 解码时用采样的策略，而不是贪心策略    temperature=0.7,        # 这个参数可以控制随机性，值越大越随机    top_k=50,               # 采样时，只考虑最靠前的前 k 个 token    top_p=0.95,             # 采样时，概率值的阈值    num_return_sequences=1  # 针对一个输入输出几个输出)\n\nText Generation Inference (TGI)Text Generation Inference（简称 TGI）是一个由 Hugging Face 开发的工具包，主要用于对大语言模型进行部署和服务搭建。它旨在为常用的开源大语言模型（LLMs）实现高性能文本生成。TGI 被 Hugging Chat 用于实际生产，Hugging Chat 是一个面向开源模型的开源交互界面。\n即调用 API 的过程\nfrom openai import OpenAI# init the client but point it to TGIclient = OpenAI(    base_url=&quot;http://localhost:8080/v1/&quot;,    api_key=&quot;-&quot;)chat_completion = client.chat.completions.create(    model=&quot;tgi&quot;,    messages=[        &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a helpful assistant.&quot; &#125;,        &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;What is deep learning?&quot;&#125;    ],    stream=True)# iterate and print streamfor message in chat_completion:    print(message)","categories":["LLM"],"tags":["trl","smol"]},{"title":"【Smol Course】6-合成数据","url":"/blog/LLM/smol6/","content":"合成数据是模拟真实世界使用情况的人工生成的数据。它允许通过扩展或增强数据集来克服数据限制。尽管合成数据已经用于一些用例，但大型语言模型使得合成数据集在训练前和训练后以及语言模型的评估中更受欢迎。\n","categories":["LLM"],"tags":["trl","smol"]},{"title":"【Smol Course】8-智能体","url":"/blog/LLM/smol8/","content":"AgentAI 智能体（AI Agents）是一种自主系统，能够理解用户请求、将请求拆解为多个步骤，然后执行相应行动以完成任务。它们将语言模型与工具及外部功能相结合，从而与所处环境进行交互。本模章将讲解如何使用 smolagents 库构建高效的智能体，该库为创建强大的 AI 智能体提供了一个轻量级框架。\n高效的智能体通常具备三种关键能力：\n\n检索能力：智能体需要能够从各种信息来源获取和使用相关信息。\n函数调用：这使得智能体能够在所处环境中采取具体行动。\n特定领域的知识和工具：这能让智能体可以执行诸如代码操作这类专业任务。\n\nBuilding Agentic RAG Systems自主性检索增强生成（RAG 或 Retrieval Augmented Generation）将有自主性的智能体的能力与知识检索能力相结合。传统的 RAG 系统只是利用大语言模型（LLM），基于检索到的信息来回答询问。而自主性 RAG 更进一步，允许系统智能地控制自身的检索和回答过程。传统 RAG 存在关键局限 —— 它仅执行单一的检索步骤，且依赖与用户询问的直接语义相似性，这可能会遗漏相关信息。自主性 RAG 通过让智能体能够自行制定搜索查询、评估结果，并根据需要执行多个检索步骤，来应对这些挑战。\nBasic Retrieval with DuckDuckGo从构建一个简单的代理开始，它可以使用 DuckDuckGo 搜索 web。该代理将能够通过检索相关信息和综合响应来回答问题。\nfrom smolagents import CodeAgent, DuckDuckGoSearchTool, HfApiModel# Initialize the search toolsearch_tool = DuckDuckGoSearchTool()# Initialize the modelmodel = HfApiModel()agent = CodeAgent(    model = model,    tools=[search_tool])# Example usageresponse = agent.run(    &quot;What are the latest developments in fusion energy?&quot;)print(response)\n\n上述代码将：\n\n分析查询以确定需要哪些信息\n使用 DuckDuckGo 搜索相关内容\n将检索到的信息合成为连贯的响应\n将交互存储在内存中以供将来参考\n\n注意：\n\nHfApiModel()：创建一个基于 HuggingFace 模型 API 的语言模型实例。HfApiModel() 可能默认使用一个开源模型，实际部署时可配置模型名、token 等。\nCodeAgent()：构造一个 CodeAgent 实例，它拥有：\n一个语言模型（model），用于理解指令、生成文本；\n一个工具列表（tools），其中包括网络搜索功能。\n\n\n\nCustom Knowledge Base Tool对于特定领域的应用程序，我们通常希望将 web 搜索与我们自己的知识库结合起来。让我们创建一个可以查询技术文档矢量数据库的自定义工具。\nfrom smolagents import Toolclass RetrieverTool(Tool):    name = &quot;retriever&quot;    description = &quot;Uses semantic search to retrieve the parts of transformers documentation that could be most relevant to answer your query.&quot;    inputs = &#123;        &quot;query&quot;: &#123;            &quot;type&quot;: &quot;string&quot;,            &quot;description&quot;: &quot;The query to perform. This should be semantically close to your target documents. Use the affirmative form rather than a question.&quot;,        &#125;    &#125;    output_type = &quot;string&quot;    def __init__(self, docs, **kwargs):        super().__init__(**kwargs)        self.retriever = BM25Retriever.from_documents(            docs, k=10        )    def forward(self, query: str) -&gt; str:        assert isinstance(query, str), &quot;Your search query must be a string&quot;        docs = self.retriever.invoke(            query,        )        return &quot;\\nRetrieved documents:\\n&quot; + &quot;&quot;.join(            [                f&quot;\\n\\n===== Document &#123;str(i)&#125; =====\\n&quot; + doc.page_content                for i, doc in enumerate(docs)            ]        )retriever_tool = RetrieverTool(docs_processed)\n\n\n上述代码继承自 smolagents.Tool，代表这是一个可供智能体 (Agent) 调用的工具。\n初始化方法中\n接收一个预处理好的文档列表 docs\nBM25Retriever.from_documents(…)：构建一个 BM25 检索器，从 docs 中构造倒排索引（用于基于关键词的相关性检索）。\n\n\nforward() 方法：\n是工具的主入口，用于接收 query、执行检索并返回字符串格式的结果。\n调用 self.retriever.invoke(query) 返回 top-k 个文档。\n最后将每个文档内容拼接成字符串输出\n\n\n\nEnhanced Retrieval Capabilities当构建自主性检索增强生成（RAG）系统时，智能体还可以借鉴以下复杂策略：\n\n查询重构：智能体并非直接使用用户的原始查询，而是精心设计优化后的搜索词，使其与目标文档更匹配。\n多步检索：智能体可以执行多次搜索，依据初始检索结果来调整后续的查询。\n来源整合：整合来自多个渠道的信息，如网页搜索和本地文档。\n结果验证：在将检索到的内容纳入回复之前，会对其相关性和准确性进行分析。\n\nCode Agents代码代理通过自动化重复任务来加速开发，同时保持代码质量。他们擅长生成样板代码、执行系统重构以及通过静态分析识别潜在问题。代理将访问外部文档和存储库的检索功能与函数调用相结合，以执行创建文件或运行测试等具体操作。\n在以下示例中，我们创建了一个代码智能体，它能够获取两个位置之间的运动时间。这里，我们使用 @tool 装饰器来定义一个可用作工具的自定义函数。\nfrom smolagents import CodeAgent, HfApiModel, tool@tooldef get_travel_duration(start_location: str, destination_location: str, departure_time: Optional[int] = None) -&gt; str:    &quot;&quot;&quot;Gets the travel time in car between two places.        Args:        start_location: the place from which you start your ride        destination_location: the place of arrival        departure_time: the departure time, provide only a `datetime.datetime` if you want to specify this    &quot;&quot;&quot;    import googlemaps # All imports are placed within the function, to allow for sharing to Hub.    import os    gmaps = googlemaps.Client(os.getenv(&quot;GMAPS_API_KEY&quot;))    if departure_time is None:        from datetime import datetime        departure_time = datetime(2025, 1, 6, 11, 0)    directions_result = gmaps.directions(        start_location,        destination_location,        mode=&quot;transit&quot;,        departure_time=departure_time    )    return directions_result[0][&quot;legs&quot;][0][&quot;duration&quot;][&quot;text&quot;]agent = CodeAgent(tools=[get_travel_duration], model=HfApiModel(), additional_authorized_imports=[&quot;datetime&quot;])agent.run(&quot;Can you give me a nice one-day trip around Paris with a few locations and the times? Could be in the city or outside, but should fit in one day. I&#x27;m travelling only via public transportation.&quot;)\n\nCustom Function Agents自定义函数智能体是一类借助专门的函数调用（或称为 tools）来执行任务的人工智能智能体。与通用智能体不同，自定义函数智能体专注于通过直接与应用程序的逻辑相集成，为高级工作流程提供支持。例如，你可以将数据库查询、系统命令或任何自定义实用程序作为独立函数开放，以供智能体调用。\n","categories":["LLM"],"tags":["trl","smol"]},{"title":"【ML2025】1-生成式人工智能","url":"/blog/ML2025/gen-AI/","content":"\n李宏毅老师《机器学习》2025学习记录\n\n\n生成式人工智能有什么样的行为？\n现有的模型通常会体现“思考”的过程（脑内小剧场？？）。\n未来 AI 的工作不再局限于“一问一答”，很多任务需要多个步骤来完成 –&gt; AI agent\n使用 AI agent 来训练模型？？\n\n运作机制\n生成式人工智能的基本原理：输入一段 token，输出另一段 token。任何事物都可以由多个 token 表示：\nThose tokens were words, some of the tokens of course could now be images, or charts, or tables, songs … speech, videos. Those tokens could be anything. token 可以是单词，图片、表、歌曲、对话等等……\n\n\n\n\n\n不论什么任务，本质上都是 token 到 token。\n\n具体来说，是给输入 token 序列，预测下一个 token。\n然后将预测的 token 与输入的 token 序列拼接，然后再次输入到模型中，预测下一个 token，重复上述步骤，直到结束。\n\n\n例如，输入图像，输出文字，那么 z 就代表所有文字 token 和图像 token 的集合\n\n通常是使用深度网络来预测下一个 token。一个不恰当的比喻，假设任务为三个数字相加，每一个层为一个查表操作，如果只用一个层，那么需要存10^3种可能，如果分为两层，那么只需要10*10+19*10种可能。\n\n本质上，让模型“思考”（reason）也是一种“深度”。\n\n困难的问题需要思考很多步，layer 的深度不够了？\n深度不够，长度来凑！\n\n\n\n内容是怎样产生出来的？\n我们要怎样得到可以生成内容的模型？三步走！\nFind Function with Unknown Parameters\nDefine Loss from Training Data\nOptimation\n\n\n生成式模型也不是新的问题：从“专才”到“通才”的转变\n如何实现这个转变？大概包含以下三个阶段\n阶段一：训练通用的编码器，只能将输入 token 转换为 embedding，要实现下游任务，需要接对应的解码器。  \n阶段二：没那么好用的模型，只能生成 token，需要在特定任务上微调（相同架构，不同的参数）  \n阶段三：大模型时代！一个模型可以解决所有的问题（相同架构，相同参数）  \n\n\n\n如何赋予模型新的能力？\n方法1：微调\n\n方法2：模型编辑\n\n方法3：模型合并\n\n\n","categories":["ML2025"],"tags":["ML"]},{"title":"【代码随想录】数组1-二分查找","url":"/blog/Leetcode/array1/","content":"基本知识\n数组元素按照顺序排列\n数组元素无法删除，只能替代（填充）\npython 中，使用 list，代码中 List 是类型注解中的一种表示方式，通常出现在类型提示中。python 3.9 之后可以使用内置的 list 来替代 List。\n\n704. 二分查找\n题目链接 link\n\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n\n输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9输出: 4解释: 9 出现在 nums 中并且下标为 4     \n\n两个要点\n数组中元素按照顺序排列\n无重复的数字（否则元素下标不唯一）\n如果有重复的数字，要求返回最小的那个呢？\n\n\n\n解法\n区间定义：定义 target 所在的区间是左闭右开还是左右全闭\n核心：将数组分割为三个部分\n左右全闭：[0, middle-1] , middle, [middle + 1, len - 1] 或者\n左开右闭：[0, middle) , middle, [middle + 1, len)\n\n\n\n左右全闭\n区间为 [left, right]：\n定义 right 为 len(nums) - 1，因为 right 要有含义\n循环条件 while(left &lt;&#x3D; right) ，因为left &#x3D;&#x3D; right是有意义的\n判断条件，若 middle 大于 target ，则遍历左区间，设置 right &#x3D; middle - 1，因为此时为右闭区间，不会再访问 middle；同理，若 middle 小于 target，则遍历右边区间，设置 left &#x3D; middle + 1，同样因为是闭区间，不会再访问 middle。\n\n\n代码：class Solution:    def search(self, nums: List[int], target: int) -&gt; int:        left = 0        right = len(nums) - 1        while left &lt;= right:            middle = int((left + right) / 2)            if nums[middle] &gt; target:                right = middle - 1            elif nums[middle] &lt; target:                left = middle + 1            else:                return middle        return -1        \n\n左闭右开\n区间为 [left, right)：\n\n定义 right 为 len(nums)，因为不会访问 right，所以设置为区间长度\n循环条件 while(left &lt; right) ，因为left &#x3D;&#x3D; right没有意义（右边为开区间）\n判断条件，若 middle 大于 target ，则遍历左区间，设置 right &#x3D; middle，因为此时为右开区间，设置 right&#x3D;middle 实际上下一次会访问 middle - 1 。\n\n\n代码：\nclass Solution:    def search(self, nums: List[int], target: int) -&gt; int:        left = 0        right = len(nums)        while left &lt; right:            middle = int((left + right) / 2)            if nums[middle] &gt; target:                right = middle            elif nums[middle] &lt; target:                left = middle + 1            else:                return middle        return -1 \n\n相关题目1：35. 搜索插入位置\n题目链接 link\n\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n你可以假设数组中无重复元素。\n要点\n无重复元素 + 升序排列，考虑二分查找\n\n这道题相较于二分查找，只是多了一个 target 不存在的情况，在这个情况下，一定满足 left &#x3D;&#x3D; right + 1 （左右都为闭区间的情况）\n\n因为，在循环的最后一轮，满足 left &#x3D;&#x3D; right，此时 只剩下最后一个数字，middle 也为 left （right）。此时若 middle 数小于 target，则 left + 1，反之则 right - 1。\n基于这个原理，若 middle 数小于 target，target 应该放在 middle + 1 上，若 middle 数大于 target，则 target 应该放在 middle 上\n对比上述两条，可以发现：\nmiddle 数小于 target，left + 1，放在 middle + 1的位置\nmiddle 数大于 target， right - 1, middle 不变，放在 middle 的位置\nmiddle 的变化和 left 相同，即小于时加1，大于时不变，而最后一轮循环时 middle、left、right 均相同，则最后的结果一定为 left。\n\n\n\n\n代码如下，只需将二分查找的代码的最后一行，改为 return left 即可\nclass Solution:    def search(self, nums: List[int], target: int) -&gt; int:        left = 0        right = len(nums) - 1        while left &lt;= right:            middle = int((left + right) / 2)            if nums[middle] &gt; target:                right = middle - 1            elif nums[middle] &lt; target:                left = middle + 1            else:                return middle        return left\n\n相关题目2：34. 在排序数组中查找元素的第一个和最后一个位置\n题目链接 link给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n\n如果数组中不存在目标值 target，返回 [-1, -1]。\n进阶：你可以设计并实现时间复杂度为 $O(\\log n)$ 的算法解决此问题吗？\n示例 1：\n\n输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8输出：[3,4]\n\n示例 2：\n\n输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6输出：[-1,-1]\n\n示例 3：\n\n输入：nums &#x3D; [], target &#x3D; 0输出：[-1,-1]\n\n思路\n相似于二分查找，分别找左边界和右边界，找到一个目标后\n若要找左边界，则在找到的目标的左边数组中再次查找，right &#x3D; middle - 1。即认为当前找到的数比实际的 target 大。\n相似的，若要找右边界，则在找到的目标的右边数组中再次查找，left &#x3D; middle + 1。即认为当前找到的数比实际的 target 小。class Solution:    def searchRange(self, nums: List[int], target: int) -&gt; int:                leftb = mySearch(nums, target, True)        rightb = mySearch(nums, target, False)        def mySearch(nums: List[int], target: int, side: bool):            left = 0            right = len(nums) - 1            res = -1            while left &lt;= right:                middle = int((left + right) / 2)                if nums[middle] &gt; target:                    right = middle - 1                elif nums[middle] &lt; target:                    left = middle + 1                else:                    res = middle                    if side:                        # 左边界                        right = middle - 1                    else:                        left = middle + 1            return res        return [leftb, rightb]\n\n\n\n相关题目3：367. 有效的完全平方数\n题目链接 link给你一个非负整数 x ，计算并返回 x 的 算术平方根 。\n\n由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。\n注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。\n示例 1：\n\n输入：x &#x3D; 4输出：2\n\n示例 2：\n\n输入：x &#x3D; 8输出：2解释：8 的算术平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。\n\n思路\n二分查找，找到第一个平方不大于 x 的数字。class Solution:    def mySqrt(self, x: int) -&gt; int:        left = 0        right = x - 1        if x == 0: return 0        if x == 1: return 1        while left &lt;= right:            middle = int((left + right) / 2)            if middle * middle &gt; x:                right = middle - 1            elif middle * middle &lt; x:                left = middle + 1            else:                return middle        return right        \n\n","categories":["Leetcode"],"tags":["Array"]},{"title":"【代码随想录】数组2-双指针法","url":"/blog/Leetcode/array2/","content":"27. 移除元素\n题目链接 link\n\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n示例 1: \n\n给定 nums &#x3D; [3,2,2,3], val &#x3D; 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。\n\n示例 2: \n\n给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n\n你不需要考虑数组中超出新长度后面的元素。\n注意：需要改动原来的数组，虽然没有直接返回改动后的数组\n暴力解法两个循环，分别用于查找 val 和移动后续元素。注意第一个循环要用 while，因为移动后续元素时减少了一位，for 循环无法控制变量 i。\nclass Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        size = len(nums)        i = 0        while i &lt; size:            if nums[i] == val:                for j in range(i+1, size):                    nums[j-1] = nums[j]                size -= 1                i -= 1            i += 1        return size\n\n双指针法双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。本题中，两个指针分别代表：\n\n快指针：查找的索引\n慢指针：更改后的数组的索引此外，每一步都需要把快指针的值赋值给慢指针（无论是否遇到等于）class Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        size = len(nums)        fast, slow = 0, 0        while fast &lt; size:            nums[slow] = nums[fast]            if nums[fast] == val:                slow -= 1            fast += 1            slow += 1                return slow\n\n26. 删除有序数组中的重复项\n题目链接 link\n\n给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。\n考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：\n更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。返回 k 。\n示例 1：\n\n输入：nums &#x3D; [1,1,2]输出：2, nums &#x3D; [1,2,_]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n\n示例 2：\n\n输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]输出：5, nums &#x3D; [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n\n思路仍然是快慢指针法，只是没有给定 val，需要在循环中动态更新 val。更新 val 的规则为，如果当前 fast 对应的值不等于 val，则将其赋值给 val。因为数组升序排列，相同的数字在一起，如果 fast 对应的值和 val（上一个数字）不相等，说明上一个数字已经不重复了。\nclass Solution:    def removeDuplicates(self, nums: List[int]) -&gt; int:        slow, fast = 0, 0        size = len(nums)        val = None               while fast &lt; size:            nums[slow] = nums[fast]            if val == nums[fast]:                slow -= 1            else:                val = nums[fast]            slow += 1            fast += 1        return slow\n283. 移动零\n题目链接 link\n\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n示例 1:\n\n输入: nums &#x3D; [0,1,0,3,12]输出: [1,3,12,0,0]\n\n示例 2:\n\n输入: nums &#x3D; [0]输出: [0]\n\n思路相当于是 val 为 0 的删除元素，同样使用快慢指针法，只是最后需要将 [slow, fast) 区间内的元素赋值为 0。\nclass Solution:    def moveZeroes(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        slow, fast, size = 0, 0, len(nums)        while fast &lt; size:            nums[slow] = nums[fast]            if nums[fast] == 0:                slow -= 1            slow += 1            fast += 1                if fast != slow:            for i in range(slow, fast):                nums[i] = 0\n844. 比较含退格的字符串\n题目链接 link\n\n给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。\n注意：如果对空文本输入退格字符，文本继续为空。\n示例 1：\n\n输入：s &#x3D; “ab#c”, t &#x3D; “ad#c”输出：true解释：s 和 t 都会变成 “ac”。\n\n示例 2：\n\n输入：s &#x3D; “ab##”, t &#x3D; “c#d#”输出：true解释：s 和 t 都会变成 “”。\n\n示例 3：\n\n输入：s &#x3D; “a#c”, t &#x3D; “b”输出：false解释：s 会变成 “c”，但 t 仍然是 “b”。\n\n思路1双指针法，相当于是查找 “#” 字符，查找到之后删除 # 以及其之前的字符。注意要考虑 # 之前没有字符的情况。\nclass Solution:    def backspaceCompare(self, s: str, t: str) -&gt; bool:        def dele(nums: list):            slow, fast, size = 0, 0, len(nums)            while fast &lt; size:                nums[slow] = nums[fast]                if nums[fast] == &quot;#&quot;:                    if slow == 0:                        slow -= 1                    else:                        slow -= 2                                slow += 1                fast += 1            if slow &lt; 0:                return []            else:                return nums[0: slow]                s1 = dele(list(s))        t1 = dele(list(t))        s = &quot;&quot;.join(s1)        t = &quot;&quot;.join(t1)        if s == t:            return True        else:            return False\n\n思路2使用栈的思想，遍历到 # 字符，则当前栈顶的字符 pop。注意 list 的 pop 方法需要 list 不为空，所以需要进行判断。\nclass Solution:    def backspaceCompare(self, s: str, t: str) -&gt; bool:        def dele(nums: list):            ret = list()            for i in nums:                                if i != &quot;#&quot;:                                        ret.append(i)                elif len(ret) != 0:                    ret.pop()                        return &quot;&quot;.join(ret)        s = dele(list(s))        t = dele(list(t))                if s == t:            return True        else:            return False\n\n977. 有序数组的平方\n题目链接 link给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n\n示例 1：\n\n输入：nums &#x3D; [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100]\n\n示例 2：\n\n输入：nums &#x3D; [-7,-3,2,3,11]输出：[4,9,9,49,121]\n\n思路双指针法，左右分别两个指针，依次比较大小，直到左指针大于右指针。注意，这里需要返回新的数组，和上面的题目不一样，所以可以新建数组，不需要在原有数组上操作。\nclass Solution:    def sortedSquares(self, nums: List[int]) -&gt; List[int]:        left, right = 0, len(nums) - 1        new_nums = [0] * len(nums)        i = len(nums) - 1        while left &lt;= right:            if nums[left] * nums[left] &lt; nums[right] * nums[right]:                new_nums[i] = nums[right] * nums[right]                right -= 1            else:                new_nums[i] = nums[left] * nums[left]                left += 1            i -= 1        return new_nums        \n","categories":["Leetcode"],"tags":["Array"]},{"title":"【代码随想录】数组3-滑动窗口法","url":"/blog/Leetcode/array3/","content":"209.长度最小的子数组\n题目链接 link给定一个含有 n 个正整数的数组和一个正整数 target 。\n\n找出该数组中满足其总和大于等于 target 的长度最小的 子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n示例 1：\n\n输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n\n示例 2：\n\n输入：target &#x3D; 4, nums &#x3D; [1,4,4]输出：1\n\n示例 3：\n\n输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]输出：0\n\n解法1：暴力循环两个 for 循环即可解决，分别遍历子数组的开头以及子数组内部。使用 python 可能会超出时间限制。\nclass Solution:    def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:        min_len = 0        for i in range(len(nums)):            array_sum = 0            for j in range(i, len(nums)):                                array_sum += nums[j]                if array_sum &gt;= target:                    cur_len = j - i + 1                    if min_len == 0 or min_len &gt; cur_len:                        min_len = cur_len                    break                return min_len\n\n解法2：前缀和+二分查找方法一中，确定了数组的开始位置，查找结束位置的时间复杂度为 O(n)，如果使用二分查找，可以优化到 O(logn)。为了使用二分查找，需要额外创建一个数组 sums 用于存储数组 nums 的前缀和，其中 sums[i] 表示从 nums[0] 到 nums[i−1] 的元素和。得到前缀和之后，对于每个开始下标 i，可通过二分查找得到大于或等于 i 的最小下标 bound，使得 sums[bound]−sums[i−1]≥target，并更新子数组的最小长度（此时子数组的长度是 bound−(i−1)）。\n相当于是查找特定元素的插入位置，这个值就是题目中给定的 target，但是要注意，当窗口的起始位置不为 0 时，target 需要加上当前窗口的起始前缀和，因为我们的窗口要满足条件 sums[end] - sums[start] &gt;&#x3D; s，即 sums[end] &gt;&#x3D; s + sums[start]，要找到满足这个条件的 end，所以二分查找的 target1 定义为 target &#x3D; s + sums[start]。\nclass Solution:    def minSubArrayLen(self, s: int, nums: List[int]) -&gt; int:        if not nums:            return 0                n = len(nums)        ans = n + 1        sums = [0]        for i in range(n):            sums.append(sums[-1] + nums[i])                for i in range(1, n + 1):            target = s + sums[i - 1]            bound = bisect.bisect_left(sums, target)            if bound != len(sums):                ans = min(ans, bound - (i - 1))                return 0 if ans == n + 1 else ans\n\n\n解法3：滑动窗口在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环完成了一个不断搜索区间的过程。\n只用一个for循环，那么这个循环的索引，一定是表示滑动窗口的终止位置。对于窗口的起始位置，则基于窗口的和来判断是否需要移动。使用一个 while 循环来表示，如果子数组的和大于 target，则减去窗口起始位置的值，并使窗口起始位置 +1。\n此外，不要以为for里放一个while就以为是O(n^2)， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。\nclass Solution:    def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:        min_len = 0        start = 0        array_sum = 0        for end in range(len(nums)):            array_sum += nums[end]            while array_sum &gt;= target:                cur_len = end - start + 1                if min_len == 0 or min_len &gt; cur_len:                    min_len = cur_len                array_sum -= nums[start]                start += 1        return min_len\n\n904. 水果成篮\n题目链接 link\n\n你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果种类 。\n你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：\n你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。\n示例 1：\n\n输入：fruits &#x3D; [1,2,1]输出：3解释：可以采摘全部 3 棵树。\n\n示例 2：\n\n输入：fruits &#x3D; [0,1,2,2]输出：3解释：可以采摘 [1,2,2] 这三棵树。如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。\n\n示例 3：\n\n输入：fruits &#x3D; [1,2,3,2,2]输出：4解释：可以采摘 [2,3,2,2] 这四棵树。如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。\n\n示例 4：\n\n输入：fruits &#x3D; [3,3,3,1,2,1,1,2,3,3,4]输出：5解释：可以采摘 [1,2,1,1,2] 这五棵树。\n\n思路相当于是只包含两个数字的最长子数组，使用了一个 Counter 类，Counter 是一个计数器字典，可以自动统计元素出现的次数。pop 方法用于删除指定的 key，并可以返回其 value。\nclass Solution:    def totalFruit(self, fruits: List[int]) -&gt; int:        max_len = 0        start = 0        cnt = Counter()        for end in range(0, len(fruits)):            cnt[fruits[end]] += 1            while len(cnt) &gt; 2:                cnt[fruits[start]] -= 1                if cnt[fruits[start]] == 0:                    cnt.pop(fruits[start])                            start += 1            max_len = max(max_len, end - start + 1)                return max_len\n\nCounter 类等价于\ncnt = &#123;&#125;cnt[x] = cnt.get(x, 0)\n\nget 方法查找指定 key 对应的 value，找不到时返回默认值，使用原始 dict 的代码如下：\nclass Solution:    def totalFruit(self, fruits: List[int]) -&gt; int:        max_len = 0        start = 0        cnt = dict()        for end in range(0, len(fruits)):            cnt[fruits[end]] = cnt.get(fruits[end], 0) + 1            while len(cnt) &gt; 2:                cnt[fruits[start]] -= 1                if cnt[fruits[start]] == 0:                    cnt.pop(fruits[start])                            start += 1            max_len = max(max_len, end - start + 1)                return max_len            \n\n76. 最小覆盖子串（Hard）\n题目链接 link\n\n给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。\n注意：\n对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。如果 s 中存在这样的子串，我们保证它是唯一的答案。\n示例 1：\n\n输入：s &#x3D; “ADOBECODEBANC”, t &#x3D; “ABC”输出：”BANC”解释：最小覆盖子串 “BANC” 包含来自字符串 t 的 ‘A’、’B’ 和 ‘C’。  \n\n示例 2：\n\n输入：s &#x3D; “a”, t &#x3D; “a”输出：”a”解释：整个字符串 s 是最小覆盖子串。\n\n示例 3:\n\n输入: s &#x3D; “a”, t &#x3D; “aa”输出: “”解释: t 中两个字符 ‘a’ 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。\n\n滑动窗口\n核心为如何判断当前 s 的窗口是否覆盖了 t。可以使用一个哈希表来记录，同时，t 中可能有重复的字符，所以需要记录字符的个数（两个计数器，需要的字符个数，和当前窗口已经有的个数）。此外，Counter 可以直接使用大于和小于运算符来进行判断是否覆盖。所以可以写出以下代码：\nclass Solution:    def minWindow(self, s: str, t: str) -&gt; str:        min_str = &quot;&quot;        s_list = list(s)        t_list = list(t)        start = 0        t_cnt = Counter()        s_cnt = Counter()        for i in t_list:            t_cnt[i] += 1          for end in range(len(s_list)):            s_cnt[s_list[end]] += 1            while s_cnt &gt;= t_cnt:                if min_str == &quot;&quot; or len(min_str) &gt; end - start + 1:                    min_str = &quot;&quot;.join(s_list[start: end + 1])                s_cnt[s_list[start]] -= 1                start += 1                return min_str\n但是，上述代码会提示超时，原因是每次更新最小子字符串时，都会进行切片操作， 也是新建字符串对象（O(end - start)，所以可以使用两个变量 ans_start 和 ans_end 来记录对应的下标，只在最后对字符串进行操作。需要注意的是，ans_end 不能一开始就设置为0，因为如果没有满足的子字符串，会直接返回 s[0：1]，不符合要求。可以把 ans_end 设置为 len(s)。\nclass Solution:    def minWindow(self, s: str, t: str) -&gt; str:        s_list = list(s)        t_list = list(t)        start = 0        t_cnt = Counter()        s_cnt = Counter()        ans_start = 0        ans_end = len(s)        for i in t_list:            t_cnt[i] += 1          for end in range(len(s_list)):            s_cnt[s_list[end]] += 1            while s_cnt &gt;= t_cnt:                if ans_end == len(s) or ans_end - ans_start &gt; end - start:                    ans_end = end                    ans_start = start                s_cnt[s_list[start]] -= 1                start += 1        if ans_end == len(s):            return &quot;&quot;        else:            return &quot;&quot;.join(s_list[ans_start: ans_end + 1])\n\nCounter 本质上是一个 dict，如果使用 dict，需要定义一个判断函数，注意，这里是遍历了 t 对应的 dict，即需要的字符数量，时间复杂度为 O(|len(t)|)，dict 为哈希表，读写的时间复杂度为 O(1)。\nclass Solution:    def minWindow(self, s: str, t: str) -&gt; str:        s_list = list(s)        t_list = list(t)        start = 0        t_cnt = dict()        s_cnt = dict()        ans_start = 0        ans_end = len(s)        for i in t_list:            t_cnt[i] = t_cnt.get(i, 0) + 1          for end in range(len(s_list)):            s_cnt[s_list[end]] = s_cnt.get(s_list[end], 0) + 1            while self.check(s_cnt, t_cnt):                if ans_end == len(s) or ans_end - ans_start &gt; end - start:                    ans_end = end                    ans_start = start                s_cnt[s_list[start]] -= 1                start += 1        if ans_end == len(s):            return &quot;&quot;        else:            return &quot;&quot;.join(s_list[ans_start: ans_end + 1])                def check(self, s_cnt1, t_cnt1):        for key, value in t_cnt1.items():            if value &gt; s_cnt1.get(key, 0):                return False                return True","categories":["Leetcode"],"tags":["Array"]},{"title":"【代码随想录】数组4-模拟过程","url":"/blog/Leetcode/array4/","content":"59. 螺旋矩阵 II\n题目链接 link\n\n给你一个正整数 n ，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\n示例：\n\n输入：n &#x3D; 3输出：[[1,2,3],[8,9,4],[7,6,5]]\n\n思路核心：左闭右开进行填充，每个圈按照以下顺序来画：\n\n填充上行从左到右\n填充右列从上到下\n填充下行从右到左\n填充左列从下到上\n\n循环变量为要画的圈的数量（偏移量，因为是左闭右开区间，每一行（列）的最后一位不填）定义：\n\n起点：每一圈的左上角的点\n终点：n 减去偏移量class Solution:    def generateMatrix(self, n: int) -&gt; List[List[int]]:        res = [[0 for _ in range(n)] for _ in range(n)]        loop = n // 2                startx, starty = 0, 0        count = 1        for offset in range(1, loop + 1):            for i in range(starty, n - offset):                res[startx][i] = count                count += 1            for i in range(startx, n - offset):                res[i][n - offset] = count                count += 1                        for i in range(n - offset, starty, -1):                res[n - offset][i] = count                count += 1                        for i in range(n - offset, startx, -1):                res[i][starty] = count                count += 1                        startx += 1            starty += 1        if n % 2 != 0:            res[n // 2][n // 2] = count        return res\n\n54. 螺旋矩阵\n题目链接 link\n\n给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。\n示例：\n\n输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5]\n\n\n思路上一个题目的扩展，即形状不一定为正方形，有以下几个方面的考虑：\n\n循环的次数（几个 loop）决定于 matrix 的短边\n计算偏移量时要注意是长边减去偏移量还是短边\n中间部分的处理：\n如果是正方形，则直接边长 &#x2F;&#x2F; 2 进行读取\n如果是长方形，则需要注意：\n判断中间部分是哪条边\n默认的情况是左闭右开，本来需要将 offset - 1，但是中间部分需要左闭右闭，则 offset 不用 - 1\n\n\n\n\n\nclass Solution:    def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:        x = len(matrix)        y = len(matrix[0])        loop = min(x, y) // 2        startx = 0        starty = 0        res = []        offset = 0        for offset in range(1, loop + 1):            for i in range(starty, y - offset):                res.append(matrix[startx][i])                        for i in range(startx, x - offset):                res.append(matrix[i][y - offset])                        for i in range(y - offset, starty, -1):                res.append(matrix[x - offset][i])                        for i in range(x - offset, startx, -1):                res.append(matrix[i][starty])            startx += 1            starty += 1                if x == y and x % 2 != 0:            res.append(matrix[x // 2][y // 2])        elif x &gt; y and y % 2 != 0:            for i in range(startx, x - offset):                res.append(matrix[i][y // 2])        elif x &lt; y and x % 2 != 0:            for i in range(starty, y - offset):                res.append(matrix[x // 2][i])                return res\n\n","categories":["Leetcode"],"tags":["Array"]},{"title":"【代码随想录】数组5-前缀和","url":"/blog/Leetcode/array5/","content":"58. 区间和\n题目链接 link\n\n给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。\n第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间下标：a，b （b &gt; &#x3D; a），直至文件结束。输出每个指定区间内元素的总和。  \n输入示例\n\n5123450 11 3\n\n输出示例\n\n39\n\n思路：前缀和重复利用计算过的子数组之和，从而降低区间查询需要累加计算的次数。ACM 输入格式。注意：\n\n前缀和的写法，第一位是 0\n按照下面的写法，计算一次就输出一次，会超出限制，可以使用一个数组把结果存起来，然后统一输出\n按照下面的写法，data 可能会超出限制，报错 下标无法访问，所以需要判断是否有查询\n\nimport sysinput = sys.stdin.readdata = input().split()n = int(data[0])sums = [0]for i in range(1, n+1):    sums.append(int(data[i]) + sums[-1])for index in range(n+1, len(data), 2)    a = int(data[index])    b = int(data[index+1])    index += 2        res.append(sums[b+1] - sums[a])    print(res)\n\n更改后的代码：\nimport sysinput = sys.stdin.readdata = input().split()n = int(data[0])sums = [0]for i in range(1, n+1):    sums.append(int(data[i]) + sums[-1])index = n + 1res = []while index &lt; len(data):    a = int(data[index])    b = int(data[index+1])    index += 2        res.append(sums[b+1] - sums[a])    print(res)\n\n44. 开发商购买土地\n题目链接 link\n\n在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。 \n现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。\n然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。 为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。 \n注意：区块不可再分。\n第一行输入两个正整数，代表 n 和 m。接下来的 n 行，每行输出 m 个正整数。请输出一个整数，代表两个子区域内土地总价值之间的最小差距。\n示例：输入\n\n3 31 2 32 1 31 2 3  \n\n输出：\n\n0\n\n思路本质上还是区间和，之不是二维的，需要考虑两个方向的求和。可以先针对两个方向求前缀和，然后进行判断。例如水平分割时，可以将数组先按行求和，然后再计算前缀和。\nimport sysinput = sys.stdin.readdata = input().split()n, m = int(data[0]), int(data[1])num = [[0] * m for _ in range(n)]index = 2for i in range(n):    for j in range(m):        num[i][j] = int(data[index])        index += 1# 求每一行的和sumx = [sum(num[i]) for i in range(n)]# 按行的前缀和sumx_pre = [sumx[0]]for i in range(1, n):    sumx_pre.append(sumx[i] + sumx_pre[-1])minx = float(&#x27;inf&#x27;)# 计算最小的差for i in range(0, n - 1):    p1 = sumx_pre[i]    p2 = sumx_pre[-1] - sumx_pre[i]    dif = abs(p2 - p1)    if minx &gt; dif:        minx = dif# 求每一列的和sumy = [sum(num[i][j] for i in range(n)) for j in range(m)]# 按列的前缀和sumy_pre = [sumy[0]]for j in range(1, m):    sumy_pre.append(sumy[j] + sumy_pre[-1])miny = float(&#x27;inf&#x27;)for j in range(0, m - 1):    p1 = sumy_pre[j]    p2 = sumy_pre[-1] - sumy_pre[j]    dif = abs(p2 - p1)    if  miny &gt; dif:        miny = difprint(min(miny, minx))\n\n优化在读取数据时，直接求整个矩阵的和。然后分别两个方向求和，模拟行分割和列分割。每求和一行（列），就计算差值。这样可以省去计算前缀和的步骤。\n总结\nACM 格式下，需要自己处理输入，这里重写了 input 方法：\n\nimport sysinput = sys.stdin.readdata = input().split()\n\nsplit()：多个空格当成一个空格；split(‘ ‘)：多个空格都要分割，每个空格分割出来空。\n重写的和自带的方法对比如下：\n重写的方法可以将所有输入作为一整个字符串读取，可以减少 IO 时间。后续使用 .split() 方法来拆分每个输入即可。\n\n题目要求求最小值时，可以将表示最小值的变量预先定义为正无穷 float(‘inf’)，便于后续比较。同理，最大值可以定义为服务器 float(‘-inf’)。\n\n本题中需要计算的是两个块之间的差，注意使用绝对值 abs()。\n\n\n","categories":["Leetcode"],"tags":["Array"]},{"title":"【代码随想录】回溯1-组合问题","url":"/blog/Leetcode/backtrack1/","content":"回溯法回溯是递归的副产品，只要有递归就会有回溯。回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。通常可以解决以下问题：\n\n组合问题：N个数里面按一定规则找出k个数的集合\n切割问题：一个字符串按一定规则有几种切割方式\n子集问题：一个N个数的集合里有多少符合条件的子集\n排列问题：N个数按一定规则全排列，有几种排列方式\n棋盘问题：N皇后，解数独等等\n\n回溯法解决的问题都可以抽象为树形结构。因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度就构成了树的深度。\n回溯法模板\n回溯函数返回值和参数\n回溯算法需要的参数不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。\n\n\n回溯函数终止条件\n？\n\n\n回溯搜索的遍历过程\n回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。\n\n\n\n\nfor (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;    处理节点;    backtracking(路径，选择列表); // 递归    回溯，撤销处理结果&#125;\n\n总结起来模板如下：\nvoid backtracking(参数) &#123;    if (终止条件) &#123;        存放结果;        return;    &#125;    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;        处理节点;        backtracking(路径，选择列表); // 递归        回溯，撤销处理结果    &#125;&#125;\n\n77. 组合\nlink\n\n给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。\n示例: 输入: n &#x3D; 4, k &#x3D; 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]\n思路直接的思路为 k 重循环。但是 k 很大时就写不出来了。\n要解决 n 为 100，k 为 50 的情况，暴力写法需要嵌套 50 层 for 循环，那么回溯法就用递归来解决嵌套层数的问题。\n组合问题可以抽象为：\n\n每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围。图中可以发现 n 相当于树的宽度，k 相当于树的深度。那么如何在这个树上遍历，然后收集到我们要的结果集呢？图中每次搜索到了叶子节点，我们就找到了一个结果。\n\n递归函数的返回值和参数：n 和 k，以及一个起始索引 start，用于指定从哪个位置开始取数。此外，还需要两个全局变量，一个用于存放所有的结果 res，另一个用于存放当前路径下的结果 cur。\n递归函数的终止条件：当前路径下的结果长度等于 k，即 len(cur) &#x3D;&#x3D; k，就说明到了叶子节点。\n单层搜索的过程：回溯法的搜索过程就是一个树型结构的遍历过程，for 循环用来横向遍历（当层），递归的过程是纵向遍历。所以 for 循环从 start 开始遍历，然后递归下一层。\n\n代码如下，注意两个点：\n\n把当前结果 cur 加入最终结果 res 时，不能直接 res.append(cur)，因为 list 是可变对象，这样写是深拷贝，加入 res 的是引用。需要写成 res.append(cur[:]) 或 res.append(list(cur))。\n第一次调用回溯函数时，start 应该是 1，不是 0。\n\nclass Solution:    def combine(self, n: int, k: int) -&gt; List[List[int]]:        res = []        cur = []        def backtrack(n, k, start):            if len(cur) == k:                res.append(cur[:])                return                        for i in range(start, n+1):                # 把当前节点加入到结果中                cur.append(i)                # 处理下一层                backtrack(n, k, i + 1)                # 将当前元素移除，然后处理下一个元素                cur.pop()        backtrack(n, k, 1)        return res \n\n减枝优化例如 n &#x3D; 4，k &#x3D; 4 的话，那么第一层 for 循环的时候，从元素 2 开始的遍历都没有意义了。 在第二层 for 循环，从元素 3 开始的遍历都没有意义了。\n\n所以，可以剪枝的地方就在递归中每一层的 for 循环所选择的结束位置。优化过程为：\n\n已经有的元素个数 len(cur)\n还需要的个数 k - len(cur)\n当前集合最多允许的结束位置 n - (k - len(cur)) + 1。\n后面剩下的要留给后续层来遍历，即后面还需要剩下 k - len(cur) 个元素\n注意这个 +1，例如在第二层，len(cur) &#x3D;&#x3D; 1，还需要 3，从后往前数 3 个，只能到 2（是在 [1, 2, 3, 4] 里面），n - (k - len(cur)) &#x3D;&#x3D; 1，所以这里有一个 +1。注意这里不是索引，而是要选的数字。\n此外，由于 range 是左闭右开，所以代码中是 +2。\n\n\n\nclass Solution:    def combine(self, n: int, k: int) -&gt; List[List[int]]:        res = []        cur = []        def backtrack(n, k, start):            if len(cur) == k:                res.append(cur[:])                return            # 减枝，注意这个 +2            for i in range(start, n - (k - len(cur)) + 2):                # 把当前节点加入到结果中                cur.append(i)                # 处理下一层                backtrack(n, k, i + 1)                # 将当前元素移除，然后处理下一个元素                cur.pop()        backtrack(n, k, 1)        return res \n\n\n17.电话号码和字母的组合\nlink\n\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n思路类似于 77.组合，只不过每一层遍历的对象都不一样，需要建立一个数字和字符串映射的字典。递归调用的参数要包含一个索引，表示当前层应该访问的数字。\nclass Solution:    def letterCombinations(self, digits: str) -&gt; List[str]:        m = &#123;            2: &quot;abc&quot;,            3: &quot;def&quot;,            4: &quot;ghi&quot;,            5: &quot;jkl&quot;,            6: &quot;mno&quot;,            7: &quot;pqrs&quot;,            8: &quot;tuv&quot;,            9: &quot;wxyz&quot;        &#125;        res = []        cur = []        def backtract(digits, index):            if len(digits) == 0:                return            if len(cur) == len(digits):                res.append(&quot;&quot;.join(cur))                return            cur_str = m[int(digits[index])]            for i in cur_str:                cur.append(i)                backtract(digits, index+1)                cur.pop()                backtract(digits, 0)        return res\n\n216.组合总和III\nlink\n\n找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：\n只使用数字 1 到 9，每个数字 最多使用一次。返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。\n\n输入: k &#x3D; 3, n &#x3D; 9输出: [[1,2,6], [1,3,5], [2,3,4]]解释:1 + 2 + 6 &#x3D; 91 + 3 + 5 &#x3D; 92 + 3 + 4 &#x3D; 9  \n\n思路同样类似于 77.组合，递归三部曲：\n\n参数和返回值：参数为当前层的起始值 start（应该从哪个数开始选）和当前的综合 total（避免多次调用 sum 函数）\n递归终止条件：当前结果 cur 长度为 k，并且和为 n，则将当前结果加入到 res；如果和大于 n 或者长度大于 k，则直接返回（剪枝操作）\n递归核心逻辑：和 77.组合 类似。\n\nclass Solution:    def combinationSum3(self, k: int, n: int) -&gt; List[List[int]]:        res = []        cur = []        def backtrack(start, total):            if len(cur) &gt; k or total &gt; n:                return            if len(cur) == k and total == n:                res.append(cur[:])                return            for i in range(start, 10):                cur.append(i)                backtrack(i + 1, total + i)                cur.pop()        backtrack(1, 0)        return res\n\n39.组合总和\nlink给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。\n\ncandidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 target 的不同组合数少于 150 个。\n\n输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7输出：[[2,2,3],[7]]解释：2 和 3 可以形成一组候选，2 + 2 + 3 &#x3D; 7 。注意 2 可以使用多次。7 也是一个候选， 7 &#x3D; 7 。仅有这两种组合。\n\n思路类似于上一题，只不过递归的主逻辑中，再次递归时，数组访问的起点可以和当前相同（因为可以重复选某些数字）\nclass Solution:    def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:        res = []        cur = []        def backtrack(start, total):            if total == target:                res.append(cur[:])                return            elif total &gt; target:                return             for i in range(start, len(candidates)):                cur.append(candidates[i])                backtrack(i, total+candidates[i])                cur.pop()                    backtrack(0, 0)        return res\n\n\n40.组合总和II\nlink\n\n给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用 一次 。注意：解集不能包含重复的组合。candidates 中可能有重复的元素。\n示例 1:\n输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,输出:[[1,1,6],[1,2,5],[1,7],[2,6]]\n思路和上一题一样，只不过添加了不能选取重复数字的限制。只需要在递归的逻辑中更改即可。但是注意，candidates 中可能有重复元素，例如 candidates &#x3D; [1,1,2]，target &#x3D; 3，两个 1 都会被选，所以结果为 [[1,2],[1,2]]。\n所以首先将 candidates 排序，然后判断当前数字是否和上一个相同，如果相同就跳过。\nclass Solution:    def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]:        res = []        cur = []        candidates.sort()        def backtrack(start, total):            if total == target:                res.append(cur[:])                return            elif total &gt; target:                return             for i in range(start, len(candidates)):                # 判断当前数字是否和上一个相同，如果相同就跳过                if i &gt; start and candidates[i] == candidates[i - 1]:                    continue                cur.append(candidates[i])                backtrack(i+1, total+candidates[i])                cur.pop()                    backtrack(0, 0)        return res     ","categories":["Leetcode"],"tags":["backtrack"]},{"title":"【代码随想录】回溯3-子集","url":"/blog/Leetcode/backtrack3/","content":"78.子集\nlink给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。\n\n思路如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点。\n\n只需要在回溯函数中每次都添加当前结果即可，注意可以不添加终止函数。\nclass Solution:    def subsets(self, nums: List[int]) -&gt; List[List[int]]:        res = []        cur = []        def backtrack(start):            res.append(cur[:])            # if start == len(nums):            #     return            for i in range(start, len(nums)):                cur.append(nums[i])                backtrack(i + 1)                cur.pop()                    backtrack(0)        return res\n90.子集II\nlink\n\n和上一题类似，只不过给定的 nums 可能包含重复元素\n思路直接用上一题的代码会重复选择某些元素，解决方法可以是先将数据进行排序，然后判断当前元素和前一个选择的元素是否相等，如果相等则跳过。\nclass Solution:    def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]:        res = []        cur = []        nums.sort()        def backtrack(start):            res.append(cur[:])            # if start == len(nums):            #     return            pre = None            for i in range(start, len(nums)):                if pre == None or pre != nums[i]:                    cur.append(nums[i])                    backtrack(i + 1)                    pre = cur.pop()                        backtrack(0)        return res\n\n更正确（？）的写法，分清楚树枝和树层之间的关系，使用一个 used 数组，如果当前数字和前一个数字相同，并且 前一个数字已经 used，说明当前层已经用过该数字，需要跳过。\n\nused[i - 1] &#x3D;&#x3D; true，说明同一树枝 candidates[i - 1]使用过used[i - 1] &#x3D;&#x3D; false，说明同一树层 candidates[i - 1]使用过而我们要对同一树层使用过的元素进行跳过  \n\n\n注意需要动态更新 used 数组。\nclass Solution:    def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]:        res = []        cur = []        used = [False] * len(nums)        nums.sort()        def backtrack(start):            res.append(cur[:])                        for i in range(start, len(nums)):                if i != 0 and used[i - 1] == False and nums[i] == nums[i-1]:                    continue                cur.append(nums[i])                used[i] = True                backtrack(i + 1)                used[i] = False                cur.pop()                             backtrack(0)        return res","categories":["Leetcode"],"tags":["backtrack"]},{"title":"【代码随想录】回溯2-分割回文串","url":"/blog/Leetcode/backtrack2/","content":"131.分割回文串\nlink\n\n给你一个字符串 s，请你将 s 分割成一些 子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。\n思路类似于组合问题，也可以抽线成一棵树\n\n\n递归参数：当前字符串的起始位置\n结束条件：遍历到字符串末尾就结束，并将 cur 加入 res。（递归逻辑中保证当前 cur 一定是满足条件的）\n递归逻辑：如果当前子串是回文串则加入 cur，并且向下递归。注意，如果当前子串不是回文串则直接剪枝，不进行后续步骤。（保证当前 cur 一定是满足条件的）\n\nclass Solution:    def partition(self, s: str) -&gt; List[List[str]]:        res = []        cur = []        def ishuiwen(start, end):            while start &lt;= end:                if s[start] != s[end]:                    return False                start += 1                end -= 1            return True        def backtrack(start):            if start == len(s):                res.append(cur[:])                return                        for i in range(start, len(s)):                if ishuiwen(start, i):                    cur.append(s[start:i+1])                    backtrack(i+1)                    cur.pop()           backtrack(0)        return res\n\n93.复原IP地址\nlink\n\n有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔\n思路递归的逻辑中，由于 ip 地址最长为 3 位，所以 for 循环只需要循环三次，但是要考虑到不能超过 s 的长度，所以 range 的结束点为 min(start + 3, len(s))。\nclass Solution:    def restoreIpAddresses(self, s: str) -&gt; List[str]:        res = []        cur = []        def isvad(subs):            num = int(subs)            if num == 0 and len(subs) == 1:                return True            if num == 0 and len(subs) &gt; 1:                return False            elif subs[0] == &#x27;0&#x27;:                return False            elif num &gt; 255:                return False            else:                return True                def backtrack(start):            if start == len(s) and len(cur) == 4:                res.append(&quot;.&quot;.join(cur))                return            if len(cur) &gt; 4:                return                        for i in range(start, min(start + 3, len(s))):                if isvad(s[start:i+1]):                    cur.append(s[start:i+1])                    backtrack(i+1)                    cur.pop()        backtrack(0)        return res\n","categories":["Leetcode"],"tags":["backtrack"]},{"title":"【代码随想录】回溯4-排列","url":"/blog/Leetcode/backtrack4/","content":"46.全排列\nlink\n\n给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。\n思路\n参数和返回值：排序是有序的，也就是说 [1,2] 和 [2,1] 是两个集合，所以处理排列问题就不用使用startIndex了。但排列问题需要一个used数组，标记已经选择的元素，如图橘黄色部分所示。\n\n终止条件：cur 长度等于 nums 长度\n\n单层逻辑：每次都需要从头开始选取，不能从 start 开始。此时使用 used 数组来标识当前元素是否被使用过。\n\n\nclass Solution:    def permute(self, nums: List[int]) -&gt; List[List[int]]:        cur = []        res = []        used = [False] * len(nums)        def backtrack():            if len(cur) == len(nums):                res.append(cur[:])                return                         for i in range(len(nums)):                if used[i]:                    continue                                cur.append(nums[i])                used[i] = True                backtrack()                cur.pop()                used[i] = False        backtrack()        return res\n47.全排列 II\nlink\n\n去重逻辑类似于 子集II，首先将数组排序，如果当前数字和上一个数字相同并且当前层已经使用过，就跳过\n\nused[i - 1] &#x3D;&#x3D; true，说明同一树枝 candidates[i - 1]使用过used[i - 1] &#x3D;&#x3D; false，说明同一树层 candidates[i - 1]使用过而我们要对同一树层使用过的元素进行跳过  \n\nclass Solution:    def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]:        cur = []        res = []        used = [False] * len(nums)        nums.sort()        def backtrack():            if len(cur) == len(nums):                res.append(cur[:])                return                         for i in range(len(nums)):                if used[i]:                    continue                if i != 0 and nums[i] == nums[i-1] and used[i-1] == False:                    continue                cur.append(nums[i])                used[i] = True                backtrack()                cur.pop()                used[i] = False        backtrack()        return res","categories":["Leetcode"],"tags":["backtrack"]},{"title":"【代码随想录】回溯5-棋盘问题","url":"/blog/Leetcode/backtrack5/","content":"51. N皇后\nlink\n\n按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。\n示例：\n\n输入：n &#x3D; 4输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]解释：如上图所示，4 皇后问题存在两个不同的解法。  \n\n思路搜索皇后的位置可以理解为一棵树：\n\n从图中，可以看出，二维矩阵中矩阵的高就是这棵树的高度，矩阵的宽就是树形结构中每一个节点的宽度。那么用皇后们的约束条件，来回溯搜索这棵树，只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了。\n递归三部曲：\n\n参数和返回值：同样使用 res 和 cur\n终止条件：遍历到最底层就结束，并把 cur 加入到 res 中\n单层逻辑：递归深度就是 row 控制棋盘的行，每一层里 for 循环的 col 控制棋盘的列，一行一列，确定了放置皇后的位置。每次都是要从新的一行的起始位置开始搜，所以都是从 0 开始。\n\n此外还需要判断棋盘是否合法，可以考虑剪枝，即对于当前考虑的位置，只需要考虑当前列、左上角和右上角是否存在皇后即可，不需要遍历整个棋盘。（由于 for 循环中每次只选择一个位置放皇后，所以当前行一定是空的）\nclass Solution:    def solveNQueens(self, n: int) -&gt; List[List[str]]:        res = []        cur = [&#x27;.&#x27; * n for _ in range(n)]        def isvad(row, col):            # 检查列            for i in range(row):                if cur[i][col] == &#x27;Q&#x27;:                    return False  # 当前列已经存在皇后，不合法            # 检查 45 度角是否有皇后            i, j = row - 1, col - 1            while i &gt;= 0 and j &gt;= 0:                if cur[i][j] == &#x27;Q&#x27;:                    return False  # 左上方向已经存在皇后，不合法                i -= 1                j -= 1            # 检查 135 度角是否有皇后            i, j = row - 1, col + 1            while i &gt;= 0 and j &lt; len(cur):                if cur[i][j] == &#x27;Q&#x27;:                    return False  # 右上方向已经存在皇后，不合法                i -= 1                j += 1            return True  # 当前位置合法        def backtrack(row):            if row &gt;= n:                res.append(cur[:])            for col in range(n):                if isvad(row, col):                    cur[row] = cur[row][:col] + &#x27;Q&#x27; + cur[row][col+1:]                    backtrack(row + 1)                    cur[row] = cur[row][:col] + &#x27;.&#x27; + cur[row][col+1:]        backtrack(0)        return res\n\n37. 解数独\nlink编写一个程序，通过填充空格来解决数独问题。\n\n一个数独的解法需遵循如下规则： 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 空白格用 ‘.’ 表示。\n思路N 皇后问题是每一行每一列只放一个皇后，只需要一层 for 循环遍历一行，递归来遍历列，然后一行一列确定皇后的唯一位置。本题中棋盘的每一个位置都要放一个数字（而 N 皇后是一行只放一个皇后），并检查数字是否合法，解数独的树形结构要比 N 皇后更宽更深。\n\n递归三部曲：\n\n参数和返回值：返回值为 bool，因为解数独找到一个符合的条件（就在树的叶子节点上）立刻就返回，相当于找从根节点到叶子节点一条唯一路径，所以需要使用 bool 返回值。\n递归终止条件：不用终止条件，解数独是要遍历整个树形结构寻找可能的叶子节点就立刻返回。\n递归单层搜索逻辑：两层循环遍历所有可能的位置。两层循环中，会出现两种情况：\n当前格选不出任何合法的数字，则返回 False\n当前位置放下数字之后，再次递归调用，同样出现：\n选不出任何合法数字（或者当前的递归中没有返回 True），返回 False，然后回溯，处理下一个情况\n重复递归调用，一直没有报错，直到整个棋盘被填满，则返回 True。然后，回到上一层递归中，同样返回 True（代码中部的 return），即找到一个解，直接结束递归。\n\n\n\n\n\n关于判断冲突，需要判断当前位置所在行、列、网格中是否存在当前数字。行和列比较好理解。对于网格，首先需要找到当前位置所在网格的左上角，即 [(row&#x2F;&#x2F;3)*3, (col&#x2F;&#x2F;3)*3]，在此基础上 +3 即为遍历的结束位置。\n下面的代码会报超出时间限制\nclass Solution:    def solveSudoku(self, board: List[List[str]]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify board in-place instead.        &quot;&quot;&quot;        def isvad(row, col, k):            for i in range(9):                if board[row][i] == k:                    return False                if board[i][col] == k:                    return False                        for i in range(3):                for j in range(3):                    if board[(row // 3) * 3 + i][(col // 3) * 3 + j] == k:                        return False            return True                def backtrack():            for i in range(9):                for j in range(9):                    if board[i][j] == &#x27;.&#x27;:                        for k in &#x27;123456789&#x27;:                            if isvad(i, j, k):                                board[i][j] = k                                if backtrack():                                    return True                                board[i][j] = &#x27;.&#x27;                        return False            return True        backtrack()\n\n进一步优化：使用 set 来判断是否重复。提前构建以下三个结构：\n\nrows[i]：第 i 行中已有数字；\ncols[j]：第 j 列中已有数字；\nboxes[i&#x2F;&#x2F;3][j&#x2F;&#x2F;3]：第 i,j 所在宫格已有数字。\n\n这样 isvad() 不需要每次遍历整行整列整宫格，而是 O(1) 判断。此外通过 empty 来记录当前棋盘中空的位置，这样就不需要两重遍历了，而是直接遍历当前的 empty 数组。\n单层的递归逻辑和上面的代码相同，如果递归的过程中没有返回 True，而是一直到 empty 数组的末尾，如果当前的下标超过 empty 则直接返回 True。\nclass Solution:    def solveSudoku(self, board: List[List[str]]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify board in-place instead.        &quot;&quot;&quot;        rows = [set() for _ in range(9)]        cols = [set() for _ in range(9)]        # 注意初始化写法        boxes = [[set() for _ in range(3)] for _ in range(3)]        empty = []        for i in range(9):            for j in range(9):                if board[i][j] == &#x27;.&#x27;:                    empty.append((i, j))                else:                    rows[i].add(board[i][j])                    cols[j].add(board[i][j])                    boxes[i // 3][j // 3].add(board[i][j])        def backtrack(pos):            if pos == len(empty):                return True            i, j = empty[pos]            for ch in &#x27;123456789&#x27;:                if (ch not in rows[i] and                    ch not in cols[j] and                    ch not in boxes[i // 3][j // 3]):                    # 放置                    board[i][j] = ch                    rows[i].add(ch)                    cols[j].add(ch)                    boxes[i // 3][j // 3].add(ch)                    if backtrack(pos + 1):                        return True                    # 撤销                    board[i][j] = &#x27;.&#x27;                    rows[i].remove(ch)                    cols[j].remove(ch)                    boxes[i // 3][j // 3].remove(ch)            return False                backtrack(0)","categories":["Leetcode"],"tags":["backtrack"]},{"title":"【代码随想录】回溯6","url":"/blog/Leetcode/backtrack6/","content":"491.递增子序列\nlink\n\n给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。\n示例 1：\n\n输入：nums &#x3D; [4,6,7,7]输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]  \n\n思路注意这道题和 组合II 类似，但是不能对给定的数组进行排序，也就不能使用 used 数组来进行去重。所以使用 set 来进行去重。\n\n注意判断是否加入当前元素的条件有两个，只要满足其一就跳过\n\n当前元素小于 cur 的末尾元素（cur 不为空时）\n当前元素使用过（在 set 中）\n\nclass Solution:    def findSubsequences(self, nums: List[int]) -&gt; List[List[int]]:        res = []        cur = []                def backtrack(start):            if len(cur) &gt;= 2:                res.append(cur[:])            uset = set()            for i in range(start, len(nums)):                if (cur and nums[i] &lt; cur[-1]) or nums[i] in uset:                    continue                uset.add(nums[i])                cur.append(nums[i])                backtrack(i + 1)                cur.pop()                             backtrack(0)        return res\n\n332.重新安排行程\nlink\n\n给定一组机票 tickets &#x3D; [[“JFK”, “SFO”], [“JFK”, “ATL”], [“SFO”, “ATL”], …]；\n每张票只用一次；要求从 “JFK” 出发，找出按字典序最小的行程；输出一个行程列表，比如 [“JFK”, “ATL”, “JFK”, “SFO”, “ATL”, “SFO”]。\n思路首先需要把所有的机票存起来，使用 dict 来进行存储，然后当前的结果 cur 一定以 “JFK” 开头。递归三部曲：\n\n递归参数和返回值：如果找到一条路径，就返回 True，类似于解数独\n终止条件：遍历完所有的 ticket，同样类似于解数独\n核心逻辑：获取当前 cur 的末尾机场，然后遍历以当前末尾机场出发的 ticket，将当前 ticket 加入 cur，然后递归调用。\n\nfrom collections import defaultdictclass Solution:    def findItinerary(self, tickets: List[List[str]]) -&gt; List[str]:        graph = defaultdict(list)        for frm, to in tickets:            graph[frm].append(to)        # 按字典序排序所有出发机场的目的地列表        for frm in graph:            graph[frm].sort()        path = [&quot;JFK&quot;]  # 初始路径从 JFK 开始        ticket_count = len(tickets)        def backtrack():            if len(path) == ticket_count + 1:                return True  # 用完所有机票，路径合法            curr = path[-1]            for i in range(len(graph[curr])):                next_city = graph[curr][i]                if next_city == &quot;#&quot;:                    continue  # &quot;#&quot; 表示该机票已经用过了                # 标记使用                graph[curr][i] = &quot;#&quot;  # 临时替换掉                path.append(next_city)                if backtrack():                    return True                # 回溯撤销                path.pop()                graph[curr][i] = next_city  # 恢复机票            return False        backtrack()        return path\n\n注意：\n\n每张机票只能用一次，所以要标记用过\n按字典序排序邻接表来确保最小路径先被试出来\n起点必须是 “JFK”\t固定出发点\n回溯需恢复现场，恢复 cur 和机票使用状态\n\n目前回溯法会超时？？\n","categories":["Leetcode"],"tags":["backtrack"]},{"title":"【代码随想录】双指针法","url":"/blog/Leetcode/double-pointer/","content":"数组移除元素\n移除元素\n\n在数组中原地移除元素，使用双指针，一个指向遍历的位置，一个指向删除后数组的长度\n字符串反转字符串\n反转字符串\n\n两个指针分别从头和尾向中间遍历，相互交换字符\n替换数字\n替换数字\n\n类似于移除元素，两个指针分别代表替换后字符串的真实位置和遍历的位置。注意是从后往前填充。\n翻转字符串里的单词\n翻转字符串里的单词\n\n首先删除多余的空格（双指针法），然后：\n\n使用双指针法确定每一个单词，并进行反转 or \n将整个字符串反转，然后再将每个单词反转回来\n\n链表反转链表\n反转链表\n\n两个指针一前一后，交换节点 next 的指向。\n删除链表的倒数第N个节点\n删除链表的倒数第N个节点\n\n快指针先走 N 步，然后和慢指针一起走，快指针走到末尾，慢指针就指向倒数第 N 个节点。\n链表相交\n链表相交\n\n同样是快慢指针，先让快指针在长的链表上走两个链表的差值（目的是让两个链表尾端对齐），然后慢指针在短链表上和快指针一起走，直到找到相交点。\n环形链表II\n环形链表II\n\n快指针一次走两格，慢指针一次走一个，判断是否有环；如果有环，则让两个新指针分别从相遇点和起点出发，两个新指针相遇的点即为环的起点。\nN 数之和三数之和\n三数之和\n\n首先将数组进行排序，循环确定第一个数，然后两个指针分别确定后两个数，两个指针分别为剩下数组中最大和最小的数，然后两个指针分别靠近彼此。\n四数之和\n四数之和\n\n和三数之和类似，只不过多加了一层循环。\n总结除了链表一些题目一定要使用双指针，其他题目都是使用双指针来提高效率，一般是将O(n^2)的时间复杂度，降为 O(n) 。\n","categories":["Leetcode"],"tags":["array","list","hash","string"]},{"title":"【代码随想录】动态规划1-基础","url":"/blog/Leetcode/dp1/","content":"动态规划动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的。\n解题步骤：\n\n确定 dp 数组（dp table）以及下标的含义\n确定递推公式\ndp 数组如何初始化\n确定遍历顺序\n举例推导 dp 数组\n\n509. 斐波那契数\nlink斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) &#x3D; 0，F(1) &#x3D; 1， F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1。给你 n ，请计算 F(n) 。\n\n思路\n确定 dp 数组（dp table）以及下标的含义：第 i 个数的斐波那契数值是 dp[i]\n确定递推公式：题目中已经告知 dp[i] &#x3D; dp[i - 1] + dp[i - 2]\ndp 数组如何初始化：题目中也告知 dp[0] &#x3D; 0, dp[1] &#x3D; 1\n确定遍历顺序：从递归公式dp[i] &#x3D; dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的\n举例推导 dp 数组：\n\nclass Solution:    def fib(self, n: int) -&gt; int:        res = [0, 1]        for i in range(2, n + 1):            res.append(res[i - 1] + res[i - 2])                return res[n]\n\n70. 爬楼梯\nlink\n\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n思路\n确定 dp 数组（dp table）以及下标的含义：到达第 i 阶的走法为 dp[i]\n确定递推公式：可以定义为 dp[i] &#x3D; dp[i - 1] + dp[i - 2]（dp[i - 1] 走一步，dp[i - 2] 走两步）\ndp 数组如何初始化：第 0 阶不走，可以定义为 0（dp[0] &#x3D; 0）,第一阶只有 1 种走法（dp[1] &#x3D; 1），第二阶有 2 种（dp[2] &#x3D; 2）\n确定遍历顺序：从前往后\n举例推导 dp 数组：\n\nclass Solution:    def climbStairs(self, n: int) -&gt; int:        res = [0, 1, 2]        for i in range(3, n + 1):            res.append(res[i - 1] + res[i - 2])                return res[n]\n\n746. 使用最小花费爬楼梯\nlink给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。\n\n你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。\n思路\n确定 dp 数组（dp table）以及下标的含义：到达第 i 阶的最小花费\n确定递推公式：可以定义为 dp[i] &#x3D; min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])（dp[i - 1] 走一步，dp[i - 2] 走两步）\ndp 数组如何初始化：题目已经给出，可以从 0 或者 1 开始走，说明 dp[0] dp[1] 都是 0\n确定遍历顺序：从前往后\n举例推导 dp 数组：\n\nclass Solution:    def minCostClimbingStairs(self, cost: List[int]) -&gt; int:        res = 0        dp = [0, 0]        for i in range(2, len(cost) + 1):            dp.append(min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]))                return dp[len(cost)]\n\n62.不同路径\nlink\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n问总共有多少条不同的路径？\n思路\n确定 dp 数组（dp table）以及下标的含义：到达第 (i, j) 位置的方法数\n确定递推公式：可以定义为 dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1]，要么从左边来，要么从上面来。注意考虑边界情况\ndp 数组如何初始化：可以定义为 1，这样 dp[0][1] 和 dp[1][0] 就可以使用递推公式来计算了\n确定遍历顺序：从前往后\n举例推导 dp 数组：\n\nclass Solution:    def uniquePaths(self, m: int, n: int) -&gt; int:        dp = [[0] * n for _ in range(m)]        dp[0][0] = 1        for i in range(m):            for j in range(n):                # 第一行                if i == 0:                    if j != 0:                        dp[i][j] = dp[i][j - 1]                # 第一列                elif j == 0:                    if i != 0:                        dp[i][j] = dp[i - 1][j]                # 剩余情况                else:                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]                return dp[m - 1][n - 1]\n\n其实第一行（dp[0][:]）和第一列（dp[:][0]）只能为 1，所以可以从 1 开始遍历\n数论思路（高中数学 😂）一共需要 m - 1 个竖着走和 n - 1 个横着走，总共是 m + n - 2 个步骤。相当于是给 m + n - 2 个不同的数，随便取 m - 1 个数，有几种取法。\n63. 不同路径 II343. 整数拆分96.不同的二叉搜索树","categories":["Leetcode"],"tags":["dynamic programming"]},{"title":"【代码随想录】贪心算法3-贪心解决股票问题","url":"/blog/Leetcode/greedy3/","content":"122.买卖股票的最佳时机 II\nlink\n\n给定一个数组，它的第  i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\n示例：\n\n输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4。随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3。  \n\n思路贪心：\n\n局部：如果后一天的价格比今天的价格高，则今天买，明天卖（多次买卖，多赚钱）\n全局：总的赚的钱最多\n\n更合理的解释是：把利润分割为以天为单位，计算每天的利润，然后只在利润为正的时候买入和卖出。\n\n局部最优：收集每天的正利润\n全局最优：求得最大利润。\n\nclass Solution:    def maxProfit(self, prices: List[int]) -&gt; int:        val = 0        for i in range(0, len(prices) - 1):            if prices[i + 1] - prices[i] &gt; 0:                val += prices[i + 1] - prices[i]                return val\n\n714. 买卖股票的最佳时机含手续费见动态规划\n","categories":["Leetcode"],"tags":["greedy"]},{"title":"【代码随想录】贪心算法5-区间问题","url":"/blog/Leetcode/greedy5/","content":"55. 跳跃游戏\nlink\n\n给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。\n示例：\n\n输入: [2,3,1,1,4]输出: true解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。  \n\n思路贪心思想为，每一步都跳最远，然后考虑每个元素作为起点时，是否能跳到末尾，代码如下：\nclass Solution:    def canJump(self, nums: List[int]) -&gt; bool:        n = len(nums)        for i in range(n):            pos = i            while pos &lt; n:                if nums[pos] == 0 and pos != n - 1:                    break                if pos + nums[pos] &gt;= n - 1:                    return True                pos += nums[pos]  # 贪心跳到最远        return False\n\n但是无法处理 [3,2,1,0,4] 情况，因为外层的 for 循环会跳过 0 这个点，直接到最后。\n正确的思路为，遍历每一个点，记录能跳到的最远距离 cover。而只在 cover 这个范围中进行遍历（cover 动态更新）。如果某一步的 cover 大于终点，则返回 True。如果循环遍历完了，说明 cover 仍然小于终点，则返回 False。\n\n局部：每次都跳最远，记录能跳的最长距离\n全局：最后得到整体最大覆盖范围，看是否能到终点。\n\nclass Solution:    def canJump(self, nums: List[int]) -&gt; bool:        n = len(nums)        i = 0        cover = 0        while i &lt;= cover:            if cover &gt;= n - 1:                return True            cover = max(nums[i] + i, cover)            i += 1        return False\n\n本质上，第二段代码已经覆盖了第一段代码的流程。因为我们每次是在 cover 里面遍历，在 cover 中无论如何都能到达，所以就不需要遍历起点。\n45.跳跃游戏 II\nlink\n\n给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。每个元素 nums[i] 表示从索引 i 向后跳转的最大长度。返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。\n思路贪心的思路，局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最少步数。\n解题的时候，要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最少步数。需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖。\n注意这一题明确了一定可以跳到：\n\n首先在当前这一步的距离 cur 中遍历，找到下一步的最大范围 nex（cur 范围内只需要一个步骤就能跳到）\n如果遍历到了 cur 的末尾，说明当前步骤跳不到，则 res 加 1（表示跳到 nex 范围中），并将 nex 赋值给 cur\n如果 cur 已经超过终点，则直接返回。（贪心的点在于每次都是跳最远的）（注意要在赋值之后才判断）\n\nclass Solution:    def jump(self, nums: List[int]) -&gt; int:        cur = 0        nex = 0        res = 0        if len(nums) == 1:            return 0        for i in range(len(nums)):            nex = max(nums[i] + i, nex)            if i == cur:                res += 1                cur = nex                if cur &gt;= len(nums) - 1:                    return res\n\n452. 用最少数量的箭引爆气球\nlink\n\n在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。\n一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。\n给你一个数组 points ，其中 points [i] &#x3D; [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。\n示例：\n\n输入：points &#x3D; [[10,16],[2,8],[1,6],[7,12]]输出：2解释：气球可以用2支箭来爆破:在x &#x3D; 6处射出箭，击破气球[2,8]和[1,6]。在x &#x3D; 11处发射箭，击破气球[10,16]和[7,12]。  \n\n思路需要将气球进行排序，需要维护一个当前箭能覆盖到的最右位置（当前重叠区间的右边界）。\n如果当前气球的开始点大于最右边界，说明当前箭射不到这个气球；如果能满足，则需要更改最大右边界，为了解决 [1, 6] 和 [2, 4] 这种情况。类似于上面的 55. 跳跃游戏，虽然第一支箭最元能从 6 射出（贪心，射最远的点），第二个气球的起点在当前最大射程之内，即一定满足，需要更新最大射程为 4.（即最远能从 6 射，但是不一定从 6 射）\nclass Solution:    def findMinArrowShots(self, points: List[List[int]]) -&gt; int:        points.sort(key=lambda x: (x[0], x[1]))        res = 1        rightboder = points[0][1]        for i in points:            if i[0] &gt; rightboder:                res += 1                rightboder = i[1]            else:                rightboder = min(i[1], rightboder)        return res\n\n435. 无重叠区间\nlink\n\n给定一个区间的集合 intervals ，其中 intervals[i] &#x3D; [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。注意 只在一点上接触的区间是 不重叠的。例如 [1, 2] 和 [2, 3] 是不重叠的。\n思路将有重叠的区间视为一个整体，本质上是判断所有的区间可以分为几个“整体”。也就是说，每个整体中最多只能包含一个区间，多余的区间就要删除掉。本质上就类似与上一题 452. 用最少数量的箭引爆气球。箭的数量就代表有几个整体，总的数量减去箭的数量就代表要删除的数量。\n所以就是要维护一个最右边界：\n\n如果当前区间的左边界比当前最右边界小，说明重叠，然后更新最右边界。注意，为了将来有更多不重叠区间被保留，需要保留右边界更小的区间\n如果当前区间的左边界比当前最右边界大，说明没有重叠，“整体”的数量加一\n\n贪心的点在于：优先保留结束早的区间，以便为后续留出更多空间\nclass Solution:    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:        intervals.sort(key=lambda x: (x[0], x[1]))        count = 1        rightboder = intervals[0][1]        for i in intervals:            if i[0] &gt;= rightboder:                count += 1                rightboder = i[1]            else:                rightboder = min(rightboder, i[1])                return len(intervals) - count\n\n763.划分字母区间\nlink\n\n给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 “ababcc” 能够被分为 [“abab”, “cc”]，但类似 [“aba”, “bcc”] 或 [“ab”, “ab”, “cc”] 的划分是非法的。\n注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。返回一个表示每个字符串片段的长度的列表。\n思路 1题目要求同一字母最多出现在一个片段中，在遍历的过程中相当于是要找每一个字母的边界，如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了。此时前面出现过所有字母，最远也就到这个边界了。\n两个步骤：\n\n统计每一个字符最后出现的位置\n从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点\n\n\n注意当前的区间必须要覆盖到当前所有字符的最后一次出现位置，所以 right &#x3D; max(right, m[ch])。\nclass Solution:    def partitionLabels(self, s: str) -&gt; List[int]:        m = &#123;&#125;        for i, ch in enumerate(s):            m[ch] = i        res = []        right = 0        left = 0        for i, ch in enumerate(s):            right = max(right, m[ch])            if right == i:                res.append(right - left + 1)                left = i + 1        return res\n\n思路 2类似于前两题 452.用最少数量的箭引爆气球 和 435.无重叠区间，统计字符串中所有字符的起始和结束位置，记录这些区间（实际上也就是 435.无重叠区间 题目里的输入），将区间按左边界从小到大排序，找到边界将区间划分成组，互不重叠。找到的边界就是答案。\n本质上是要把有重叠的区间（说明对应的字符串要放在一起）合并。\nclass Solution:    def countLabels(self, s):        # 初始化一个长度为26的区间列表，初始值为负无穷        hash = [[float(&#x27;-inf&#x27;), float(&#x27;-inf&#x27;)] for _ in range(26)]        hash_filter = []        for i in range(len(s)):            if hash[ord(s[i]) - ord(&#x27;a&#x27;)][0] == float(&#x27;-inf&#x27;):                hash[ord(s[i]) - ord(&#x27;a&#x27;)][0] = i            hash[ord(s[i]) - ord(&#x27;a&#x27;)][1] = i        for i in range(len(hash)):            if hash[i][0] != float(&#x27;-inf&#x27;):                hash_filter.append(hash[i])        return hash_filter    def partitionLabels(self, s):        res = []        hash = self.countLabels(s)        hash.sort(key=lambda x: x[0])  # 按左边界从小到大排序        rightBoard = hash[0][1]  # 记录最大右边界        leftBoard = 0        for i in range(1, len(hash)):            if hash[i][0] &gt; rightBoard:  # 出现分割点                res.append(rightBoard - leftBoard + 1)                leftBoard = hash[i][0]            rightBoard = max(rightBoard, hash[i][1])        res.append(rightBoard - leftBoard + 1)  # 最右端        return res\n\n56. 合并区间\nlink\n\n以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。\n示例：\n\n输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]输出：[[1,6],[8,10],[15,18]]解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]\n\n思路类似于前几题，只不过判断出重叠后，需要合并区间。同样先对区间进行排序。\n\n注意这里先将第一个区间放到结果集合 res 中，然后每次遍历时都取当前结果 res 的最后一个区间来进行比较，如果 last[1] &gt; i[0]，说明当前有重叠，把最后的区间取出来，合并之后再放进去。\n注意合并区间时，其实只需要更改结束的点，因为最开始就进行了排序，前一个区间的起始点一定是最小的。\n\nclass Solution:    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:        intervals.sort(key=lambda x: x[0])        res = [intervals[0]]        start = 0        end = 0        for i in intervals:            last = res[-1]            if last[1] &gt;= i[0]:                res.pop()                # 其实只需要改区间的终点                res.append([min(last[0], i[0]), max(last[1], i[1])])            else:                res.append(i)        return res","categories":["Leetcode"],"tags":["greedy"]},{"title":"【代码随想录】贪心算法6","url":"/blog/Leetcode/greedy6/","content":"53. 最大子序和\nlink\n\n给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组是数组中的一个连续部分。\n思路局部最优：当前累加和是正的，就继续累加；否则重新开始。如果当前累加的子数组和 cur_sum 小于 0，那它对后面的结果毫无贡献，直接舍弃，从下一个元素重新开始。\n全局最优：过程中不断维护最大值。\n同时记得每添加一次都需要更新当前的最大值\nclass Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        cur = 0        maxi = float(&#x27;-inf&#x27;)        for i in nums:            cur += i            maxi = max(cur, maxi)            if cur &lt; 0:                cur = 0        return maxi\n134. 加油站\nlink\n\n在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。\n给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则保证它是唯一的。\n暴力两层循环，分别遍历起点和跑一圈，如果能重新到达起点，则说明当前起点满足条件。\n贪心如果总油量小于总消耗量，则说明无论如何都不能满足条件。然后从 0 开始遍历，记录从头开始的油箱剩余量（rest +&#x3D; gas[i] - cost[i]）。如果某个步骤 i 判断 rest 小于 0，则说明从当前起点 start 开始，最远只能跑到 i。此时把起点设置为 i+1，重新开始遍历。（只用遍历到末尾即可，因为上一步是从 0 开始，（等价于末尾），最远到 i，而第二步是从 i+1 开始遍历到末尾，（等价是 0），相当于跑了一圈）\n\n如果 tank &lt; 0，说明从起点走到当前 i 失败了：当前这一段不能作为起点。\n所以我们跳过它，从 i+1 开始重新尝试，把 tank 重置为 0。\n\n虽然某些起点不行，但我们只要跳过这些亏损段（tank&lt;0 的段），并且：\n\n总的供油是 ≥ 总耗油的\n那么在某个位置之后，盈余就能把之前的亏空补回来\n也就是说，之前亏了多少，后面就能“补回来”，最终一定可以绕一圈。\n\nclass Solution:    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -&gt; int:        if sum(gas) &lt; sum(cost):            return -1        cur = 0        start = 0        for i in range(len(gas)):            cur += gas[i] - cost[i]            if cur &lt; 0:                start = i + 1                cur = 0        return start\n\n\n968. 监控二叉树\nlink\n\n给定一个二叉树，我们在树的节点上安装摄像头。节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。计算监控树的所有节点所需的最小摄像头数量。\n\n思路核心：摄像头不能放在叶子节点上。摄像头可以覆盖上中下三层，如果把摄像头放在叶子节点上，就浪费的一层的覆盖。所以把摄像头放在叶子节点的父节点位置，才能充分利用摄像头的覆盖面积。\n局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少\n需要从下向上遍历，只有使用后序遍历。在遍历的过程中需要进行状态转移。定义三种状态：有如下三种：\n\n该节点无覆盖\n本节点有摄像头\n本节点有覆盖\n\n分别有三个数字来表示：\n\n0：该节点无覆盖\n1：本节点有摄像头\n2：本节点有覆盖\n\n递归三部曲：\n\n参数和返回值：需要返回当前节点的状态\n终止条件：遇到空就返回，注意空节点应该定义为有覆盖（2）（否则该叶子节点就需要放摄像头了）\n核心逻辑：\n左右都有覆盖（两个 2），当前节点就为无覆盖（0）\n至少一个孩子没有覆盖（至少一个 0），那就要放摄像头（1）\n至少一个孩子放了摄像头（至少一个 1），当前节点就有覆盖（2）\n\n\n\n注意上述顺序不能打乱，下面的情况应该是 1，而不是 2。\n\n此外，如果根节点没有覆盖，也需要放摄像头。\nclass Solution:    def minCameraCover(self, root: Optional[TreeNode]) -&gt; int:        res = [0]        def treverse(node):            if node == None:                return 2                        left = treverse(node.left)            right = treverse(node.right)            if left == 2 and right == 2:                return 0            if left == 0 or right == 0:                res[0] += 1                return 1                        if left == 1 or right == 1:                return 2                if treverse(root) == 0:            res[0] += 1        return res[0]","categories":["Leetcode"],"tags":["greedy"]},{"title":"【代码随想录】贪心算法1","url":"/blog/Leetcode/greedy1/","content":"理论基础贪心的本质是选择每一阶段的局部最优，从而达到全局最优。\n刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心。\n455. 分发饼干\nlink\n\n假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。\n对每个孩子 i，都有一个胃口值  g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\n示例：\n\n输入: g &#x3D; [1,2,3], s &#x3D; [1,1]输出: 1 解释:你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。所以你应该输出 1。  \n\n思路贪心体现为：优先让大尺寸的饼干满足大胃口的孩子\n这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩。\n只需要将两个数组排序，然后从大到小遍历即可。\nclass Solution:    def findContentChildren(self, g: List[int], s: List[int]) -&gt; int:        g.sort()        s.sort()        num = 0        sp = len(s) - 1        gp = len(g) - 1        while sp &gt;= 0 and gp &gt;= 0:            if s[sp] &gt;= g[gp]:                num += 1                sp -= 1                gp -= 1            else:                gp -= 1        return num\n\n1005.K次取反后最大化的数组和\nlink\n\n给你一个整数数组 nums 和一个整数 k ，选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。重复这个过程恰好 k 次。可以多次选择同一个下标 i 。以这种方式修改数组后，返回数组 可能的最大和。\n示例：\n\n输入：nums &#x3D; [4,2,3], k &#x3D; 1输出：5解释：选择下标 1 ，nums 变为 [4,-2,3] 。\n\n思路贪心思路：每次都选最小的值来反转（注意是在修改后的数组中找最小的），注意如果最小值为 0，则应该多次选 0。思路如下：\n\n将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小\n从前向后遍历，遇到负数将其变为正数，同时K–\n如果K还大于0，那么反复转变数值最小的元素，将K用完\n求和\n\nclass Solution:    def largestSumAfterKNegations(self, nums: List[int], k: int) -&gt; int:        nums.sort(key=lambda x: abs(x), reverse=True)        for i in range(len(nums)):  # 第二步：执行K次取反操作            if nums[i] &lt; 0 and k &gt; 0:                nums[i] *= -1                k -= 1        if k % 2 == 1:  # 第三步：如果K还有剩余次数，将绝对值最小的元素取反            nums[-1] *= -1        result = sum(nums)  # 第四步：计算数组A的元素和        return result\n\n注意 python 排序的写法。\n\nsort 方法的 key 参数表示排序时，不直接用列表元素本身来比较，而是先对每个元素应用一次 key 函数，然后用返回值来排序。\nlambda x: abs(x) 为一个匿名函数，表示接收一个参数 x，返回 x 的绝对值（abs(x)）。等价于：\n\ndef f(x):    return abs(x)\n\n所以也可以写成 nums.sort(key&#x3D;f)\n860.柠檬水找零\nlink\n\n在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。注意，一开始你手头没有任何零钱。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。\n示例：\n\n输入：bills &#x3D; [5,5,5,10,20]输出：true解释：前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。由于所有客户都得到了正确的找零，所以我们输出 true。  \n\n思路每次找钱的时候都计算当前的钱是否满足，感觉这段代码有点暴力的思想？如果钱的组合更复杂怎么办？\nclass Solution:    def lemonadeChange(self, bills: List[int]) -&gt; bool:        money = Counter()                for i in bills:            if i == 5:                money[5] += 1            elif i == 10:                if money[5] &gt;= 1:                    money[10] += 1                    money[5] -= 1                else:                    return False            else:                if money[10] &gt;= 1 and money[5] &gt;= 1:                    money[10] -= 1                    money[5] -= 1                elif money[5] &gt;= 3:                    money[5] -= 3                else:                    return False        return True\n正确理解：共有三种情况：\n\n情况一：账单是 5，直接收下。\n情况二：账单是 10，消耗一个 5，增加一个 10\n情况三：账单是 20，优先消耗一个 10 和一个 5，如果不够，再消耗三个 5\n\n情况三存在贪心思想，因为美元 10 只能给账单 20 找零，而美元 5 可以给账单 10 和账单 20 找零，美元 5 更万能。所以局部最优：遇到账单 20，优先消耗美元 10，完成本次找零。全局最优：完成全部账单的找零。\n","categories":["Leetcode"],"tags":["greedy"]},{"title":"【代码随想录】贪心算法2-序列问题","url":"/blog/Leetcode/greedy2/","content":"376. 摆动序列\nlink\n\n如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。\n\n例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。\n相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。\n\n给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。\n思路 1：贪心局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。\n整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。\n\n实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）。每一步都只关注当前是否能构成“拐点”（即构成一个有效的“摆动”），而不是枚举所有子序列进行动态规划选择。\n在计算是否有峰值的时候，通过遍历下标 i ，计算 prediff(nums[i] - nums[i-1]) 和 curdiff(nums[i+1] - nums[i])，如果 prediff &lt; 0 &amp;&amp; curdiff &gt; 0 或者 prediff &gt; 0 &amp;&amp; curdiff &lt; 0 此时就有波动就需要统计。\n需要注意以下两点：\n\n初始化：\n序列长度小于 2 时，无法计算元素差，所以直接返回序列长度\ncount 的初始值问题，如果前两个元素的差为 0，则 count 为 1（当前摆动序列只算一个数字）；否则为 2（前两个数字全部算入摆动序列中）\n\n\n条件判断：\npre &#x3D;&#x3D; 0 的情况，相当于前一对没有进行变化，如果此时的 cur !&#x3D; 0，则说明遇到了第一个波动，需要记录\n\n\n\n详细的案例分析见代码随想录\nclass Solution:    def wiggleMaxLength(self, nums: List[int]) -&gt; int:        if len(nums) &lt; 2:            return len(nums)                pre = nums[1] - nums[0]        if pre != 0:            count = 2        else:            count = 1        for i in range(1, len(nums) - 1):            cur = nums[i + 1] - nums[i]            if (cur &gt; 0 and pre &lt;= 0) or (cur &lt; 0 and pre &gt;= 0):                count += 1                pre = cur        return count \n\n738.单调递增的数字\nlink\n\n当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;&#x3D; y 时，我们称这个整数是单调递增的。给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。\n示例 1:\n\n输入: n &#x3D; 10输出: 9  \n\n示例 2:\n\n输入: n &#x3D; 1234输出: 1234  \n\n示例 3:\n\n输入: n &#x3D; 332输出: 299  \n\n思路例如：98，一旦出现 strNum[i - 1] &gt; strNum[i] 的情况（非单调递增），首先想让 strNum[i - 1]–，然后 strNum[i] 给为9，这样这个整数就是 89，即小于 98 的最大的单调递增整数。\n这样就只能从后往前遍历了。因为需要先确定大的数字。整体流程为：反向遍历，如果当前数字小于前一个，则前一位“借 1”，当前位置之后的所有数字都设置为 9\nclass Solution:    def monotoneIncreasingDigits(self, n: int) -&gt; int:        num = list(str(n))        for i in range(len(num) - 1, 0, -1):            if num[i] &lt; num[i - 1]:                num[i - 1] = str(int(num[i - 1]) - 1)                for j in range(i, len(num)):                    num[j] = &#x27;9&#x27;        return int(&#x27;&#x27;.join(num))\n\n","categories":["Leetcode"],"tags":["greedy"]},{"title":"【代码随想录】贪心算法4-两个维度权衡问题","url":"/blog/Leetcode/greedy4/","content":"135. 分发糖果\nlink\n\nn 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。\n你需要按照以下要求，给这些孩子分发糖果：每个孩子至少分配到 1 个糖果。相邻两个孩子评分更高的孩子会获得更多的糖果。请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。\n思路一个孩子的糖果数量要收到左右两边的限制，所以需要遍历两次。确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，如果两边一起考虑一定会顾此失彼。\n\n单向贪心只能考虑单侧的约束（即“当前孩子比左边&#x2F;右边大”）。\n但孩子可能同时比左边和右边大，因此必须双向分别处理每个方向的关系。\n两次遍历后，每个孩子的糖果数就是：满足所有约束条件的最小值。\n\n局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果（反向同理）。注意反向遍历时的赋值问题。\nclass Solution:    def candy(self, ratings: List[int]) -&gt; int:        res = [1] * len(ratings)        for i in range(1, len(ratings)):            if ratings[i] &gt; ratings[i - 1]:                res[i] = res[i - 1] + 1                    for i in range(len(ratings) - 2, -1, -1):            if ratings[i] &gt; ratings[i + 1]:                res[i] = max(res[i], res[i + 1] + 1)                    return sum(res)\n406.根据身高重建队列\nlink\n\n假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] &#x3D; [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。\n请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] &#x3D; [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。\n示例：\n\n输入：people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]解释：编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。\n\n思路有两个维度，h 和 k，看到这种题目一定要想如何确定一个维度，然后再按照另一个维度重新排列。\n首先按照 h 排序，身高一定是从大到小排（身高相同的话则 k 小的站前面），让高个子在前面。前面的节点一定都比当前节点高。\n按照身高排序之后，优先按身高高的 people 的 k 来插入，后序插入节点也不会影响前面已经插入的节点，最终按照 k 的规则完成了队列。\n\n\n局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性\n全局最优：最后都做完插入操作，整个队列满足题目队列属性\n\nclass Solution:    def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]:        people.sort(key=lambda x: (-x[0], x[1]))        res = []        for p in people:            res.insert(p[1], p)        return res\n\nsortkey 是一个函数，用于从每个元素中提取出用于排序的关键字。\n例子 1nums = [3, 12, -4, 6]nums.sort(key=abs)print(nums)  # 输出：[-4, 3, 6, 12]\n\nabs 是 Python 的内置函数，返回绝对值\n排序时比较的是每个元素的 abs(x) 值，而不是原始值本身\n\n例子 2按字符串长度排序\nwords = [&quot;apple&quot;, &quot;a&quot;, &quot;banana&quot;, &quot;pear&quot;]words.sort(key=len)print(words)  # 输出：[&#x27;a&#x27;, &#x27;pear&#x27;, &#x27;apple&#x27;, &#x27;banana&#x27;]\n\n例子 3排序二维数组\narr = [[7, 0], [4, 4], [7, 1], [5, 0]]arr.sort(key=lambda x: (x[0], x[1]))print(arr)  # 输出：[[4, 4], [5, 0], [7, 0], [7, 1]]\n\nkey&#x3D;lambda x: (x[0], x[1]) 表示先按第一个元素排，再按第二个元素排\nlambda 将列表的每一个元素都构造为一个元组。即使用元组排序的规则：先比第一个，不同就确定；相同就比第二个\n\n例子 4people = [[7,0],[4,4],[7,1],[5,0]]people.sort(key=lambda x: (-x[0], x[1]))\n\n-x[0]：表示身高从高到低排序\nx[1]：当身高相同时，按 k 值从小到大排序\n\n例子 5对比 people.sort(key&#x3D;lambda x: (x[0], x[1]), reverse&#x3D;True) 和 people.sort(key&#x3D;lambda x: (-x[0], x[1]))。\n\npeople.sort(key&#x3D;lambda x: (-x[0], x[1]))：\n第一关键字：-x[0] → 按身高从大到小\n第二关键字：x[1] → 同身高时，k 值从小到大\n\n\npeople.sort(key&#x3D;lambda x: (x[0], x[1]), reverse&#x3D;True)\n先按 x[0] 升序、再按 x[1] 升序，然后整体结果翻转成降序。\n结果是身高和 k 都是降序。\n\n\n\n","categories":["Leetcode"],"tags":["greedy"]},{"title":"【代码随想录】哈希表1","url":"/blog/Leetcode/hash1/","content":"Python 哈希表相关操作哈希表都是用来快速判断一个元素是否出现集合里。例如要查询一个名字是否在这所学校里。要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。\nlistdictdefaultdict 和 Counter这两个类都是 dict 的子类，在 key 不存在时，dict 会报错。但是这两个类定义了 __missing__() 方法，在 key 不存在时，会调用该方法并返回其值。例如，Counter 类的定义如下，即 key 不存在的话就返回 0，满足计数器的要求。\nclass Counter(dict):    def __missing__(self, key):        return 0\n\ndefaultdict 则会返回初始化时给定的类型。例如：\nd = defaultdict(int)d = defaultdict(list)\n\n使用 dict 也可以实现 Counter 类似的效果：\nd = dict()d[key] = d.get(key, 0) + 1\n\n\nset集合中的元素不可重复，可以遍历，但不能使用索引来访问。\n添加元素：add()\n删除元素：remove()\n242. 有效的字母异位词\n题目链接 link\n\n给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的 字母异位词。\n示例 1:\n\n输入: s &#x3D; “anagram”, t &#x3D; “nagaram”输出: true  \n\n示例 2:\n\n输入: s &#x3D; “rat”, t &#x3D; “car”输出: false  \n\n思路分别记录两个字符串中各个字符的数量，然后判断是否相等。\n数组写法使用相对的 ASCII 来作为索引。这里使用了 ord 方法，用于将字符转换为数字。\nclass Solution:    def isAnagram(self, s: str, t: str) -&gt; bool:        s_list = [0 for _ in range(26)]        for i in s:            index = ord(i) - ord(&#x27;a&#x27;)            s_list[index] += 1                for i in t:            index = ord(i) - ord(&#x27;a&#x27;)            s_list[index] -= 1                for i in s_list:            if i != 0:                return False                return True\n\n字典写法注意需要使用 get(i, 0) 方法，如果没有对应的键值，则返回 0。\nclass Solution:    def isAnagram(self, s: str, t: str) -&gt; bool:        record = &#123;&#125;        for i in s:            record[i] = record.get(i, 0) + 1                for i in t:            record[i] = record.get(i, 0) - 1                for i in record:            if record[i] != 0:                return False                return True\n\nCounter 写法可以直接比较两个 Counter（计数器 dict）\nclass Solution:    def isAnagram(self, s: str, t: str) -&gt; bool:        record_s = Counter()        record_t = Counter()        for i in s:            record_s[i] += 1                for i in t:            record_t[i] += 1                if record_s == record_t:            return True        else:            return False\n\n49. 字母异位词分组\n题目链接 link\n\n给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n示例 1:\n\n输入: strs &#x3D; [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]解释：在 strs 中没有字符串可以通过重新排列来形成 “bat”。字符串 “nat” 和 “tan” 是字母异位词，因为它们可以重新排列以形成彼此。字符串 “ate” ，”eat” 和 “tea” 是字母异位词，因为它们可以重新排列以形成彼此。  \n\n思路 1遍历所有的字符串，判断该字符串是否和已经分好组的字符串为字母异位词，如果是，则添加到满足的那个组，如果不是则单独添加为一个组。但是这段代码会超出时间限制。\nclass Solution:    def judge(self, s, t):        record_s = Counter()        record_t = Counter()        for i in s:            record_s[i] += 1                for i in t:            record_t[i] += 1                if record_s == record_t:            return True        else:            return False    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        res = []        for s in strs:            if len(res) == 0:                res.append([s])            else:                flag = False                for index in range(len(res)):                    if self.judge(s, res[index][0]):                        res[index].append(s)                        flag = True                        break                if flag == False:                    res.append([s])                return res\n\n思路 2思路 1 的时间复杂度为 O(n*n*n)，优化的点在于判断是否为字母异位词时，可以将字符串进行排序，将排序后的字符串作为 key，将对应的字符串存在一个 list 中 作为 value。这里需要用到 defaultdict。当访问一个不存在的键时，defaultdict 会自动调用 default_factory 生成一个默认值并插入字典，然后返回这个值。\n这里使用了 sorted 方法，可以将任意可迭代的对象进行排序，返回一个 list。\nclass Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        d = defaultdict(list)        for s in strs:            key = &quot;&quot;.join(sorted(s))            d[key].append(s)                return list(d.values())\n\n438. 找到字符串中所有字母异位词\nlink\n\n给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n示例 1:\n\n输入: s &#x3D; “cbaebabacd”, p &#x3D; “abc”输出: [0,6]解释:起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。  \n\n思路滑动窗口，对于每一个字串都进行判断。有如下优化：\n\n如果当前字串是字母异位词，则只需要比较当前窗口出去的字符和进来的字符是否相等，如果相等则下一个字串也为字母异位词。\n判断字母异位词直接使用排序，时间复杂度为 O(klogk)，否则为\n\nclass Solution:    def judge(self, s, t):        ss = &quot;&quot;.join(sorted(s))        tt = &quot;&quot;.join(sorted(t))        if ss == tt:            return True        else:            return False          def findAnagrams(self, s: str, p: str) -&gt; List[int]:        res = []        pre = None        for start in range(len(s) - len(p) + 1):            end = start + len(p)            if pre == None:                if self.judge(s[start:end], p):                    res.append(start)                    pre = s[start]            else:                if pre == s[end - 1]:                    res.append(start)                    pre = s[start]                else:                    pre = None        return res\n\n思路 2对于每个字串，不用每次都进行判断，只需要记录每个字符的数量以及其变化情况即可。\n","categories":["Leetcode"],"tags":["hash"]},{"title":"【代码随想录】哈希表2","url":"/blog/Leetcode/hash2/","content":"349. 两个数组的交集\n题目链接 link\n\n给定两个数组 nums1 和 nums2 ，返回 它们的 交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。\n思路 1将两个 list 转换为 set（确保一个数字在一个 list 中只存在一次），然后分别进行遍历，统计所有数字出现的次数，出现次数为 2 的即为交集。本质上是用 dict 作为哈希表。\nclass Solution:    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:        c = Counter()        res = []        for i in set(nums1):            c[i] += 1                for i in set(nums2):            c[i] += 1                for key in c:            if c[key] &gt; 1:                res.append(key)        return res\n\n思路 2一步到位，直接使用 set 的 &amp; 操作符来计算交集。\nclass Solution:    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:        return list(set(nums1) &amp; set(nums2))\n\n350. 两个数组的交集 II\n题目链接 link\n\n给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。\n示例 1：\n\n输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]输出：[2,2]  \n\n示例 2:\n\n输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]输出：[4,9]\n\n思路用 dict 来记录两个 list 中数字的数量，然后判断重叠部分的数量。\nclass Solution:    def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:        c1 = Counter()        c2 = Counter()        for i in nums1:            c1[i] += 1                for i in nums2:            c2[i] += 1        res = []        for key in c1:            if c1[key] &gt; 0 and c2[key] &gt; 0:                for i in range(min(c1[key], c2[key])):                    res.append(key)        return res        &#x27;\n\n202. 快乐数\nlink\n\n编写一个算法来判断一个数 n 是不是快乐数。\n「快乐数」 定义为：\n对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果这个过程 结果为 1，那么这个数就是快乐数。\n思路用一个 set 记录出现过的结果，如果出现过了该结果，则说明不是快乐数\nclass Solution:    def isHappy(self, n: int) -&gt; bool:        s = 0        l = set()        while s != 1:            s = 0            while n != 0:                temp = n % 10                s += temp * temp                n = n // 10                        if s in l:                return False            else:                if s == 1:                    return True                l.add(s)                n = s\n\n注意，虽然 set 和 list 都是用 in 来判断是否存在，但是其复杂度差很多：\n1. 两数之和\nlink\n\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n你可以按任意顺序返回答案。\n示例 1：\n\n输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。  \n\n思路本质上是查找，所以可以使用 set 进行查找，但是又需要返回下标，所以使用 dict 作为哈希表。使用 nums 中的值作为 key，使用下标作为 value。可以写出以下代码：\nclass Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        d = dict()        for i in range(len(nums)):            d[nums[i]] = i        for i in range(len(nums)):            if target - nums[i] in d:                return [i, d[target - nums[i]]]\n\n乍一看没问题，但是，题目要求不能使用两个相同的数，例如输入 nums&#x3D;[3, 2, 4]，target&#x3D;6 时，上述代码会返回 [0, 0]。问题在于我们先把所有的数都存入哈希表了，这样查询 3 的时候就会直接返回，而不会再去查询 2。事实上不需要将所有的数都预先存到哈希表中，这是因为即使遍历到 2，此时 4 还没有加入哈希表，但是遍历到 4 时，2 已经加入了，所以一定会找到答案。（题目中也暗示可以按照任意顺序返回答案）\nclass Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        d = dict()        for i in range(len(nums)):            if target - nums[i] in d:                return [i, d[target - nums[i]]]            d[nums[i]] = i\n\n对比：\n\nlist 的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。\nset 是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用\n\n454. 四数相加 II\nlink\n\n给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：\n0 &lt;&#x3D; i, j, k, l &lt; nnums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0\n示例 1：\n\n输入：nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]输出：2解释：两个元组如下： (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0 (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0  \n\n思路数组两两配对相加，分别计算出可能的和，然后就退化成两数之和。注意两个数组的和可能又多种可能，所以需要使用使用 Counter 作为哈希表。\nclass Solution:    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -&gt; int:        sum1 = Counter()        sum2 = Counter()        for i in nums1:            for j in nums2:                sum1[i + j] += 1                for i in nums3:            for j in nums4:                sum2[i + j] += 1        res = 0        for i in sum1:            if 0 - i in sum2:                res += sum2[0 - i]                return res","categories":["Leetcode"],"tags":["hash"]},{"title":"【代码随想录】哈希表2","url":"/blog/Leetcode/hash3/","content":"383. 赎金信\nlink\n\n给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。\n如果可以，返回 true ；否则返回 false 。\nmagazine 中的每个字符只能在 ransomNote 中使用一次。\n思路统计 magazine 和 ransomNote 中的字符数量，然后再判断大小（直接比较 Counter）。\nclass Solution:    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:        cm = Counter()        cr = Counter()        for i in magazine:            cm[i] += 1        for i in ransomNote:            cr[i] += 1                if cm &gt;= cr:            return True        else:            return False\n\n15. 三数之和\nlink\n\n给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请你返回所有和为 0 且不重复的三元组。\n注意：答案中不可以包含重复的三元组。\n示例 1：\n\n输入：nums &#x3D; [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 。nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 。nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。\n\n思路本题无法使用三重循环。因为如果所有的数都为 0，则需要需要大量去重。\n「不重复」的本质是什么？我们保持三重循环的大框架不变，只需要保证：\n\n第二重循环枚举到的元素不小于当前第一重循环枚举到的元素； \n第三重循环枚举到的元素不小于当前第二重循环枚举到的元素。\n\n也就是说，我们枚举的三元组 (a,b,c) 满足 a≤b≤c，保证了只有 (a,b,c) 这个顺序会被枚举到，而 (b,a,c)、(c,b,a) 等等这些不会，这样就减少了重复。同时，对于每一重循环而言，相邻两次枚举的元素不能相同，否则也会造成重复。\n但是上述方法仍为三重循环。如果我们固定了前两重循环枚举到的元素 a 和 b，那么只有唯一的 c 满足 a+b+c&#x3D;0。当第二重循环往后枚举一个元素 b’ 时，由于 b’&gt;b，那么满足 a+b’+c’&#x3D;0 的 c’ 一定有 c’&lt;c，即在数组中一定出现在 c 的左侧。也就是说，我们可以从小到大枚举 b，同时从大到小枚举 c，即第二重循环和第三重循环实际上是并列的关系。故枚举 b 为左指针，枚举 c 为右指针。\nfrom typing import Listclass Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        nums.sort()        res = []        for i in range(len(nums)):            if i &gt; 0 and nums[i] == nums[i - 1]:  # 跳过重复a                continue            left, right = i + 1, len(nums) - 1            while left &lt; right:                total = nums[i] + nums[left] + nums[right]                if total == 0:                    res.append([nums[i], nums[left], nums[right]])                    left += 1                    right -= 1                    # 跳过重复b                    while left &lt; right and nums[left] == nums[left - 1]:                        left += 1                    # 跳过重复c                    while left &lt; right and nums[right] == nums[right + 1]:                        right -= 1                elif total &lt; 0:                    left += 1                else:                    right -= 1        return res\n\n思考两数之和 能不能用双指针法呢？\n\n两数之和不能使用双指针法，因为1.两数之和 (opens new window)要求返回的是索引下标， 而双指针法一定要排序，一旦排序之后原数组的索引就被改变了。\n如果1.两数之和 (opens new window)要求返回的是数值的话，就可以使用双指针法了\n18. 四数之和\nlink\n\n给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：\n0 &lt;&#x3D; a, b, c, d &lt; na、b、c 和 d 互不相同nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target你可以按 任意顺序 返回答案 。\n思路类似于三数之和，同样是使用双指针法减少一层循环。\nclass Solution:    def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]:        nums.sort()        res = []        for i in range(len(nums)):            if i &gt; 0 and nums[i] == nums[i-1]:                continue            for j in range(i + 1, len(nums)):                if j &gt; i + 1 and nums[j] == nums[j - 1]:                    continue                                left, right = j + 1, len(nums) - 1                while left &lt; right:                    total = nums[i] + nums[j] + nums[left] + nums[right]                    if total == target:                        res.append([nums[i], nums[j], nums[left], nums[right]])                        left += 1                        right -= 1                        while left &lt; right and nums[left] == nums[left - 1]:                            left += 1                                                while left &lt; right and nums[right] == nums[right + 1]:                            right -= 1                                        elif total &lt; target:                        left += 1                    else:                        right -= 1        return res","categories":["Leetcode"],"tags":["hash"]},{"title":"【代码随想录】单调栈","url":"/blog/Leetcode/monotonic-stack/","content":"739. 每日温度\nlink\n\n请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n例如，给定一个列表 temperatures &#x3D; [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。\n思路使用单调栈的时机：通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。时间复杂度为 O(n)。\n\n单调栈的本质是空间换时间，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。\n更直白来说，就是用一个栈来记录我们遍历过的元素，因为我们遍历数组的时候，我们不知道之前都遍历了哪些元素，以至于遍历一个元素找不到是不是之前遍历过一个更小的，所以我们需要用一个容器（这里用单调栈）来记录我们遍历过的元素。\n\n核心点：\n\n单调栈里存放的元素是什么？单调栈里只需要存放元素的下标 i 就可以了，如果需要使用对应的元素，直接 T[i] 就可以获取。\n单调栈里元素是递增呢？ 还是递减呢？顺序的描述为从栈头到栈底的顺序，这里要使用递增循序，因为只有递增的时候，栈里要加入一个元素 i 的时候，才知道栈顶元素在数组中右面第一个比栈顶元素大的元素是 i。\n\n单调栈满足：\n\n栈中存的是“还没找到更高温度的那些天”，即：这些天还在等更暖的一天。当发现某天比他们“暖”，就将他们移出栈，并更新它们的等待时间。\n栈保持的是“温度单调递减”，因为只有温度递减才会出现“等待更暖的天”。\n\nclass Solution:    def dailyTemperatures(self, temperatures: List[int]) -&gt; List[int]:        stack = []        res = [0] * len(temperatures)        for i in range(0, len(temperatures)):            while len(stack) &gt; 0:                if temperatures[stack[-1]] &lt; temperatures[i]:                    res[stack[-1]] = i - stack[-1]                    stack.pop()                else:                    break                        stack.append(i)        return res\n以上代码为精简版，即如果栈不为空，就一直比较：\n\n如果当前元素比栈底元素大，说明找到了第一个大于当前元素的元素，就可以更新结果。为了保证栈的递增性，就要把当前元素移出，然后再循环判断\n如果当前元素比栈底元素小，说明当前元素不满足要求，跳出循环\n最后在 while 循环外将当前元素添加到栈中（无论如何都需要添加）\n\n496.下一个更大元素 I\nlink\n\n给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。\n思路类似于上一题，首先针对 nums2 中的每一个元素，在其右边找到第一个大于当前元素的元素 存放在 res 中，如果找不到就存 -1（默认值为 -1）。然后对于 nums1 中的每一个元素，先在 nums2 中找到下标，然后将 res 中对应下标的值存到新的 res 中。\nclass Solution:    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:        res = [-1] * len(nums2)        stack = []        for i in range(len(nums2)):            while len(stack) &gt; 0:                if nums2[stack[-1]] &lt; nums2[i]:                    res[stack[-1]] = nums2[i]                    stack.pop()                else:                    break                            stack.append(i)                new_res = []        # 也可以使用哈希表来存储        for i in nums1:            cur = res[nums2.index(i)]            new_res.append(cur)        return new_res\n\n503. 下一个更大元素 II\nlink\n\n给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。\n思路要处理循环数组，可以遍历当前数组两次来模拟（相当于是把两个相同的数组拼在一起）。每次处理下标是，都需要取余操作。\nclass Solution:    def nextGreaterElements(self, nums: List[int]) -&gt; List[int]:        stack = []        n = len(nums)        res = [-1] * n        for i in range(n * 2):            while len(stack) &gt; 0:                cur = stack[-1]                if nums[cur % n] &lt; nums[i % n]:                    res[cur % n] = nums[i % n]                    stack.pop()                else:                    break                        stack.append(i)                return res\n\n42. 接雨水\nlink\n\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n示例：\n\n\n输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]输出：6解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。   \n\n思路 1核心点：每一根柱子上方能接多少水，取决于：它左边最高的柱子 和 右边最高的柱子 的较小值，减去自己的高度，即 water[i] &#x3D; min(max_left[i], max_right[i]) - height[i]\n所以先正向和反向都遍历一遍，找到当前柱子左右两边的最大值，然后通过上述公式计算即可。\nclass Solution:    def trap(self, height: List[int]) -&gt; int:        n = len(height)        if n == 0:            return 0                max_left = [0] * n        max_right = [0] * n        # 从左向右预处理左侧最大高度        max_left[0] = height[0]        for i in range(1, n):            max_left[i] = max(max_left[i - 1], height[i])        # 从右向左预处理右侧最大高度        max_right[n - 1] = height[n - 1]        for i in range(n - 2, -1, -1):            max_right[i] = max(max_right[i + 1], height[i])        # 计算每个柱子上方可接雨水量        total_water = 0        for i in range(n):            water = min(max_left[i], max_right[i]) - height[i]            if water &gt; 0:                total_water += water        return total_water\n\n这种方法是按列来进行计算的。\n\n思路 2使用一个单调递减栈（存的是下标）来找出：\n\n当前柱子是否可以构成一个“接水凹槽”\n如果可以，我们就计算凹槽中间那一段的接水量\n\n每次遇到更高的柱子，就回头找左边有没有柱子能形成一对“墙”。\n假设当前遍历到下标 i，高度为 height[i]：\n\n如果 栈为空 或 当前高度 &lt;&#x3D; 栈顶高度：\n入栈（表示还没形成接水凹槽）。\n\n\n如果 当前高度 &gt; 栈顶高度：\n说明可能形成“接水凹槽”，开始出栈并计算。\n\n\n每次出栈后：\n栈顶是 凹槽的左墙\n当前是 右墙\n被出栈的那个柱子是 底部\n\n\n水的计算方式：\n高度 &#x3D; min(左墙高度, 右墙高度) - 底部高度\n宽度 &#x3D; 右墙索引 - 左墙索引 - 1\n水量 &#x3D; 高度 × 宽度\n\n\n\nclass Solution:    def trap(self, height: List[int]) -&gt; int:        stack = []        water = 0        for i in range(len(height)):                        while stack:                if height[stack[-1]] &lt; height[i]:                    last = stack.pop()                    # 注意底部出栈后，可能没有左墙，则需要跳出当前循环                    if not stack:                        break                                        w = i - stack[-1] - 1                    # last 是底部，i 是右墙，stack[-1] 是左墙                    h = min(height[stack[-1]], height[i]) - height[last]                    water += h * w                else:                    break            stack.append(i)                return water\n\n这种方法是按行来计算的：\n\n84.柱状图中最大的矩形\nlink\n\n给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。\n示例 1：\n\n\n输入：heights &#x3D; [2,1,5,6,2,3]输出：10解释：最大的矩形为图中红色区域，面积为 10  \n\n示例 2：\n\n\n输入： heights &#x3D; [2,4]输出： 4  \n\n思路 1目标： 找出每个柱子向左和向右能延伸的最大范围，即为当前柱子能构成的最大矩形。使用单调栈，只不过从栈头到栈尾是递增的。\n\n当前柱子高度 比栈顶高 → 继续入栈（栈保持递增）\n当前柱子高度 比栈顶低 → 出栈，并计算以该柱子（出栈的那个柱子）为高的最大矩形\n矩形的高：当前出栈的柱子\n矩形宽的起点：出栈之后的栈顶\n矩形宽的终点：当前 i\n注意，如果出栈的柱子下标和当前 i 不相邻，则说明之前一定有一个（或多个）更高的柱子出栈过，此时就是跨柱子框选矩形的情况了。\n\n\n\nclass Solution:    def largestRectangleArea(self, heights: List[int]) -&gt; int:        size = 0        heights = [0] + heights + [0]        stack = []        for i in range(len(heights)):            while stack:                if heights[stack[-1]] &gt; heights[i]:                    last = stack.pop()                    w = i - stack[-1] - 1                    h = heights[last]                    cur = h * w                    size = max(cur, size)                else:                    break                        stack.append(i)        return size\n\n注意，这里需要在 heights 的左右各添加一个哨兵 0，用于处理边界的情况。对比 接雨水 和本题：\n\n\n柱状图最大矩形 需要哨兵：\n\n本质：每根柱子都可能是最大矩形的“最矮墙”\n所以每根柱子都要参与处理\n但单调栈不会主动处理栈中剩下的元素，必须手动“清栈”\n加个尾部哨兵 0 会自动触发清栈逻辑，不需要额外代码\n\n\n接雨水 不需要哨兵：\n\n本质：只在 当前柱子比栈顶高 时才处理接水逻辑\n不满足条件（右墙不高）就跳过\n到最后一根柱子后，也不需要强制处理栈里剩下的柱子\n因为没有右墙就不会装水\n\n\n\n思路 2同样，本题也可以类似于 接雨水，对每个柱子，找到左右两边第一个小于当前柱子的柱子。然后构建的矩形的高为当前柱子，，宽度是能延伸到左右两边第一个比它小的柱子之间的范围。\nclass Solution:    def largestRectangleArea(self, heights: List[int]) -&gt; int:        n = len(heights)        left = [-1] * n      # 左边第一个比它小的位置        right = [n] * n      # 右边第一个比它小的位置        stack = []        # 计算 left[]        for i in range(n):            while stack and heights[stack[-1]] &gt;= heights[i]:                stack.pop()            left[i] = stack[-1] if stack else -1            stack.append(i)        stack.clear()        # 计算 right[]        for i in reversed(range(n)):            while stack and heights[stack[-1]] &gt;= heights[i]:                stack.pop()            right[i] = stack[-1] if stack else n            stack.append(i)        # 枚举每个柱子作为矩形的“最矮边”        max_area = 0        for i in range(n):            width = right[i] - left[i] - 1            area = heights[i] * width            max_area = max(max_area, area)        return max_area\n","categories":["Leetcode"],"tags":["stack"]},{"title":"【代码随想录】链表2","url":"/blog/Leetcode/list2/","content":"206.反转链表\n题目链接 link\n\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n双指针（迭代）只需要改变链表的next指针的指向，直接将链表反转，而不用重新定义一个新的链表。\nclass Solution:    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        if head == None or head.next == None:            return head        pre = head        cur = head.next        head.next = None        while cur != None:            temp = cur.next            cur.next = pre            pre = cur            cur = temp                return pre\n以上代码单独考虑了特殊情况，实际上可以写在一起，直接将 pre 设置为 None，cur 设置为 head 即可。\n递归法本质上是多次完成以下任务：将当前 cur.next 赋值为 pre，然后移动 cur 和 pre。可以使用递归的方法，写一个函数来多次完成上述过程。\nclass Solution:    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        pre = None        cur = head        return self.reserve(pre, cur)    def reserve(self, pre, cur):        if cur == None:            return pre                temp = cur.next        cur.next = pre        pre = cur        cur = temp        return self.reserve(pre, cur)\n\n24. 两两交换链表中的节点\n题目链接 link\n\n给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n迭代法设置一个虚拟头节点，然后进行两两交换。\nclass Solution:    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        if head == None or head.next == None:            return head                dummy_head = ListNode(0, head)        pre = dummy_head        cur1 = head        cur2 = head.next        while True:            lat = cur2.next            cur2.next = cur1            cur1.next = lat            pre.next = cur2            if lat != None and lat.next != None:                pre = cur1                cur1 = lat                cur2 = lat.next                            else:                return dummy_head.next\n\n19.删除链表的倒数第N个节点\n题目链接 link\n\n给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n思路 1直观方法，先遍历一遍，获取链表的长度，然后再遍历删除。\nclass Solution:    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:        dummy_head = ListNode(0, head)        length = 0        cur = dummy_head.next        while cur != None:            length += 1            cur = cur.next        i = 0        cur = dummy_head.next        pre = dummy_head        while i &lt; length - n:            cur = cur.next            pre = pre.next            i += 1                pre.next = cur.next        return dummy_head.next\n\n思路 2要求只遍历一遍链表：双指针的典型应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。（假设链表长度为 l，fast 移动了 l，slow 移动了 l - n,）\nclass Solution:    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:        dummy_head = ListNode(0, head)        fast = dummy_head.next        slow = dummy_head.next        pre = dummy_head        i = 0        while fast != None:            if i &lt; n:                i += 1            else:                slow = slow.next                pre = pre.next            fast = fast.next                pre.next = slow.next        return dummy_head.next\n\n面试题 02.07. 链表相交\n题目链接 link\n\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\n示例：\n输入两个 list，返回两个 list 相交的节点。\n思路如果两个 list 有相交的部分，那么一定在 list 的后半部分（尾部对齐）。那么可以使用快慢指针，首先遍历两个 list 的长度，找到其长度差 dif，让 fast 指针在长的 list 上先移动 dif，然后两个指针再一起移动。\nclass Solution:    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:        cur1 = headA        cur2 = headB        len1 = 0        len2 = 0        while cur1 != None:            len1 += 1            cur1 = cur1.next        while cur2 != None:            len2 += 1            cur2 = cur2.next                dif = abs(len2 -len1)        if len2 &gt; len1:            fast = headB            slow = headA        else:            fast = headA            slow = headB        for i in range(dif):            fast = fast.next                while fast != None:            if fast == slow:                return fast                        fast = fast.next            slow = slow.next                return None","categories":["Leetcode"],"tags":["list"]},{"title":"【代码随想录】栈和队列1-基础理论","url":"/blog/Leetcode/stack-queue1/","content":"基础知识队列是先进先出，栈是先进后出\n\n栈提供 push 和 pop 等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是 set 或者 map 提供迭代器 iterator 来遍历所有元素。\n栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。\n\n232.用栈实现队列\nlink\n\n使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n实现 MyQueue 类：\n\nvoid push(int x) 将元素 x 推到队列的末尾int pop() 从队列的开头移除并返回元素int peek() 返回队列开头的元素boolean empty() 如果队列为空，返回 true ；否则，返回 false\n\n说明：\n只能使用标准的栈操作 —— 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n思路使用栈来模拟队列的行为，如果仅仅用一个栈，是一定不行的，所以需要两个栈一个输入栈，一个输出栈，这里要注意输入栈和输出栈的关系。\nclass MyQueue:    def __init__(self):        self.in_stack = []        self.out_stack = []    def push(self, x: int) -&gt; None:        self.in_stack.append(x)    def pop(self) -&gt; int:        if len(self.out_stack) == 0:            for i in range(len(self.in_stack)-1, -1, -1):                self.out_stack.append(self.in_stack[i])                self.in_stack.pop(i)        return self.out_stack.pop()                def peek(self) -&gt; int:        if len(self.out_stack) == 0:            for i in range(len(self.in_stack)-1, -1, -1):                self.out_stack.append(self.in_stack[i])                self.in_stack.pop(i)        return self.out_stack[-1]            def empty(self) -&gt; bool:        if len(self.in_stack) == 0 and len(self.out_stack) == 0:            return True        else:            return False        # Your MyQueue object will be instantiated and called as such:# obj = MyQueue()# obj.push(x)# param_2 = obj.pop()# param_3 = obj.peek()# param_4 = obj.empty()\n\n注意 list 的 pop 方法，默认是返回并移除最后的元素，如果给一个参数则返回并删除指定 index 位置的元素。而 list 的 remove 方法是删除第一次遇到的指定元素。\n225. 用队列实现栈\nlink\n\n使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。\n实现 MyStack 类：\nvoid push(int x) 将元素 x 压入栈顶。int pop() 移除并返回栈顶元素。int top() 返回栈顶元素。boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。\n注意：\n你只能使用队列的标准操作 —— 也就是 push to back、peek&#x2F;pop from front、size 和 is empty 这些操作。你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\n思路使用一个队列。在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。\nPython 中的双端队列为 from collections import deque，常用方法如下：\n\n把双端队列当成普通队列来使用，只需要用 append(x) 和  popleft() 即可。\nclass MyStack:    def __init__(self):        self.queue = deque()    def push(self, x: int) -&gt; None:        self.queue.append(x)    def pop(self) -&gt; int:        for _ in range(len(self.queue)-1):            temp = self.queue.popleft()            self.queue.append(temp)                return self.queue.popleft()            def top(self) -&gt; int:        for _ in range(len(self.queue)-1):            temp = self.queue.popleft()            self.queue.append(temp)                temp = self.queue.popleft()        self.queue.append(temp)        return temp         def empty(self) -&gt; bool:        if len(self.queue) == 0:            return True        else:            return False# Your MyStack object will be instantiated and called as such:# obj = MyStack()# obj.push(x)# param_2 = obj.pop()# param_3 = obj.top()# param_4 = obj.empty() ","categories":["Leetcode"],"tags":["stack","queue"]},{"title":"【代码随想录】链表1-定义","url":"/blog/Leetcode/list1/","content":"链表定义\n性能对比：\nclass ListNode:    def __init__(self, val, next=None):        self.val = val        self.next = next\n203.移除链表元素\n题目链接 link\n\n给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。\n方法一：不使用虚拟头节点如果删除的时头节点，则需要单独处理，即直接将头节点指向下一个节点。\nclass Solution:    def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:        new_head = head        cur = head        pre = None        while cur != None:                        if cur.val == val:                if pre == None:                    cur = cur.next                    new_head = cur                else:                    pre.next = cur.next                    cur = cur.next            else:                pre = cur                cur = cur.next        return new_head\n\n方法二：使用虚拟头节点设置一个虚拟头结点，这样原链表的所有节点就都可以按照统一的方式进行移除了。\nclass Solution:    def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:        dummy_head = ListNode(0, head)        cur = head        pre = dummy_head        while cur != None:            if cur.val == val:                pre.next = cur.next            else:                pre = pre.next            cur = cur.next                return dummy_head.next\n\n707.设计链表\n题目链接 link\n\n你可以选择使用单链表或者双链表，设计并实现自己的链表。\n单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针&#x2F;引用。\n如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。\n实现 MyLinkedList 类：\n\nMyLinkedList() 初始化 MyLinkedList 对象。\nint get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。\nvoid addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。\nvoid addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。\nvoid addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。\nvoid deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。\n\n单链表注意，在 addAtIndex 方法中，需要判断 index 是否等于 list 的长度，如果等于的话就直接插入到末尾。但是在 while 循环中，也有 index &#x3D;&#x3D; i 的判断，这样会重复插入（覆盖），所以 while 中插入后，直接 return（之前写的 break）。\nclass MyLinkedList:    def __init__(self):        self.dummy_head = ListNode(0, None)    def get(self, index: int) -&gt; int:        i = 0        cur = self.dummy_head.next        while cur != None:            if index == i:                return cur.val            else:                cur = cur.next                i += 1        return -1    def addAtHead(self, val: int) -&gt; None:        new_node = ListNode(val, self.dummy_head.next)        self.dummy_head.next = new_node    def addAtTail(self, val: int) -&gt; None:        cur = self.dummy_head.next        pre = self.dummy_head        new_node = ListNode(val, None)        while cur != None:            cur = cur.next            pre = pre.next        pre.next = new_node    def addAtIndex(self, index: int, val: int) -&gt; None:        i = 0        cur = self.dummy_head.next        pre = self.dummy_head        while cur != None:            if index == i:                new_node = ListNode(val, cur)                pre.next = new_node                # 这里要写 return，不能写 break                return            else:                i += 1                pre = pre.next                cur = cur.next            # print(i, cur.val)        if index == i:            new_node = ListNode(val, None)            pre.next = new_node            def deleteAtIndex(self, index: int) -&gt; None:        i = 0        cur = self.dummy_head.next        pre = self.dummy_head        while cur != None:            if index == i:                pre.next = cur.next                break            else:                i += 1                pre = pre.next                cur = cur.next\n\n可以再定义一个 size 变量用于存储 list 的长度，这样会方便很多。\n双链表","categories":["Leetcode"],"tags":["list"]},{"title":"【代码随想录】栈和队列2-栈的应用","url":"/blog/Leetcode/stack-queue2/","content":"20. 有效的括号\nlink\n\n给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n每个右括号都有一个对应的相同类型的左括号。\n\n示例 1：\n\n输入：s &#x3D; “()”输出：true\n\n思路使用栈来进行存储，遇到匹配的则出栈。\nclass Solution:    def match(self, i, j):        if i == &quot;]&quot; and j == &quot;[&quot;:            return True        elif i == &#x27;&#125;&#x27; and  j == &#x27;&#123;&#x27;:            return True        elif i == &#x27;)&#x27; and j == &#x27;(&#x27;:            return True        else:            return False    def isValid(self, s: str) -&gt; bool:        stack = []        for i in s:            if len(stack) != 0:                if self.match(i, stack[-1]):                    stack.pop()                else:                    stack.append(i)            else:                stack.append(i)                if len(stack) == 0:            return True        else:            return False\n\n1047. 删除字符串中的所有相邻重复项\nlink\n\n给出由小写字母组成的字符串 s，重复项删除操作会选择两个相邻且相同的字母，并删除它们。在 s 上反复执行重复项删除操作，直到无法继续删除。在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。\n 示例：\n\n输入：”abbaca”输出：”ca”解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。  \n\n思路类似于上一题。可以理解为“消消乐”，遇到相同的则出栈。\nclass Solution:    def removeDuplicates(self, s: str) -&gt; str:        stack = []        for i in s:            if len(stack) != 0 and stack[-1] == i:                stack.pop()            else:                stack.append(i)                return &quot;&quot;.join(stack)\n\n150. 逆波兰表达式求值\nlink\n\n给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。请你计算该表达式。返回一个表示表达式值的整数。\n注意：\n\n有效的算符为 ‘+’、’-‘、’*’ 和 ‘&#x2F;‘ 。\n每个操作数（运算对象）都可以是一个整数或者另一个表达式。\n两个整数之间的除法总是 向零截断 。\n表达式中不含除零运算。\n输入是一个根据逆波兰表示法表示的算术表达式。\n答案及所有中间计算结果可以用 32 位 整数表示。\n\n思路核心规则：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中。\n注意题目中要求是向零截断，使用 // 不行。// 是向下取整，对于复数结果不满足向零截断（-1 &#x2F;&#x2F; 2 &#x3D;&#x3D; -1）。可以使用 int(a &#x2F; b)。\nclass Solution:    def evalRPN(self, tokens: List[str]) -&gt; int:        stack = []        for i in tokens:            if i.isdigit() or i.replace(&#x27;-&#x27;, &#x27;&#x27;).isdigit():                stack.append(int(i))            else:                num2 = stack.pop()                num1 = stack.pop()                if i == &#x27;-&#x27;:                    res = num1 - num2                elif i == &#x27;+&#x27;:                    res = num1 + num2                elif i == &#x27;*&#x27;:                    res = num1 * num2                elif i == &#x27;/&#x27;:                    res = int(num1 / num2)                stack.append(res)                return stack[0]","categories":["Leetcode"],"tags":["stack"]},{"title":"【代码随想录】栈和队列3-队列的应用","url":"/blog/Leetcode/stack-queue3/","content":"239. 滑动窗口最大值\nlink\n\n给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n返回滑动窗口中的最大值 。\n思路滑动窗口就是一个队列，需要存储其中的最大值。（但是如果最大值被 pop 出去了呢？记录次大值也不行）\n正确思路：维护一个单调队列。单调队列不一定要存放窗口中所有的数。pop 和 push 操作要保持如下规则：\n\npop(value)：如果窗口移除的元素 value 等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作\npush(value)：如果 push 的元素 value 大于入口元素的数值，那么就将队列入口的元素弹出，直到 push 元素的数值小于等于队列入口元素的数值为止\n\n保持如上规则，每次窗口移动的时候，只要问 que.front() （que[0]）就可以返回当前窗口的最大值。\n过程如图所示：\n\nclass MyQueue: #单调队列（从大到小    def __init__(self):        self.queue = deque() #这里需要使用deque实现单调队列，直接使用list会超时        #每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。    #同时pop之前判断队列当前是否为空。    def pop(self, value):        if self.queue and value == self.queue[0]:            self.queue.popleft()#list.pop()时间复杂度为O(n),这里需要使用collections.deque()                #如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。    #这样就保持了队列里的数值是单调从大到小的了。    def push(self, value):        while self.queue and value &gt; self.queue[-1]:            self.queue.pop()        self.queue.append(value)            #查询当前队列里的最大值 直接返回队列前端也就是front就可以了。    def front(self):        return self.queue[0]    class Solution:    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:        que = MyQueue()        result = []        for i in range(k): #先将前k的元素放进队列            que.push(nums[i])        result.append(que.front()) #result 记录前k的元素的最大值        for i in range(k, len(nums)):            que.pop(nums[i - k]) #滑动窗口移除最前面元素            que.push(nums[i]) #滑动窗口前加入最后面的元素            result.append(que.front()) #记录对应的最大值        return result\n\n347.前 K 个高频元素\nlink\n\n给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。\n示例 1:\n\n输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2输出: [1,2]\n\n思路三个步骤：\n\n要统计元素出现频率（哈希表）\n对频率排序（优先级队列）\n找出前K个高频元素\n\n优先级队列其实就是一个披着队列外衣的堆，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。优先级队列内部元素是自动依照元素的权值排列。\n堆（Heap）是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。大顶堆（堆头是最大元素），小顶堆（堆头是最小元素）。\n堆的常见用途：\n\n优先队列（Priority Queue）：比如 Python 的 heapq 默认是小顶堆。\n堆排序（Heap Sort）：利用大顶堆可实现升序排序，时间复杂度 O(n log n)。\nTop K 问题：维护一个大小为 K 的小顶堆来获取最大的 K 个元素。\n\n题目要求前 K 个高频元素，那么果断用大顶堆。那么问题来了，定义一个大小为 k 的大顶堆，在每次移动更新大顶堆的时候，每次弹出都把最大的元素弹出去了，那么怎么保留下来前K个高频元素呢。而且使用大顶堆就要把所有元素都进行排序，那能不能只排序k个元素呢？所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。\n寻找前k个最大元素流程如图所示：（图中的频率只有三个，所以正好构成一个大小为3的小顶堆，如果频率更多一些，则用这个小顶堆进行扫描）\n\nimport heapqclass Solution:    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:        #要统计元素出现频率        map_ = &#123;&#125; #nums[i]:对应出现的次数        for i in range(len(nums)):            map_[nums[i]] = map_.get(nums[i], 0) + 1                #对频率排序        #定义一个小顶堆，大小为k        pri_que = [] #小顶堆                #用固定大小为k的小顶堆，扫描所有频率的数值        for key, freq in map_.items():            heapq.heappush(pri_que, (freq, key))            if len(pri_que) &gt; k: #如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k                heapq.heappop(pri_que)                #找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组        result = [0] * k        for i in range(k-1, -1, -1):            result[i] = heapq.heappop(pri_que)[1]        return result\n","categories":["Leetcode"],"tags":["queue"]},{"title":"【代码随想录】链表3","url":"/blog/Leetcode/list3/","content":"142.环形链表II\n题目链接 link\n\n给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n不允许修改 链表。\n示例 1：\n\n返回的节点为 2\n\n思路 1：哈希表把遇到的节点存起来，如果重复遇到了节点，说明该节点是环的起点。\nclass Solution:    def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        cur = head        nodes = []        while cur != None:            if cur in nodes:                return cur            else:                nodes.append(cur)                cur = cur.next\n\n思路 2：快慢指针核心思想为：慢指针每次移动一格，快指针每次移动两格，如果快慢指针相遇，则一定在环上。（快指针追上慢指针）\n思路 2-1快慢指针相遇后，先让慢指针走一圈得到其圈的长度。然后从头重新定义快慢指针，快指针先走圈的长度，然后两个指针一起走，这样就会在圈的起点相遇。如图所示：\n\n思路 2-2更进一步，如图所示，慢指针走了 b，快指针走了 b + nc（n 为圈数），快指针每次移动两格，所以有 2b &#x3D; b + nc，即 b &#x3D; nc。相当于慢指针走的总长度为圈长度的 n 倍。但是，慢指针走的路程中（nc）中，有一段不在环中（即要求的 a），所以说，还需要再走 a 才相当于走满了 n 圈。\n然后再使用双指针，分别从头节点和相遇节点出发，他们一定会在环的起点相遇。\n思路 2-1 可以认为是特殊情况，先求出环的长度 c，快指针先走 c，还需要再走 a 才能回到环的起点，此时两个指针同时移动，相遇时则走了 a。\n\nclass Solution:    def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        fast = head        slow = head        while fast != None and fast.next != None:            fast = fast.next.next            slow = slow.next            if fast == slow:                new_slow = head                while new_slow != slow:                    slow = slow.next                    new_slow = new_slow.next                                return new_slow                return None","categories":["Leetcode"],"tags":["list"]},{"title":"【代码随想录】二叉树1-遍历","url":"/blog/Leetcode/tree1/","content":"二叉树概念满二叉树和完全二叉树\n\n二叉搜索树二叉搜索树是一个有序树。\n\n若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；\n若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；\n它的左、右子树也分别为二叉排序树\n\n\n平衡二叉搜索树，又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。\n\n存储方式链式存储：\n\n顺序存储：\n\n如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。\n遍历\n深度优先遍历\n前序遍历（递归法，迭代法）\n中序遍历（递归法，迭代法）\n后序遍历（递归法，迭代法）\n\n\n广度优先遍历\n层次遍历（迭代法）\n\n\n\n注意，这里前中后，其实指的就是中间节点的遍历顺序，只要大家记住前中后序指的就是中间节点的位置就可以了。\n二叉树的递归遍历迭代（iteration）是重复反馈过程的活动，其目的通常是逼近所需目标或结果；递归（recursion）是重复调用函数自身。迭代通常由计数器来判断是否结束；而递归则满足终止条件才逐层返回。\n递归三要素：\n\n确定递归函数的参数和返回值：参数为当前节点，返回值为结果数组（在方法内定义迭代函数，可以不设置返回值）\n确定终止条件：当前节点为空则返回\n确定单层递归的逻辑：三个步骤，根据遍历的类型来调整顺序\n遍历当前节点（将当前节点的内容加到结果数组中）\n遍历左子树\n遍历右子树\n\n\n\n前序遍历代码如下，中序和后序遍历只需要更改递归函数中的逻辑顺序即可\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:        def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        res = []        def recursion(node):            if node != None:                res.append(node.val)                recursion(node.left)                recursion(node.right)                recursion(root)        return res\n\n二叉树的迭代遍历递归的实现是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。\n前序遍历当栈不为空时，将栈顶节点 pop，访问其元素，并将其子节点分别放入栈中。注意要先放右节点再放左节点，以保证左节点先访问。\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:        def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        res = []        stack = [root]        while len(stack) != 0:            cur = stack.pop()            if cur != None:                res.append(cur.val)                stack.append(cur.right)                stack.append(cur.left)                return res\n\n中序遍历前序遍历的顺序是中左右，先访问的元素是中间节点（子节点分别放到栈中），先处理的元素也是中间节点（将 val 存入 res），所以刚刚才能写出相对简洁的代码，因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。\n中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。\n对于当前栈顶节点节点，一直遍历左子树，直到为空（访问左）；然后，将 val 存入 res（处理中）；最后再将当前节点的右子树放到栈中（访问右）。\nclass Solution:    def inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        res = []        stack = []        cur = root        while True:            while cur != None:                stack.append(cur)                cur = cur.left                        if len(stack) == 0:                break            cur = stack.pop()            res.append(cur.val)            cur = cur.right        return res\n\n后续遍历思路 1和中序遍历一样，对于当前节点，一直遍历其左子树，直到为空（访问左）；然后对其右子树进行判断（访问右），如果：\n\n右子树为空，则访问当前元素（处理中）\n右子树不为空，此时需要判断当前右子树是否被访问过：\n右子树访问过，则访问当前元素\n没访问过，则当前节点再次入栈，并且当前指针指向右节点\n\n\n\n总结一下，右子树不为空并且没被访问过，则访问右子树；否则访问当前元素，并记录当前元素已经访问。\nclass Solution:        def postorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        res = []        stack = []        cur = root        prev = None        while True:            while cur != None:                stack.append(cur)                cur = cur.left                        if len(stack) == 0:                break                        cur = stack.pop()            if cur.right != None and prev != cur.right:                stack.append(cur)                cur = cur.right            else:                res.append(cur.val)                prev = cur                cur = None        return res\n\n思路 2先序遍历是中左右，后序遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了。\n统一迭代遍历递归本质上是维护一个栈来保存调用顺序。但是可能会面临访问（访问子节点）和处理（读取值）不同步的情况，导致不同的遍历顺序写法不同。要统一写法，将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记：\n\n方法一：就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。 这种方法可以叫做空指针标记法。\n\n方法二：加一个 boolean 值跟随每个节点，false (默认值) 表示需要为该节点和它的左右儿子安排在栈中的位次，true 表示该节点的位次之前已经安排过了，可以收割节点了。 这种方法可以叫做boolean 标记法。这种方法更容易理解，在面试中更容易写出来。\n\n\n方法一首先把根节点放到 stack 中（保证不为空），核心逻辑为：栈头元素出栈，判断该节点是否为空\n\n如果为空，说明当前的栈头元素的子元素已经访问过，则当前栈头元素出栈，读取其 val；\n如果不为空，说明当前元素的子元素没被访问过，则将当前节点的子节点、当前节点和一个空节点加入到 stack 中。（注意 stack 先进先出，所以要逆序，即前序遍历是中左右，则放入 stack 的顺序为：右、左，中+空节点）\n\n前序代码如下，中序和后序只需要更改三个步骤的顺序即可。\nclass Solution:        def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        res = []        stack = []        if root != None:            stack.append(root)        while len(stack) != 0:            cur = stack.pop()            if cur != None:                # 右节点入栈                if cur.right:                    stack.append(cur.right)                # 左节点入栈                if cur.left:                    stack.append(cur.left)                # 中间节点入栈                stack.append(cur)                stack.append(None)            else:                cur = stack.pop()                res.append(cur.val)        return res\n\n方法二栈存放一个元组，包含节点和一个 flag，表示当前节点的子节点是否被访问过。接下来则和方法一类似，对于每个节点都检查这个 flag，如果为 False，说明子节点没有被访问过，则遍历子节点；如果为 True，则处理当前节点。\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:        def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        res = []        stack = []        if root != None:            stack.append((root, False))        while len(stack) != 0:            cur, flag = stack.pop()            if flag == False:                if cur.right:                    stack.append((cur.right, False))                if cur.left:                    stack.append((cur.left, False))                stack.append((cur, True))            else:                res.append(cur.val)        return res\n\n102.二叉树的层序遍历\nlink\n\n给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。\n示例\n\n\n输入：root &#x3D; [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]  \n\n思路一个队列来存储节点。对于当前节点，访问之后将其子节点加入到队列中，直到队列为空。\nclass Solution:    def levelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:        que = deque()        res = []        if root:            que.append(root)                while que:            cur = que.popleft()            res.append(cur.val)            if cur.left:                que.append(cur.left)            if cur.right:                que.append(cur.right)                return res\n不难写出以上代码，但是注意到题目要求每一层的节点在单独的一个 list 中。解决方法，保证每次循环（que 长度不为 0）时，队列中只有一层的节点，所以可以一次性把当前层的所有子节点全部放到队列中。只需要对当前队列进行遍历即可。\nclass Solution:    def levelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:        que = deque()        res = []        if root:            que.append(root)                while que:            cur_level = []            for _ in range(len(que)):                cur = que.popleft()                cur_level.append(cur.val)                if cur.left:                    que.append(cur.left)                if cur.right:                    que.append(cur.right)            res.append(cur_level)        return res\n\n107.二叉树的层次遍历 II给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n思路：相较于上一题，只需要把结果反过来即可\n199.二叉树的右视图\nlink\n\n\n思路：遍历每一层时，只需要保留当前层的最后一个元素即可\nclass Solution:    def rightSideView(self, root: Optional[TreeNode]) -&gt; List[int]:        que = deque()        res = []        count = 0        if root:            que.append(root)            count += 1                while que:            l = len(que)            for i in range(len(que)):                cur = que.popleft()                if i == l - 1:                    res.append(cur.val)                if cur.left:                    que.append(cur.left)                if cur.right:                    que.append(cur.right)        return res\n\n637.二叉树的层平均值给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。\n思路：遍历每一层时求均值即可\n429.N叉树的层序遍历和二叉树相同，只不过 N 叉树的子节点为一个 Node 的数组\n515.在每个树行中找最大值将每行数组中最大的值存入 res 即可\n116.填充每个节点的下一个右侧节点指针\n思路：在每一层，针对每一个节点进行操作即可\n104.二叉树的最大深度二叉树的层序遍历，最后返回 res 的长度即可\n111.二叉树的最小深度同样是层序遍历，只不过判断条件是左右孩子全为空则说明到了最浅的节点（因为是严格按照一层一层来进行遍历的）。\n","categories":["Leetcode"],"tags":["tree"]},{"title":"【代码随想录】二叉树2-属性1","url":"/blog/Leetcode/tree2/","content":"101. 对称二叉树\nlink给一个二叉树的根节点 root ， 检查它是否轴对称。\n\n思路层序遍历，判断每一层是否为对称。注意需要记录当前在第几层，还需要判断当前层的长度是否是 2^n。但是，这种方法只考虑了满二叉树的情况。\nclass Solution:    def isSymmetric(self, root: Optional[TreeNode]) -&gt; bool:        que = deque()        if root:            que.append(root)        count = 0        while que:            cur_level = []            for _ in range(len(que)):                cur = que.popleft()                cur_level.append(cur.val)                if cur.left:                    que.append(cur.left)                if cur.right:                    que.append(cur.right)            if len(cur_level) == 2 ** count:                l, r = 0, len(cur_level) - 1                while l &lt;= r:                    if cur_level[l] != cur_level[r]:                        return False                    else:                        l += 1                        r -= 1            else:                return False            count += 1        return True\n\n正确思路对于根节点，应该要判断其两个子树是否是对称的，所以需要同时遍历两个子树。注意，两个子树的遍历方法也需要对称，本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。（？）\n递归三部曲：\n\n参数和返回类型：传入左右子树，返回两个子树是否相等\n终止条件：比较两个子节点\n单层递归逻辑：分别比较外侧和内侧节点是否相等\n\nclass Solution:    def isSymmetric(self, root: Optional[TreeNode]) -&gt; bool:                def treverse(l, r):            if l != None and r == None:                return False            elif l == None and r != None:                return False            elif l == None and r == None:                return True            else:                if r.val != l.val:                    return False                else:                    # 左右节点都不为空，且节点相等，开始遍历子节点                    inter = treverse(l.right, r.left)                    out = treverse(l.left, r.right)                                        if out &amp; inter:                        return True                    else:                        return False                if root:            return treverse(root.left, root.right)        else:            return False\n\n\n\n104.二叉树的最大深度层序遍历，返回 res 的长度\n111.二叉树的最小深度层序遍历，节点的左右都为空时，则返回当前深度\n222.完全二叉树的节点个数完全二叉树：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点\n思路1直接遍历\n思路2完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。\n对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。\n对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。\n\n在完全二叉树中，如果递归向左遍历的深度等于递归向右遍历的深度，那说明就是满二叉树。\nclass Solution:    def countNodes(self, root: Optional[TreeNode]) -&gt; int:        def treverse(node):            if node!= None:                leftd, rightd = 1, 1                rightn = node.right                leftn = node.left                while rightn:                    rightd += 1                    rightn = rightn.right                while leftn:                    leftd += 1                    leftn = leftn.left                if leftd == rightd:                    return 2 ** leftd - 1                else:                    return treverse(node.left) + treverse(node.right) + 1            else:                return 0        return treverse(root)\n\n110.平衡二叉树\nlink\n\n平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。\n\n二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。\n二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。\n\n\n使用后序遍历：\n\n参数：当前传入节点。 返回值：以当前传入节点为根节点的树的高度。\n递归的过程中依然是遇到空节点了为终止，返回0，表示当前节点为根节点的树高度为0\n判断以当前传入节点为根节点的二叉树是否是平衡二叉树：其左子树高度和其右子树高度的差值。代码中返回 -1 表示当前已经有子树不满足平衡条件了，所以不用进行后续比较，直接退出即可。\n\nclass Solution:    def isBalanced(self, root: Optional[TreeNode]) -&gt; bool:        def treverse(node):            if node != None:                leftd = treverse(node.left)                rightd = treverse(node.right)                if leftd == -1:                    return -1                if rightd == -1:                    return -1                if abs(leftd - rightd) &gt; 1:                    return -1                else:                    return 1 + max(leftd, rightd)            else:                return 0                if treverse(root) == -1:            return False        else:            return True","categories":["Leetcode"],"tags":["tree"]},{"title":"【代码随想录】字符串1","url":"/blog/Leetcode/string1/","content":"344. 反转字符串\nlink\n\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。\n不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\n示例 1：\n\n输入：s &#x3D; [“h”,”e”,”l”,”l”,”o”]输出：[“o”,”l”,”l”,”e”,”h”]  \n\n思路从头到尾、从尾到头同时遍历，然后交换。\nclass Solution:    def reverseString(self, s: List[str]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify s in-place instead.        &quot;&quot;&quot;        left = 0        right = len(s) - 1        while left &lt; right:            temp = s[left]            s[left] = s[right]            s[right] = temp            left += 1            right -= 1        \n\n541. 反转字符串 II\nlink\n\n给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。\n如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\n示例 1：\n\n输入：s &#x3D; “abcdefg”, k &#x3D; 2输出：”bacdfeg”\n\n思路模拟过程，每过 2k 个步骤就处理一次\nclass Solution:    def reserve(self, s):        left = 0        right = len(s) - 1        while left &lt; right:            temp = s[left]            s[left] = s[right]            s[right] = temp            left += 1            right -= 1        return &quot;&quot;.join(s)    def reverseStr(self, s: str, k: int) -&gt; str:        s_list = list(s)        res = []        for i in range(0, len(s_list), 2 * k):            left = len(s_list) - i            if left &gt;= 2 * k:                res.append(self.reserve(s_list[i:i+k]))                res.append(&quot;&quot;.join(s_list[i+k:i+2*k]))            elif left &lt; 2 * k and left &gt;= k:                res.append(self.reserve(s_list[i:i+k]))                res.append(&quot;&quot;.join(s_list[i+k:]))            else:                res.append(self.reserve(s_list[i:]))                return &quot;&quot;.join(res)\n\n替换数字\nlink\n\n给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。\n例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。\n思路直接遍历，然后将结果存在数组中即可\nimport sysinput = sys.stdin.readdata = input()res = []for i in data:    if i.isdigit():        res.append(&quot;number&quot;)    else:        res.append(i)print(&quot;&quot;.join(res))\n\n还可以使用双指针的方法，即首先确定数字的数量，然后两个指针分别在原字符串和新的结果 list 上移动。\nimport sysinput = sys.stdin.readdata = input()num = 0for i in data:    if i.isdigit():        num += 1res = [&quot;0&quot;] * (num * 5 + len(data))j = 0s = &quot;number&quot;for i in range(len(data)):    if data[i].isdigit():        for index in range(len(s)):            res[j+index] = s[index]                j += 6    else:        res[j] = data[i]        j += 1print(&quot;&quot;.join(res))\n\n上述代码是从前往后填充，但是某些题目要求在原对象上修改（扩容之后），所以最好是从后往前填充。示意图如下：\n\n151.翻转字符串里的单词\nlink\n\n给你一个字符串 s ，请你反转字符串中 单词 的顺序。\n单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。\n返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。\n注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。\n示例 1：\n\n输入：s &#x3D; “the sky is blue”输出：”blue is sky the”  \n\n思路相当于是使用 split() 之后在倒序。注意：split()：多个空格当成一个空格；split(‘ ‘)：多个空格都要分割，每个空格分割出来空字符串。但是要我们自己实现 split() 方法。这里使用了双指针来判断单词的起始位置，然后把单词存起来。\nclass Solution:    def reverseWords(self, s: str) -&gt; str:                s_list = list(s)        slow = 0        fast = 0        res = []        while fast &lt; len(s):            if slow == fast:                 if s_list[slow] == &quot; &quot; :                    slow += 1                    fast += 1                elif fast == len(s) - 1:                    res.append(&quot;&quot;.join(s[slow:fast+1]))                    fast += 1                else:                    fast += 1            else:                if s_list[fast] == &quot; &quot;:                    res.append(&quot;&quot;.join(s[slow:fast]))                    slow = fast                elif fast == len(s) - 1:                    res.append(&quot;&quot;.join(s[slow:fast+1]))                    fast += 1                else:                    fast += 1        new_res = []        for i in range(len(res)-1, -1, -1):            new_res.append(res[i])        return &quot; &quot;.join(new_res)\n\n进阶如果要求空间复杂度为 O(1) 呢？类似于之前的 移除元素 ，同样使用快慢指针，删除多余的空格。然后翻转整个字符串，再遍历其中的单词，把单词翻转回来。解题思路如下：\n\n移除多余空格\n将整个字符串反转\n将每个单词反转\n\n举个例子，源字符串为：” the sky is blue  “\n\n移除多余空格 : “the sky is blue”\n字符串反转：”eulb si yks eht”\n单词反转：”blue is sky the”\n\n这样空间复杂度为 O(1)，但是 python 的 string 不支持修改，所以可以将字符串转换为 list 来进行操作。\n右旋字符串\nlink\n\n字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。 \n例如，对于输入字符串 “abcdefg” 和整数 2，函数应该将其转换为 “fgabcde”。\n思路简单的想法肯定是用一个新的数组来存放结果。但是如果要求在原有的数组基础上进行修改，可以参考上一题使用整体反转+局部反转就可以实现反转单词顺序的思想。如图所示：\n\n其实，思路就是 通过 整体倒叙，把两段子串顺序颠倒，两个段子串里的的字符在倒叙一把，负负得正，这样就不影响子串里面字符的顺序了。\n","categories":["Leetcode"],"tags":["string"]},{"title":"【代码随想录】字符串2-KMP算法","url":"/blog/Leetcode/string2/","content":"KMP 算法KMP有什么用KMP的经典思想就是:当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。\nnext数组就是一个前缀表（prefix table）。前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。\n例子：要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。\n\n可以看出，文本串中第六个字符b 和 模式串的第六个字符f，不匹配了。如果暴力匹配，发现不匹配，此时就要从头匹配了。\n但如果使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中第三个字符b继续开始匹配。\n理解：在当前对文本串和模式串检索的过程中，若出现了不匹配，如何充分利用已经匹配的部分。到不匹配时，找到匹配的字符串中，最长的相等的前后缀。例如上面的例子，已经匹配了 aabaa，下一个不匹配了，找到最长相等的前后缀为 aa。这个 aa 表示：\n\n模式串的前两个 aa\n匹配了的文本串的后两个 aa\n\n这两个部分是相等的，所以这两部分不用匹配，直接从 aa 的下一个字符开始匹配，如图所示：\n\nnext 数组参考讲解 bilibili，以及其中的评论：  \n\n借视频中例子说明一下 prefix_len &#x3D; next【prefix_len - 1】 的原因。例如，串 A B A C A B A B　　　　 0 1 2 3 4 5 6 7扫描到 6 号位的 A 时，最长公共前后缀是 ABA；而扫描到 7 号位的 B 时，ABAC 和 ABAB 不匹配了，即原来的最长公共前后缀失配。这时候我们要做的事情就是，找上一次匹配中次长的公共前后缀，看与 7 号位的 B 拼接起来是否能匹配。这时候，注意到上一次扫描中 0 ~ 2 位的 ABA 是和 4 ~ 6 位的 ABA 完全相同的（贪心原则保证上次结果一定是包含前一位置字符的最长公共前后缀），所以考察上一次匹配中次长的公共前后缀，只能在考察上一次匹配中的最长公共前后缀中考察，也就是说，只能考察 ABA 中更短的 BA、A 是否是次长的，而这直接在前面一个 ABA 中考察都行，所以我们把 ABA C ABA 中中间部分（C）和后缀（ABA）直接抛弃，等效于一个串 ABA（也就是前缀）与 B 拼接成 ABAB。这样再来计算第 7 位的 B 的 next 值，等价于计算 ABAB 第 3 位的 B 的 next 值。prefix_len &#x3D; next【prefix_len - 1】 也就是这个等效过程的代码展示。  \n\nnext 数组表示的就是：下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。\n\n在比较时找到的不匹配的位置，那么此时我们要看它的前一个字符的前缀表的数值是多少。然后移动到前缀表数值对应的下标处重新开始匹配。\n如何计算 next 数组？核心是“回退”，利用前面计算好的 next 数组来简化计算。可以分为三个步骤：\n\n初始化\n字符相同时\n字符不同时\n\n初始化初始化两个指针，i 表示后缀的末尾，从 1 开始；j 表示前缀的末尾（也表示前缀的长度），从 0 开始。最开始 next[0] 一定为 0，因为没有意义。然后 i 遍历 range(1, len(patt))。分别处理相同和不相同的情况。（先理解后面两种情况，然后再理解为什么这样初始化）\n字符相同例如，已经找到了当前最长的相同前后缀为 AB，此时 j&#x3D;1（B），i&#x3D;5（B）。在下一轮，我们只需要判断下一个字符是否相同，即 j&#x3D;2（A），i&#x3D;6（B），此时相同，那么就可以直接将前缀长度 j（也等于 next[i-1]，但是为了统一表达，还是使用 j，详见下面的情况） 加一作为当前的 next[i]。\n字符不同上一步已经找到最长的相同前后缀为 ABA，但是下一个字符不相同。此时要做的事情是，找上一次匹配中次长的相同前后缀，看与 i&#x3D;7 的 B 拼接起来是否能匹配（因为要使用之前计算的 next 数组，最长的不符合就找次长的）。\n而找次长的相同前后缀，等价以当前最长的相同前后缀为对象，找最长的相同前后缀。（也就是将 ABA 看作单独的字符串，找 ABA 的最长相同子字符串）。因为次长的相同前后缀一定在最长的前后缀中（贪心原则，每次都是在上一轮最长前后缀的基础上扩展）。\n而 ABA 的最长相同前后缀在之前已经计算好了，为 next[j-1]（此时 j&#x3D;3）（左图）。所以 j 就回退到次长的相同前后缀处（回退后 j&#x3D;1），再次进行比较（中图）。此时字符相同，就可以直接将前缀长度 j 加一作为当前的 next[i]（右图，注意，此时就不能再像上面那个情况一样，使用 next[i-1] 来赋值）。\n\n计算 next 数组在遍历 i 时，注意 for 和 while 循环的不同写法。因为在字符不相同时，j 需要回退到次长相同前后缀的位置来再次比较，如果还是不相同还需要回退。所以 i 的值需要手动控制（使用 while 循环）或者对当前 i 进行多次比较（for 循环中再套一层 while）。代码如下：\ni = 1j = 0next = [0] * len(patt)while i &lt; len(patt):    if patt[i] == patt[j]:        next[i] = j + 1        j += 1        i += 1    else:        if j == 0:            next[i] = j            i += 1        else:            j = next[j - 1]\n\nj = 0next = [0] * len(patt)for i in range(1, len(patt)):    while j &gt; 0 and patt[i] != patt[j]:        j = next[j-1]    if patt[i] == patt[j]:        j += 1        next[i] = j\n\n28. 实现 strStr()\nlink\n\n给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。\n示例 1：\n\n输入：haystack &#x3D; “sadbutsad”, needle &#x3D; “sad”输出：0解释：”sad” 在下标 0 和 6 处匹配。第一个匹配项的下标是 0 ，所以返回 0 。\n\n示例 2：\n\n输入：haystack &#x3D; “leetcode”, needle &#x3D; “leeto”输出：-1解释：”leeto” 没有在 “leetcode” 中出现，所以返回 -1 。  \n\n思路KMP 算法的应用，计算完 next 数组后，就需要进行匹配。使用两个指针，分别在文本串和模式串上移动，当不匹配时，模式串上的指针 j 就回退到前一位对应的 next 数组的值处，即 j &#x3D; next[j-1]。（从这里也可以看出，计算 next 数组本质上也是 KMP 算法！）\n注意两种写法的返回值不一样！\nfor 写法：i 是在每次循环开始才增加，在循环中，j 先增加，所以判断是否遍历到模式串末尾时，只有 j 增加了，所以返回需要加 1。\nclass Solution:    def strStr(self, haystack: str, needle: str) -&gt; int:        j = 0        next = [0] * len(needle)        for i in range(1, len(needle)):            while j &gt; 0 and needle[i] != needle[j]:                j = next[j-1]            if needle[i] == needle[j]:                j += 1                        next[i] = j                j = 0        i = 0        for i in range(len(haystack)):            while j &gt; 0 and haystack[i] != needle[j]:                j = next[j-1]            if haystack[i] == needle[j]:                j += 1            if j == len(needle):                return i - j + 1    return -1\n\nwhile 写法：while 循环是我们自己控制 i 和 j 的增减，所以如果满足条件，他们是同时增加的。所以判断是否遍历到模式串末尾时，不需要加 1。\nclass Solution:    def strStr(self, haystack: str, needle: str) -&gt; int:        j = 0        next = [0] * len(needle)        for i in range(1, len(needle)):            while j &gt; 0 and needle[i] != needle[j]:                j = next[j-1]            if needle[i] == needle[j]:                j += 1                        next[i] = j                j = 0        i = 0                    while i &lt; len(haystack):            if haystack[i] == needle[j]:                j += 1                i += 1            else:                if j == 0:                    i += 1                else:                    j = next[j-1]            if j == len(needle):                return i - j         return -1\n\n459. 重复的子字符串\nlink\n\n给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。\n示例 1:\n\n输入: s &#x3D; “abab”输出: true解释: 可由子串 “ab” 重复两次构成。  \n\n示例 2:\n\n输入: s &#x3D; “aba”输出: false  \n\n思路 1对每个子串都应用 KMP 算法，优化的点：\n\n传入的 haystack 串可以去除选择的子串\n遍历子串的时候，如果剩余长度小于子串长度，则跳过\nreturn 的时机：  \n不相等直接 return False\n两个指针同时指向各自字符串的末尾\n\n\n\n但是会超出时间限制\nclass Solution:    def kmp(self, haystack, needle):        j = 0        next = [0] * len(needle)        for i in range(1, len(needle)):            while j &gt; 0 and needle[i] != needle[j]:                j = next[j-1]            if needle[i] == needle[j]:                j += 1                        next[i] = j                j = 0        i = 0                    while i &lt; len(haystack):            if haystack[i] == needle[j]:                j += 1                i += 1            else:                return False            if j == len(needle):                if i == len(haystack):                    return True                else:                    j = 0    def repeatedSubstringPattern(self, s: str) -&gt; bool:        for i in range(len(s)):            left = len(s) - i - 1            if left &lt; i + 1:                return False                        if self.kmp(s[i+1:], s[0:i+1]):                return True        \n思路 2：暴力一个for循环获取 子串的终止位置， 然后判断子串是否能重复构成字符串，又嵌套一个for循环，所以是O(n^2)的时间复杂度。\n思路 3：移动匹配如果一个字符串 s 由子串构成，那么 s+s 去掉首尾之后一定包含 s。\n需要证明充要性:（？）\n\ns 可由某个非空子串重复 k≥2 次构成 &lt;–&gt; s 是 (s+s)[1:−1] 的一个子串.\n\n可以直接用 in，也可以用 KMP 实现的 strStr()。\nclass Solution:    def strStr(self, haystack: str, needle: str) -&gt; int:        j = 0        next = [0] * len(needle)        for i in range(1, len(needle)):            while j &gt; 0 and needle[i] != needle[j]:                j = next[j-1]            if needle[i] == needle[j]:                j += 1                        next[i] = j                j = 0        i = 0                    while i &lt; len(haystack):            if haystack[i] == needle[j]:                j += 1                i += 1            else:                if j == 0:                    i += 1                else:                    j = next[j-1]            if j == len(needle):                return True        return False    def repeatedSubstringPattern(self, s: str) -&gt; bool:                ss = s + s        return self.strStr(ss[1:-1], s)\n\n思路 4：KMP在一个串中查找是否出现过另一个串，这是KMP的看家本领。KMP算法中next数组为什么遇到字符不匹配的时候可以找到上一个匹配过的位置继续匹配，靠的是有计算好的前缀表。前缀表里，统计了各个位置为终点字符串的最长相同前后缀的长度。那么 最长相同前后缀和重复子串的关系又有什么关系呢？\n字符串s是由重复子串组成 &lt;&#x3D;&#x3D;&#x3D;&gt; 最长相等前后缀不包含的子串是字符串s的最小重复子串\n","categories":["Leetcode"],"tags":["string"]},{"title":"【代码随想录】二叉树3-属性2","url":"/blog/Leetcode/tree3/","content":"257. 二叉树的所有路径\nlink\n\n给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。叶子节点是指没有子节点的节点。\n思路要从根节点出发，记录路径，一直走到叶子节点，把这条路径记录下来。必须先访问根节点，所以只能用前序遍历。涉及到回溯，因为我们要把路径记录下来，需要回溯来回退一个路径再进入另一个路径。\n递归法(DFS)逻辑\n\n把当前节点的值加入路径中 \n如果是叶子节点，就把路径加入结果集\n否则继续递归左右子树\n回溯时，把路径中当前节点的值弹出，回退到上一步\n\nclass Solution:    def binaryTreePaths(self, root: Optional[TreeNode]) -&gt; List[str]:        res = []        path = []        def treverse(node):            path.append(str(node.val))            if node.left == None and node.right == None:                res.append(&quot;-&gt;&quot;.join(path))            if node.left:                treverse(node.left)            if node.right:                treverse(node.right)                        path.pop()                if root !=None:            treverse(root)        return res\n\nBFS层序遍历，队列中直接存储当前节点以及其对应的路径\nclass Solution:    def binaryTreePaths(self, root: Optional[TreeNode]) -&gt; List[str]:        res = []        que = deque()        if root != None:            que.append((root, [str(root.val)]))        while que:            cur, path = que.popleft()            if cur.left == None and cur.right == None:                res.append(&quot;-&gt;&quot;.join(path))            if cur.left:                que.append((cur.left, path + [str(cur.left.val)]))            if cur.right:                que.append((cur.right, path + [str(cur.right.val)]))        return res\n\n注意，上述代码中，入队时不能使用 append，因为如果左右节点都存在，那么会错误添加元素\n404.左叶子之和\nlink\n\n\n\n输入: root &#x3D; [3,9,20,null,null,15,7]输出: 24解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24  \n\n思路dfs 遍历该树，遇到左节点为叶子节点就记录其数值，否则遍历其子树。注意这里写成了 res &#x3D; [0]，不写 res&#x3D;0 是因为在函数内部对某个变量赋值（如 res +&#x3D; …），Python 会默认把这个变量当作函数的局部变量。\nclass Solution:    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -&gt; int:        res = [0]  # ✅ 使用 list 包装成可变对象        def dfs(node):            if node.left:                # 如果左孩子是叶子节点才加                if not node.left.left and not node.left.right:                    res[0] += node.left.val                else:                    dfs(node.left)            if node.right:                dfs(node.right)        if root:            dfs(root)        return res[0]\n\n513.找树左下角的值\nlink\n\n给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。\n思路层序遍历，取最后一层的第一个结果\nclass Solution:    def findBottomLeftValue(self, root: Optional[TreeNode]) -&gt; int:        res = []        que = deque()        que.append(root)        while que:            cur_level = []            for _ in range(len(que)):                                cur = que.popleft()                cur_level.append(cur.val)                if cur.left:                    que.append(cur.left)                if cur.right:                    que.append(cur.right)                                        res.append(cur_level)                return res[-1][0]\n112. 路径总和\nlink\n\n给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。\n思路类似于 257. 二叉树的所有路径，只是当访问到叶子节点时，就计算路径和，判断是否满足条件。使用 BFS 较为简单，可以更好控制返回时机。\nclass Solution:    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -&gt; bool:        que = deque()        if root:            que.append((root, [root.val]))        while que:            cur, path = que.popleft()            if cur.left == None and cur.right == None:                s = sum(path)                if s == targetSum:                    return True            if cur.left:                que.append((cur.left, path + [cur.left.val]))                        if cur.right:                que.append((cur.right, path + [cur.right.val]))                return False\n\n","categories":["Leetcode"],"tags":["tree"]},{"title":"【代码随想录】二叉树4-修改与改造","url":"/blog/Leetcode/tree4/","content":"226.翻转二叉树\nlink\n\n翻转一颗二叉树\n思路前序遍历或者后续遍历，在访问当前节点的时候就翻转节点的两个子树。\n递归写法\nclass Solution:    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:        def treverse(node):            if node != None:                temp = node.right                node.right = node.left                node.left = temp                treverse(node.left)                treverse(node.right)                treverse(root)        return root\n\n迭代写法（统一的思路）\nclass Solution:    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:                stack = []        if root != None:            stack.append(root)                while stack:            cur = stack.pop()            if cur != None:                # 右节点入栈                if cur.right:                    stack.append(cur.right)                # 左节点入栈                if cur.left:                    stack.append(cur.left)                # 中间节点入栈                stack.append(cur)                stack.append(None)            else:                cur = stack.pop()                temp = cur.left                cur.left = cur.right                cur.right = temp        return root\n\n106.从中序与后序遍历序列构造二叉树\nlink\n\n给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。\n思路明确：\n\n后序遍历的性质：后序遍历的最后一个元素一定是整棵树的根节点。即 postorder &#x3D; [左子树…, 右子树…, 根]\n中序遍历的性质：在中序遍历中，根节点左边的元素是左子树，右边的是右子树。\n\n过程如下：\n\n从后序遍历中取出最后一个元素作为根节点；\n在中序遍历中找到这个根节点的位置；\n递归构建左右子树：\n中序左边部分 → 左子树\n中序右边部分 → 右子树\n后序中要对应分成左子树和右子树的区间\n\n\n\n\n注意在递归中，要优先处理右子树，因为右子树更靠近根节点，需要先 pop（但是为什么不需要手动切片？这里的 posto 不是局部变量吗？）\nclass Solution:    def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; Optional[TreeNode]:                def make(ino, posto):            if not ino or not posto:                return None            val = posto.pop()            index = ino.index(val)            root = TreeNode(val)            subinleft = ino[0:index]            subinright = ino[index+1:]            root.right = make(subinright, posto)            root.left = make(subinleft, posto)            return root        return make(inorder, postorder)        \n\n\n105. 从前序与中序遍历序列构造二叉树\nlink\n\n类似于上一题，只不过由于前序遍历是根节点在索引 0，无法动态更新数组，所以需要进行手动切片，此时就不需要在乎先处理哪个子树了，因为已经显示地指定。上一题需要先处理右子树，是因为需要在递归的过程中多次修改 posto 数组。\nclass Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:        def make(ino, posto):            if not ino or not posto:                return None            val = posto[0]            index = ino.index(val)            root = TreeNode(val)            subinleft = ino[0:index]            subinright = ino[index+1:]            root.left = make(subinleft, posto[1:len(subinleft)+1])            root.right = make(subinright, posto[len(subinleft)+1:])            return root        return make(inorder, preorder)\n小总结\n前序和中序可以唯一确定一棵二叉树。\n后序和中序可以唯一确定一棵二叉树。\n但是前序和后序不能唯一确定一棵二叉树！\n\n因为无法确定根节点，就无法进行分割\n654.最大二叉树\nlink\n\n给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:\n\n创建一个根节点，其值为 nums 中的最大值。\n递归地在最大值 左边 的 子数组前缀上 构建左子树。\n递归地在最大值 右边 的 子数组后缀上 构建右子树。\n\n思路类似于构造二叉树，思路在题目中已经给出\nclass Solution:    def constructMaximumBinaryTree(self, nums: List[int]) -&gt; Optional[TreeNode]:                def make(num_list):            if not num_list:                return None            max_num = max(num_list)            index = num_list.index(max_num)            root = TreeNode(max_num)            root.left = make(num_list[:index])            root.right = make(num_list[index+1:])            return root                return make(nums)\n\n617.合并二叉树\nlink\n\n同时遍历两颗树即可。注意递归的主逻辑判断，当一个节点为空时，直接返回另一个节点，不用考虑另一个节点是否为空。只有两个节点都不为空的时候才需要单独判断。\nclass Solution:    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -&gt; Optional[TreeNode]:                def make(node1, node2):            if node1 == None:                return node2            if node2 == None:                return node1                        cur = TreeNode(node1.val + node2.val)            cur.left = make(node1.left, node2.left)            cur.right = make(node1.right, node2.right)            return cur                return make(root1, root2)\n\n","categories":["Leetcode"],"tags":["tree"]},{"title":"Pycharm debug 方法记录","url":"/blog/Mark/debug/","content":"Pycharm 调试按钮\n参考链接\n\n\nstep over（F8快捷键）：在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完再停止，也就是把子函数整个作为一步。在不存在子函数的情况下是和step into效果一样的。\nstep into（F7快捷键）：在单步执行时，遇到子函数就进入并且继续单步执行，有的会跳到源代码里面去执行。\nstep into my code（Alt+Shift+F7快捷键）：在单步执行时，遇到子函数就进入并且继续单步执行，不会进入到源码中。\nstep out（Shift+F8快捷键）：假如进入了一个函数体中，看了两行代码，不想看了，跳出当前函数体内，返回到调用此函数的地方。\nResume program (F9快捷键)：恢复程序，直接运行到下一断点处。若无下一断点，则直接跑完程序。\n\n调试时带参数\n参考链接\n\n\nrun -&gt; edit configurations\n新建选择 python，name 随便写，script 选择要 debug 的文件，下方填要添加的参数，最下方选择 “debug” 点击即可\n\n\n\n\n","categories":["狠狠mark住"],"tags":["Python","Pytorch"]},{"title":"【代码随想录】二叉树6-二叉搜索树的属性","url":"/blog/Leetcode/tree5/","content":"700.二叉搜索树中的搜索\nlink\n\n给定二叉搜索树（BST）的根节点 root 和一个整数值 val。需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。\n二叉搜索树：每个节点都满足：左节点 &lt; 当前节点 &lt; 右节点。\n思路前序遍历当前树，判断是进入左子树还是右子树。迭代法较为简便，可以直接 return 来返回结果。\nclass Solution:    def searchBST(self, root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:        stack = []        if root:            stack.append(root)        while stack:            cur = stack.pop()            if cur.val == val:                return cur            elif cur.val &gt; val:                if cur.left:                    stack.append(cur.left)                else:                    return None                        elif cur.val &lt; val:                if cur.right:                    stack.append(cur.right)                else:                    return None\n\n更简便的方法：直接进行遍历，不需要使用栈来维护调用顺序\nclass Solution:    def searchBST(self, root: TreeNode, val: int) -&gt; TreeNode:        while root:            if val &lt; root.val: root = root.left            elif val &gt; root.val: root = root.right            else: return root        return None\n\n98.验证二叉搜索树\nlink\n\n给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。有效 二叉搜索树定义如下：\n\n节点的左子树只包含 小于 当前节点的数。\n节点的右子树只包含 大于 当前节点的数。\n所有左子树和右子树自身必须也是二叉搜索树。\n\n思路题目中暗含的是，判断当前节点是否满足，然后遍历左右子树，本质上是前序遍历。但是，不能单纯的比较左节点小于中间节点，右节点大于中间节点，要比较的是左子树所有节点小于中间节点，右子树所有节点大于中间节点。所以需要进行中序遍历。\n注意中序遍历下，二叉搜索树的结果为有序数组，所以只需要判断中序遍历的结果是否为有序数组即可。\nclass Solution:    def isValidBST(self, root: Optional[TreeNode]) -&gt; bool:        res = []        def eval(node):            if node.left:                eval(node.left)            res.append(node.val)            if node.right:                eval(node.right)        if root:            eval(root)        for i in range(len(res) - 1):            if res[i] &gt;= res[i+1]:                return False        return True\n\n也可以直接在中序遍历的过程中判断，只需要记录前一个访问的节点，然后判断是否是升序即可。\nclass Solution:    def isValidBST(self, root: Optional[TreeNode]) -&gt; bool:                res = []        stack = []        cur = root        pre = float(&#x27;-inf&#x27;)        while True:            while cur != None:                stack.append(cur)                cur = cur.left                        if len(stack) == 0:                break            cur = stack.pop()            if cur.val &lt;= pre:                return False            else:                pre = cur.val            cur = cur.right        return True\n\n（来自 gpt）此外，也可以维护一个区间，通过递归判断一个节点是否在指定的范围中：\nclass Solution:    def isValidBST(self, root: Optional[TreeNode]) -&gt; bool:        def validate(node, lower=float(&#x27;-inf&#x27;), upper=float(&#x27;inf&#x27;)):            if not node:                return True            if not (lower &lt; node.val &lt; upper):                return False            return (validate(node.left, lower, node.val) and                    validate(node.right, node.val, upper))        return validate(root)\n\n\n530.二叉搜索树的最小绝对差\nlink\n\n给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。差值是一个正数，其数值等于两值之差的绝对值。所有节点均为正数。\n思路中序遍历，然后在结果数组中依次判断相邻的节点。\n也可以像前一题一样记录上一次访问的数，直接判断。\nclass Solution:    def getMinimumDifference(self, root: Optional[TreeNode]) -&gt; int:        res = []        stack = []        cur = root        pre = None        mindif = float(&#x27;inf&#x27;)        while True:            while cur != None:                stack.append(cur)                cur = cur.left                        if len(stack) == 0:                break            cur = stack.pop()            if pre != None:                mindif = min(mindif, cur.val - pre)                       pre = cur.val            cur = cur.right        return mindif\n\n\n遇到在二叉搜索树上求什么最值，求差值之类的，都要思考一下二叉搜索树可是有序的，要利用好这一特点。\n501.二叉搜索树中的众数\nlink\n\n二叉搜索树放宽条件：\n\n结点左子树中所含节点的值 小于等于 当前节点的值\n结点右子树中所含节点的值 大于等于 当前节点的值\n左子树和右子树都是二叉搜索树\n\n思路简单做法仍然是在遍历结果中寻找。\n如果在遍历的过程中进行处理，中序遍历的结果是升序，所以和上一题一样，记录上一个值，如果相同则 count 加一。同时需要记录 maxcount，如果当前的 count 大于 maxcount，则将结果清空再加入当前元素。\nclass Solution:    def findMode(self, root: Optional[TreeNode]) -&gt; List[int]:        maxcount = 0        count = 0        res = []        stack = []        cur = root        pre = None        while True:            while cur!= None:                stack.append(cur)                cur = cur.left                        if len(stack) == 0:                break            cur = stack.pop()            if pre != None and pre == cur.val:                count += 1            else: # 有新数字出现 or 第一个数字                count = 1            if count &gt; maxcount:                res.clear()                res.append(cur.val)                maxcount = count            elif count == maxcount:                res.append(cur.val)            pre = cur.val            cur = cur.right        return res\n\n538.把二叉搜索树转换为累加树\nlink\n\n给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。\n思路节点 node 的新值等于原树中大于或等于 node.val 的值之和。而二叉搜索树中序遍历是升序排列。如果我们从右到左中序遍历（右 → 根 → 左），就会得到降序序列。就可以从大到小进行累加。\nclass Solution:    def convertBST(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:        stack = []        s = 0        cur = root        while True:            while cur:                stack.append(cur)                cur = cur.right                        if len(stack) == 0:                break            cur = stack.pop()            s += cur.val            cur.val = s            cur = cur.left                return root","categories":["Leetcode"],"tags":["tree"]},{"title":"git timeout 报错443解决方法","url":"/blog/Mark/git-443/","content":"\n参考链接\n\n解决方法\n查看代理的端口号（clash 的 General 菜单中，默认为7890）\n查看并取消 git 的 http 和 https 代理// 首先，查一下当前全局的 http 代理：git config --global http.proxy// 如果有代理，就取消git config --global --unset http.proxy // 再查 https 的代理：git config --global https.proxy// 同样的，有就取消git config --global --unset https.proxy\n设置代理//设置git端口号和上面的端口号保持一致git config --global http.proxy http://127.0.0.1:7890git config --global https.proxy https://127.0.0.1:7890\n\n","categories":["狠狠mark住"],"tags":["Git"]},{"title":"【代码随想录】二叉树5-公共祖先问题","url":"/blog/Leetcode/tree6/","content":"236. 二叉树的最近公共祖先\nlink\n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n\n输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1输出：3解释：节点 5 和节点 1 的最近公共祖先是节点 3 。  \n\n思路自底向上查找即可（回溯），后序遍历天然满足这个条件。接下来就看如何判断一个节点是节点q和节点p的公共祖先。\n首先最容易想到的一个情况：如果找到一个节点，发现左子树出现结点 p，右子树出现节点 q，或者 左子树出现结点 q，右子树出现节点 p，那么该节点就是节点 p 和 q 的最近公共祖先。 即情况一：\n\n判断逻辑是 如果递归遍历遇到 q，就将 q 返回，遇到 p 就将 p 返回，那么如果 左右子树的返回值都不为空，说明此时的中节点，一定是 q 和 p 的最近祖先。\n接着是情况二，q 或者 p 为祖先节点：\n\nclass Solution:    def lowestCommonAncestor(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; &#x27;TreeNode&#x27;:        def dfs(node):            # 找到p或者q，或者为空            if node == p or node == q or node == None:                return node            # 分别在左右子树去找            lres = dfs(node.left)            rres = dfs(node.right)            # 左边右边都找到了，直接返回当前节点            if lres and rres:                return node            # 在左（右）边找到，可能是找到p（q），            # 也可能是找到了公共节点，回溯去判断。            if lres:                return lres            if rres:                return rres            return None        return dfs(root)\n\n注意，情况 2 在第一个 if 就判断了，例如对于例子中的 6，判断不为 q 或者 p，则访问其子节点，左边直接返回 q，右边返回 None，此时就直接返回 q 为最终结果了。因为在左边查找到了一个节点，右边为空，则说明两个节点一定在一个子树上，所以直接返回找到的 q。\n235. 二叉搜索树的最近公共祖先\nlink\n\n在上一题的基础上添加了限制为二叉搜索树。\n思路搜索二叉树是有序的，所以最近公共子节点一定在区间 [q, p] 或者 [p, q] 中。那么只要从上到下去遍历，遇到 cur节点是数值在[p, q]区间中则一定可以说明该节点cur就是p 和 q的公共祖先。 那问题来了，一定是最近公共祖先吗？\n如图所示，首先遍历到 10，q p 都小于 10，则遍历左子树，第一次遇到 5，满足条件，p q 一定一个在左边一个在右边，如何再遍历，则后续节点都不是公共祖先了。\n\nclass Solution:    def lowestCommonAncestor(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; &#x27;TreeNode&#x27;:        stack = []        if root:            stack.append(root)        while stack:            cur = stack.pop()            if (min(q.val, p.val) &lt;= cur.val &lt;= max(q.val, p.val)):                return cur            if cur.val &gt; max(q.val, p.val):                stack.append(cur.left)             if cur.val &lt; min(q.val, p.val):                stack.append(cur.right)","categories":["Leetcode"],"tags":["tree"]},{"title":"hexo基本命令","url":"/blog/Mark/hexo-command/","content":"快速开始创建新博客$ hexo new &quot;My New Post&quot;\n\n\n运行服务器$ hexo server\n动态部署，修改代码实时更新。\n生成静态文件$ hexo generate\n\n远端部署$ hexo deploy\n\n\n清理缓存$ hexo clean\nDon’t forget to clean cache…\n标签插件链接到其他博客页面使用 post_link 标签。注意要以 &#x2F;_posts 文件夹为根路径。即使两个 post 在同一个子文件下，也需要写出子文件夹的名字，例如下面的 hello-world 页面位于 _post 文件夹下，就直接写文件名。\n&#123;% post_link 相对路径 &#x27;链接文字&#x27; %&#125;&lt;!-- &#123;% post_link hello-world &#x27;访问首页&#x27; %&#125; --&gt;\n访问首页\n\n引用块写法 1&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content&#123;% endblockquote %&#125;\nexample\nhexo-official代码块\n\n写法 2&gt; &gt; &gt; \n\n\n这是引用这是引用  \n\n注意这种方法的每一行后面要打连两个空格，用于换行\n写法 3某些情况下，引用块中需要缩进，上面两种方法都无法处理缩进，可以直接使用以下标签：\n&lt;blockquote&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/blockquote&gt;\n\n\n无缩进\n    四个字符（一个 tab）缩进\n        八个字符（两个 tab）缩进\n\n\n代码块&#123;% codeblock %&#125;alert(&#x27;Hello World!&#x27;);&#123;% endcodeblock %&#125;\n等同于使用反引号 \n``` your code ``` \n\n\nHexo新建文章到子目录hexo new 命令说明：\nUsage: hexo new [layout] &lt;title&gt;Description:Create a new post.Arguments:  layout  Post layout. Use post, page, draft or whatever you want.  title   Post title. Wrap it with quotations to escape.Options:  -p, --path     Post path. Customize the path of the post.  -r, --replace  Replace the current post if existed.  -s, --slug     Post slug. Customize the URL of the post.\n例如，在 202411/ 文件夹下新建 test.md 文件\nhexo n -p 202411/test.md\n\n","categories":["狠狠mark住"],"tags":["Hexo"]},{"title":"Huggingface 相关问题","url":"/blog/Mark/hf/","content":"更换 Huggingface 源\nexport HF_ENDPOINT&#x3D;https://hf-mirror.com\n\n一键下载 Huggingface 模型下载 huggingface-cli 。\n\nhuggingface-cli download model_name –local-dir .&#x2F;your_download_dir\n\n只需要更改 model_name 和 ./your_download_dir 。\n","categories":["狠狠mark住"],"tags":["LLM","Linux"]},{"title":"设置HTTP代理","url":"/blog/Mark/http-proxy/","content":"问题在 Ubuntu 设置中已经使用了手动代理，但是在终端中无效\n解决方法Ubuntu 的“设置 → 网络 → 代理”只会影响：\n\nGNOME 桌面环境中的 图形化应用程序（如 Firefox、Software Center）\n某些支持 GNOME D-Bus 代理自动检测的 GUI 软件\n\n但它不会自动影响：\n\n命令行工具（如 curl, wget, git, pip, requests, huggingface_hub）\nPython&#x2F;Conda 脚本运行环境\n后台服务进程（systemd 等）\n\n这些程序需要通过环境变量显式获取代理设置，命令如下：\nexport HTTP_PROXY=http://127.0.0.1:7890export HTTPS_PROXY=http://127.0.0.1:7890\n但是上述命令只是临时的，只对当前终端有效。可以使用以下命令写入配置文件：\necho &quot;export HTTP_PROXY=http://127.0.0.1:7890&quot; &gt;&gt; ~/.bashrcecho &quot;export HTTPS_PROXY=http://127.0.0.1:7890&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc\n","categories":["狠狠mark住"],"tags":["Linux"]},{"title":"Numpy 报错：numpy is not available","url":"/blog/Mark/numpy/","content":"描述报错如下：\n\nA module is compiled with numpy 1.X cannot be run in numpy 2.X\n\n解决方法换旧版本的 numpy\npip uninstall numpypip install numpy==1.25.3\n","categories":["狠狠mark住"],"tags":["Python","Pytorch"]},{"title":"Ubuntu 内核与 Nvidia 驱动不匹配问题","url":"/blog/Mark/nvidia-kernal/","content":"\n一定要关系自动更新！！\n卸载并安装驱动\nhttps://www.cnblogs.com/aliving/articles/18389099\n\n\n更改内核版本\nhttps://blog.csdn.net/damifeng/article/details/132985518\n\n查看可以安装的内核版本（机子上曾经下过的，不会删除）\n\ndpkg –get-selections|grep linux\n\n\n下载指定版本\n  sudo apt-get install linux-image-xxx-genericsudo apt-get install linux-headers-xxx-genericsudo apt-get install linux-modules-xxx-genericsudo apt-get install linux-modules-extra-xxx-genericsudo apt-get install linux-tools-xxx-generic\n更新 initramfs\n\nsudo update-initramfs -u -k all\n\n\n修改 grub，选择指定内核\n\nhttps://www.8kiz.cn/archives/14385.html\n开机狂按 shift，选择 advanced options\n\n\n一定要\n  sudo update-grub\n\n\n删除下载的内核（不是真的删除）\nhttps://download.csdn.net/blog/column/12270246/130411204\n\n\n\n","categories":["狠狠mark住"],"tags":["Linux"]},{"title":"【代码随想录】二叉树7-二叉搜索树的修改与改造","url":"/blog/Leetcode/tree7/","content":"701.二叉搜索树中的插入操作\nlink\n\n给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。\n注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。\n思路题目中说随便返回一种结果即可，所以可以一条路走到底，不用遍历整个树\nclass Solution:    def insertIntoBST(self, root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:        cur = root        node = TreeNode(val)        pre = None        if root == None:            return node        while cur:            pre = cur            if cur.val &gt; val:                cur = cur.left            else:                cur = cur.right        if pre.val &lt; val:            pre.right = node        else:            pre.left = node                    return root\n\n450.删除二叉搜索树中的节点\nlink\n\n给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n思路找到节点后，需要修改以当前节点为根节点的子树，判断其左右节点是否存在，可以按照如下修改：\n\n把左子树作为当前根节点，右子树放到原有左子树的最右边\n右子树作为当前根节点，左子树放到原有左子树的左边\n\n返回的值为更新后的子树\nclass Solution:    def deleteNode(self, root: Optional[TreeNode], key: int) -&gt; Optional[TreeNode]:        def dfs(node):            if not node:                return None            if node.val &gt; key:                node.left =  dfs(node.left)                return node                        if node.val &lt; key:                node.right = dfs(node.right)                return node                        if not node.left and not node.right:                return None            if not node.left and node.right:                return node.right            if node.left and not node.right:                return node.left                        cur = node.right            pre = node            while cur:                pre = cur                cur = cur.left            pre.left = node.left            return node.right        return dfs(root)\n\n669. 修剪二叉搜索树\nlink\n\n给你二叉搜索树的根节点 root ，同时给定最小边界 low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在 [low, high] 中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。\n思路直接的思路是判断当前节点是否在区间外，如果在区间左边就直接删除左子树，在区间右边就删除右子树。但是，子树里面可能有在区间内的节点，如图所示\n\n使用递归的方法，在遇到上述两种情况时，可以直接返回递归子树的结果。接下来就处理根节点在区间内的情况，即根节点的左右子树分别递归处理，并将返回结果赋值给左右指针。\nclass Solution:    def trimBST(self, root: Optional[TreeNode], low: int, high: int) -&gt; Optional[TreeNode]:                def dfs(node, l, h):            if not node:                return None            if node.val &gt; h:                return dfs(node.left, l, h)            if node.val &lt; l:                return dfs(node.right, l, h)                        # 当前节点在区间内            node.left = dfs(node.left, l, h)            node.right = dfs(node.right, l, h)            return node                return dfs(root, low, high)\n\n108.将有序数组转换为二叉搜索树\nlink\n\n将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\n\n思路递归调用：\n\n递归函数接受当前的区间，返回基于当前区间构建的子树\n当区间长度为 0 时就停止递归，返回空\n主要逻辑：\n找到区间中点，基于区间中点创建根节点\n划分区间，左区间构建左子树，右区间构建右子树\n将两个子树赋值给根节点\n\n\n\nclass Solution:    def sortedArrayToBST(self, nums: List[int]) -&gt; Optional[TreeNode]:                def dfs(num):            if len(num) == 0:                return None            index = len(num) // 2            root = TreeNode(num[index])            root.left = dfs(num[:index])            root.right = dfs(num[index+1:])            return root        return dfs(nums)","categories":["Leetcode"],"tags":["tree"]},{"title":"swanlab 使用","url":"/blog/Mark/swanlab/","content":"解决 wandb 无法访问的问题首先在环境中安装 swanlab，然后登录\npip install swanlabswanlab login\n\n然后在要运行的 Python 文件前加上以下代码，注意要在 wandb.init() 之前。\nimport swanlabswanlab.sync_wandb()\n\n最后把 wandb 设置为离线模式。在终端运行或者写在 bash 文件中均可。（写在 bash 文件中要给 offline 加引号）\nexport WANDB_MDOE=offline","categories":["狠狠mark住"],"tags":["Python"]}]